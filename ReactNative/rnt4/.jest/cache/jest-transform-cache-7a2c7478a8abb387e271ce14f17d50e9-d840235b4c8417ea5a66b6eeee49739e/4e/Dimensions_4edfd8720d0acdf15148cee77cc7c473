886fa0588b86a3ebd8f2ed5cc785e3e3


'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EventEmitter = require('EventEmitter');
var Platform = require('Platform');
var RCTDeviceEventEmitter = require('RCTDeviceEventEmitter');

var invariant = require('fbjs/lib/invariant');

var eventEmitter = new EventEmitter();
var dimensionsInitialized = false;
var dimensions = {};

var Dimensions = function () {
  function Dimensions() {
    _classCallCheck(this, Dimensions);
  }

  _createClass(Dimensions, null, [{
    key: 'set',
    value: function set(dims) {
      if (dims && dims.windowPhysicalPixels) {
        dims = JSON.parse(JSON.stringify(dims));

        var windowPhysicalPixels = dims.windowPhysicalPixels;
        dims.window = {
          width: windowPhysicalPixels.width / windowPhysicalPixels.scale,
          height: windowPhysicalPixels.height / windowPhysicalPixels.scale,
          scale: windowPhysicalPixels.scale,
          fontScale: windowPhysicalPixels.fontScale
        };
        if (Platform.OS === 'android') {
          var screenPhysicalPixels = dims.screenPhysicalPixels;
          dims.screen = {
            width: screenPhysicalPixels.width / screenPhysicalPixels.scale,
            height: screenPhysicalPixels.height / screenPhysicalPixels.scale,
            scale: screenPhysicalPixels.scale,
            fontScale: screenPhysicalPixels.fontScale
          };

          delete dims.screenPhysicalPixels;
        } else {
          dims.screen = dims.window;
        }

        delete dims.windowPhysicalPixels;
      }

      _extends(dimensions, dims);
      if (dimensionsInitialized) {
        eventEmitter.emit('change', {
          window: dimensions.window,
          screen: dimensions.screen
        });
      } else {
        dimensionsInitialized = true;
      }
    }
  }, {
    key: 'get',
    value: function get(dim) {
      invariant(dimensions[dim], 'No dimension set for key ' + dim);
      return dimensions[dim];
    }
  }, {
    key: 'addEventListener',
    value: function addEventListener(type, handler) {
      invariant(type === 'change', 'Trying to subscribe to unknown event: "%s"', type);
      eventEmitter.addListener(type, handler);
    }
  }, {
    key: 'removeEventListener',
    value: function removeEventListener(type, handler) {
      invariant(type === 'change', 'Trying to remove listener for unknown event: "%s"', type);
      eventEmitter.removeListener(type, handler);
    }
  }]);

  return Dimensions;
}();

var dims = global.nativeExtensions && global.nativeExtensions.DeviceInfo && global.nativeExtensions.DeviceInfo.Dimensions;
var nativeExtensionsEnabled = true;
if (!dims) {
  var DeviceInfo = require('DeviceInfo');
  dims = DeviceInfo.Dimensions;
  nativeExtensionsEnabled = false;
}

invariant(dims, 'Either DeviceInfo native extension or DeviceInfo Native Module must be registered');
Dimensions.set(dims);
if (!nativeExtensionsEnabled) {
  RCTDeviceEventEmitter.addListener('didUpdateDimensions', function (update) {
    Dimensions.set(update);
  });
}

module.exports = Dimensions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkRpbWVuc2lvbnMuanMiXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIlBsYXRmb3JtIiwiUkNURGV2aWNlRXZlbnRFbWl0dGVyIiwiaW52YXJpYW50IiwiZXZlbnRFbWl0dGVyIiwiZGltZW5zaW9uc0luaXRpYWxpemVkIiwiZGltZW5zaW9ucyIsIkRpbWVuc2lvbnMiLCJkaW1zIiwid2luZG93UGh5c2ljYWxQaXhlbHMiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ3aW5kb3ciLCJ3aWR0aCIsInNjYWxlIiwiaGVpZ2h0IiwiZm9udFNjYWxlIiwiT1MiLCJzY3JlZW5QaHlzaWNhbFBpeGVscyIsInNjcmVlbiIsImVtaXQiLCJkaW0iLCJ0eXBlIiwiaGFuZGxlciIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJnbG9iYWwiLCJuYXRpdmVFeHRlbnNpb25zIiwiRGV2aWNlSW5mbyIsIm5hdGl2ZUV4dGVuc2lvbnNFbmFibGVkIiwic2V0IiwidXBkYXRlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFVQTs7Ozs7Ozs7QUFFQSxJQUFNQSxlQUFlQyxRQUFRLGNBQVIsQ0FBckI7QUFDQSxJQUFNQyxXQUFXRCxRQUFRLFVBQVIsQ0FBakI7QUFDQSxJQUFNRSx3QkFBd0JGLFFBQVEsdUJBQVIsQ0FBOUI7O0FBRUEsSUFBTUcsWUFBWUgsUUFBUSxvQkFBUixDQUFsQjs7QUFFQSxJQUFNSSxlQUFlLElBQUlMLFlBQUosRUFBckI7QUFDQSxJQUFJTSx3QkFBd0IsS0FBNUI7QUFDQSxJQUFNQyxhQUFhLEVBQW5COztJQUNNQyxVOzs7Ozs7O3dCQU9PQyxJLEVBQWtDO0FBSTNDLFVBQUlBLFFBQVFBLEtBQUtDLG9CQUFqQixFQUF1QztBQUVyQ0QsZUFBT0UsS0FBS0MsS0FBTCxDQUFXRCxLQUFLRSxTQUFMLENBQWVKLElBQWYsQ0FBWCxDQUFQOztBQUVBLFlBQU1DLHVCQUF1QkQsS0FBS0Msb0JBQWxDO0FBQ0FELGFBQUtLLE1BQUwsR0FBYztBQUNaQyxpQkFBT0wscUJBQXFCSyxLQUFyQixHQUE2QkwscUJBQXFCTSxLQUQ3QztBQUVaQyxrQkFBUVAscUJBQXFCTyxNQUFyQixHQUE4QlAscUJBQXFCTSxLQUYvQztBQUdaQSxpQkFBT04scUJBQXFCTSxLQUhoQjtBQUlaRSxxQkFBV1IscUJBQXFCUTtBQUpwQixTQUFkO0FBTUEsWUFBSWhCLFNBQVNpQixFQUFULEtBQWdCLFNBQXBCLEVBQStCO0FBRTdCLGNBQU1DLHVCQUF1QlgsS0FBS1csb0JBQWxDO0FBQ0FYLGVBQUtZLE1BQUwsR0FBYztBQUNaTixtQkFBT0sscUJBQXFCTCxLQUFyQixHQUE2QksscUJBQXFCSixLQUQ3QztBQUVaQyxvQkFBUUcscUJBQXFCSCxNQUFyQixHQUE4QkcscUJBQXFCSixLQUYvQztBQUdaQSxtQkFBT0kscUJBQXFCSixLQUhoQjtBQUlaRSx1QkFBV0UscUJBQXFCRjtBQUpwQixXQUFkOztBQVFBLGlCQUFPVCxLQUFLVyxvQkFBWjtBQUNELFNBWkQsTUFZTztBQUNMWCxlQUFLWSxNQUFMLEdBQWNaLEtBQUtLLE1BQW5CO0FBQ0Q7O0FBRUQsZUFBT0wsS0FBS0Msb0JBQVo7QUFDRDs7QUFFRCxlQUFjSCxVQUFkLEVBQTBCRSxJQUExQjtBQUNBLFVBQUlILHFCQUFKLEVBQTJCO0FBRXpCRCxxQkFBYWlCLElBQWIsQ0FBa0IsUUFBbEIsRUFBNEI7QUFDMUJSLGtCQUFRUCxXQUFXTyxNQURPO0FBRTFCTyxrQkFBUWQsV0FBV2M7QUFGTyxTQUE1QjtBQUlELE9BTkQsTUFNTztBQUNMZixnQ0FBd0IsSUFBeEI7QUFDRDtBQUNGOzs7d0JBaUJVaUIsRyxFQUFxQjtBQUM5Qm5CLGdCQUFVRyxXQUFXZ0IsR0FBWCxDQUFWLEVBQTJCLDhCQUE4QkEsR0FBekQ7QUFDQSxhQUFPaEIsV0FBV2dCLEdBQVgsQ0FBUDtBQUNEOzs7cUNBVXVCQyxJLEVBQWNDLE8sRUFBbUI7QUFDdkRyQixnQkFDRW9CLFNBQVMsUUFEWCxFQUVFLDRDQUZGLEVBR0VBLElBSEY7QUFLQW5CLG1CQUFhcUIsV0FBYixDQUF5QkYsSUFBekIsRUFBK0JDLE9BQS9CO0FBQ0Q7Ozt3Q0FLMEJELEksRUFBY0MsTyxFQUFtQjtBQUMxRHJCLGdCQUNFb0IsU0FBUyxRQURYLEVBRUUsbURBRkYsRUFHRUEsSUFIRjtBQUtBbkIsbUJBQWFzQixjQUFiLENBQTRCSCxJQUE1QixFQUFrQ0MsT0FBbEM7QUFDRDs7Ozs7O0FBR0gsSUFBSWhCLE9BQ0ZtQixPQUFPQyxnQkFBUCxJQUNBRCxPQUFPQyxnQkFBUCxDQUF3QkMsVUFEeEIsSUFFQUYsT0FBT0MsZ0JBQVAsQ0FBd0JDLFVBQXhCLENBQW1DdEIsVUFIckM7QUFJQSxJQUFJdUIsMEJBQTBCLElBQTlCO0FBQ0EsSUFBSSxDQUFDdEIsSUFBTCxFQUFXO0FBQ1QsTUFBTXFCLGFBQWE3QixRQUFRLFlBQVIsQ0FBbkI7QUFDQVEsU0FBT3FCLFdBQVd0QixVQUFsQjtBQUNBdUIsNEJBQTBCLEtBQTFCO0FBQ0Q7O0FBRUQzQixVQUNFSyxJQURGLEVBRUUsbUZBRkY7QUFJQUQsV0FBV3dCLEdBQVgsQ0FBZXZCLElBQWY7QUFDQSxJQUFJLENBQUNzQix1QkFBTCxFQUE4QjtBQUM1QjVCLHdCQUFzQnVCLFdBQXRCLENBQWtDLHFCQUFsQyxFQUF5RCxVQUFTTyxNQUFULEVBQWlCO0FBQ3hFekIsZUFBV3dCLEdBQVgsQ0FBZUMsTUFBZjtBQUNELEdBRkQ7QUFHRDs7QUFFREMsT0FBT0MsT0FBUCxHQUFpQjNCLFVBQWpCIiwiZmlsZSI6IkRpbWVuc2lvbnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmb3JtYXRcbiAqIEBmbG93XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdFdmVudEVtaXR0ZXInKTtcbmNvbnN0IFBsYXRmb3JtID0gcmVxdWlyZSgnUGxhdGZvcm0nKTtcbmNvbnN0IFJDVERldmljZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ1JDVERldmljZUV2ZW50RW1pdHRlcicpO1xuXG5jb25zdCBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuY29uc3QgZXZlbnRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xubGV0IGRpbWVuc2lvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuY29uc3QgZGltZW5zaW9ucyA9IHt9O1xuY2xhc3MgRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIG5hdGl2ZSBjb2RlIGJ5IHNlbmRpbmcgdGhlXG4gICAqIGRpZFVwZGF0ZURpbWVuc2lvbnMgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkaW1zIFNpbXBsZSBzdHJpbmcta2V5ZWQgb2JqZWN0IG9mIGRpbWVuc2lvbnMgdG8gc2V0XG4gICAqL1xuICBzdGF0aWMgc2V0KGRpbXM6IHtba2V5OiBzdHJpbmddOiBhbnl9KTogdm9pZCB7XG4gICAgLy8gV2UgY2FsY3VsYXRlIHRoZSB3aW5kb3cgZGltZW5zaW9ucyBpbiBKUyBzbyB0aGF0IHdlIGRvbid0IGVuY291bnRlciBsb3NzIG9mXG4gICAgLy8gcHJlY2lzaW9uIGluIHRyYW5zZmVycmluZyB0aGUgZGltZW5zaW9ucyAod2hpY2ggY291bGQgYmUgbm9uLWludGVnZXJzKSBvdmVyXG4gICAgLy8gdGhlIGJyaWRnZS5cbiAgICBpZiAoZGltcyAmJiBkaW1zLndpbmRvd1BoeXNpY2FsUGl4ZWxzKSB7XG4gICAgICAvLyBwYXJzZS9zdHJpbmdpZnkgPT4gQ2xvbmUgaGFja1xuICAgICAgZGltcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGltcykpO1xuXG4gICAgICBjb25zdCB3aW5kb3dQaHlzaWNhbFBpeGVscyA9IGRpbXMud2luZG93UGh5c2ljYWxQaXhlbHM7XG4gICAgICBkaW1zLndpbmRvdyA9IHtcbiAgICAgICAgd2lkdGg6IHdpbmRvd1BoeXNpY2FsUGl4ZWxzLndpZHRoIC8gd2luZG93UGh5c2ljYWxQaXhlbHMuc2NhbGUsXG4gICAgICAgIGhlaWdodDogd2luZG93UGh5c2ljYWxQaXhlbHMuaGVpZ2h0IC8gd2luZG93UGh5c2ljYWxQaXhlbHMuc2NhbGUsXG4gICAgICAgIHNjYWxlOiB3aW5kb3dQaHlzaWNhbFBpeGVscy5zY2FsZSxcbiAgICAgICAgZm9udFNjYWxlOiB3aW5kb3dQaHlzaWNhbFBpeGVscy5mb250U2NhbGUsXG4gICAgICB9O1xuICAgICAgaWYgKFBsYXRmb3JtLk9TID09PSAnYW5kcm9pZCcpIHtcbiAgICAgICAgLy8gU2NyZWVuIGFuZCB3aW5kb3cgZGltZW5zaW9ucyBhcmUgZGlmZmVyZW50IG9uIGFuZHJvaWRcbiAgICAgICAgY29uc3Qgc2NyZWVuUGh5c2ljYWxQaXhlbHMgPSBkaW1zLnNjcmVlblBoeXNpY2FsUGl4ZWxzO1xuICAgICAgICBkaW1zLnNjcmVlbiA9IHtcbiAgICAgICAgICB3aWR0aDogc2NyZWVuUGh5c2ljYWxQaXhlbHMud2lkdGggLyBzY3JlZW5QaHlzaWNhbFBpeGVscy5zY2FsZSxcbiAgICAgICAgICBoZWlnaHQ6IHNjcmVlblBoeXNpY2FsUGl4ZWxzLmhlaWdodCAvIHNjcmVlblBoeXNpY2FsUGl4ZWxzLnNjYWxlLFxuICAgICAgICAgIHNjYWxlOiBzY3JlZW5QaHlzaWNhbFBpeGVscy5zY2FsZSxcbiAgICAgICAgICBmb250U2NhbGU6IHNjcmVlblBoeXNpY2FsUGl4ZWxzLmZvbnRTY2FsZSxcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBkZWxldGUgc28gbm8gY2FsbGVycyByZWx5IG9uIHRoaXMgZXhpc3RpbmdcbiAgICAgICAgZGVsZXRlIGRpbXMuc2NyZWVuUGh5c2ljYWxQaXhlbHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaW1zLnNjcmVlbiA9IGRpbXMud2luZG93O1xuICAgICAgfVxuICAgICAgLy8gZGVsZXRlIHNvIG5vIGNhbGxlcnMgcmVseSBvbiB0aGlzIGV4aXN0aW5nXG4gICAgICBkZWxldGUgZGltcy53aW5kb3dQaHlzaWNhbFBpeGVscztcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGRpbWVuc2lvbnMsIGRpbXMpO1xuICAgIGlmIChkaW1lbnNpb25zSW5pdGlhbGl6ZWQpIHtcbiAgICAgIC8vIERvbid0IGZpcmUgJ2NoYW5nZScgdGhlIGZpcnN0IHRpbWUgdGhlIGRpbWVuc2lvbnMgYXJlIHNldC5cbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB7XG4gICAgICAgIHdpbmRvdzogZGltZW5zaW9ucy53aW5kb3csXG4gICAgICAgIHNjcmVlbjogZGltZW5zaW9ucy5zY3JlZW4sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGltZW5zaW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbCBkaW1lbnNpb25zIGFyZSBzZXQgYmVmb3JlIGBydW5BcHBsaWNhdGlvbmAgaXMgY2FsbGVkIHNvIHRoZXkgc2hvdWxkXG4gICAqIGJlIGF2YWlsYWJsZSBiZWZvcmUgYW55IG90aGVyIHJlcXVpcmUncyBhcmUgcnVuLCBidXQgbWF5IGJlIHVwZGF0ZWQgbGF0ZXIuXG4gICAqXG4gICAqIE5vdGU6IEFsdGhvdWdoIGRpbWVuc2lvbnMgYXJlIGF2YWlsYWJsZSBpbW1lZGlhdGVseSwgdGhleSBtYXkgY2hhbmdlIChlLmdcbiAgICogZHVlIHRvIGRldmljZSByb3RhdGlvbikgc28gYW55IHJlbmRlcmluZyBsb2dpYyBvciBzdHlsZXMgdGhhdCBkZXBlbmQgb25cbiAgICogdGhlc2UgY29uc3RhbnRzIHNob3VsZCB0cnkgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIGV2ZXJ5IHJlbmRlciwgcmF0aGVyXG4gICAqIHRoYW4gY2FjaGluZyB0aGUgdmFsdWUgKGZvciBleGFtcGxlLCB1c2luZyBpbmxpbmUgc3R5bGVzIHJhdGhlciB0aGFuXG4gICAqIHNldHRpbmcgYSB2YWx1ZSBpbiBhIGBTdHlsZVNoZWV0YCkuXG4gICAqXG4gICAqIEV4YW1wbGU6IGB2YXIge2hlaWdodCwgd2lkdGh9ID0gRGltZW5zaW9ucy5nZXQoJ3dpbmRvdycpO2BcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRpbSBOYW1lIG9mIGRpbWVuc2lvbiBhcyBkZWZpbmVkIHdoZW4gY2FsbGluZyBgc2V0YC5cbiAgICogQHJldHVybnMge09iamVjdD99IFZhbHVlIGZvciB0aGUgZGltZW5zaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldChkaW06IHN0cmluZyk6IE9iamVjdCB7XG4gICAgaW52YXJpYW50KGRpbWVuc2lvbnNbZGltXSwgJ05vIGRpbWVuc2lvbiBzZXQgZm9yIGtleSAnICsgZGltKTtcbiAgICByZXR1cm4gZGltZW5zaW9uc1tkaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBoYW5kbGVyLiBTdXBwb3J0ZWQgZXZlbnRzOlxuICAgKlxuICAgKiAtIGBjaGFuZ2VgOiBGaXJlcyB3aGVuIGEgcHJvcGVydHkgd2l0aGluIHRoZSBgRGltZW5zaW9uc2Agb2JqZWN0IGNoYW5nZXMuIFRoZSBhcmd1bWVudFxuICAgKiAgIHRvIHRoZSBldmVudCBoYW5kbGVyIGlzIGFuIG9iamVjdCB3aXRoIGB3aW5kb3dgIGFuZCBgc2NyZWVuYCBwcm9wZXJ0aWVzIHdob3NlIHZhbHVlc1xuICAgKiAgIGFyZSB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuIHZhbHVlcyBvZiBgRGltZW5zaW9ucy5nZXQoJ3dpbmRvdycpYCBhbmRcbiAgICogICBgRGltZW5zaW9ucy5nZXQoJ3NjcmVlbicpYCwgcmVzcGVjdGl2ZWx5LlxuICAgKi9cbiAgc3RhdGljIGFkZEV2ZW50TGlzdGVuZXIodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbikge1xuICAgIGludmFyaWFudChcbiAgICAgIHR5cGUgPT09ICdjaGFuZ2UnLFxuICAgICAgJ1RyeWluZyB0byBzdWJzY3JpYmUgdG8gdW5rbm93biBldmVudDogXCIlc1wiJyxcbiAgICAgIHR5cGUsXG4gICAgKTtcbiAgICBldmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuXG4gICAqL1xuICBzdGF0aWMgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdHlwZSA9PT0gJ2NoYW5nZScsXG4gICAgICAnVHJ5aW5nIHRvIHJlbW92ZSBsaXN0ZW5lciBmb3IgdW5rbm93biBldmVudDogXCIlc1wiJyxcbiAgICAgIHR5cGUsXG4gICAgKTtcbiAgICBldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH1cbn1cblxubGV0IGRpbXM6ID97W2tleTogc3RyaW5nXTogYW55fSA9XG4gIGdsb2JhbC5uYXRpdmVFeHRlbnNpb25zICYmXG4gIGdsb2JhbC5uYXRpdmVFeHRlbnNpb25zLkRldmljZUluZm8gJiZcbiAgZ2xvYmFsLm5hdGl2ZUV4dGVuc2lvbnMuRGV2aWNlSW5mby5EaW1lbnNpb25zO1xubGV0IG5hdGl2ZUV4dGVuc2lvbnNFbmFibGVkID0gdHJ1ZTtcbmlmICghZGltcykge1xuICBjb25zdCBEZXZpY2VJbmZvID0gcmVxdWlyZSgnRGV2aWNlSW5mbycpO1xuICBkaW1zID0gRGV2aWNlSW5mby5EaW1lbnNpb25zO1xuICBuYXRpdmVFeHRlbnNpb25zRW5hYmxlZCA9IGZhbHNlO1xufVxuXG5pbnZhcmlhbnQoXG4gIGRpbXMsXG4gICdFaXRoZXIgRGV2aWNlSW5mbyBuYXRpdmUgZXh0ZW5zaW9uIG9yIERldmljZUluZm8gTmF0aXZlIE1vZHVsZSBtdXN0IGJlIHJlZ2lzdGVyZWQnLFxuKTtcbkRpbWVuc2lvbnMuc2V0KGRpbXMpO1xuaWYgKCFuYXRpdmVFeHRlbnNpb25zRW5hYmxlZCkge1xuICBSQ1REZXZpY2VFdmVudEVtaXR0ZXIuYWRkTGlzdGVuZXIoJ2RpZFVwZGF0ZURpbWVuc2lvbnMnLCBmdW5jdGlvbih1cGRhdGUpIHtcbiAgICBEaW1lbnNpb25zLnNldCh1cGRhdGUpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEaW1lbnNpb25zO1xuIl19