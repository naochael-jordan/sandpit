fa136cc89de39ac73fc108ad10494a40

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AnimatedNode = require('./AnimatedNode');
var AnimatedWithChildren = require('./AnimatedWithChildren');
var NativeAnimatedHelper = require('../NativeAnimatedHelper');

var invariant = require('fbjs/lib/invariant');
var normalizeColor = require('normalizeColor');

var linear = function linear(t) {
  return t;
};

function createInterpolation(config) {
  if (config.outputRange && typeof config.outputRange[0] === 'string') {
    return createInterpolationFromStringOutputRange(config);
  }

  var outputRange = config.outputRange;
  checkInfiniteRange('outputRange', outputRange);

  var inputRange = config.inputRange;
  checkInfiniteRange('inputRange', inputRange);
  checkValidInputRange(inputRange);

  invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');

  var easing = config.easing || linear;

  var extrapolateLeft = 'extend';
  if (config.extrapolateLeft !== undefined) {
    extrapolateLeft = config.extrapolateLeft;
  } else if (config.extrapolate !== undefined) {
    extrapolateLeft = config.extrapolate;
  }

  var extrapolateRight = 'extend';
  if (config.extrapolateRight !== undefined) {
    extrapolateRight = config.extrapolateRight;
  } else if (config.extrapolate !== undefined) {
    extrapolateRight = config.extrapolate;
  }

  return function (input) {
    invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');

    var range = findRange(input, inputRange);
    return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
  };
}

function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
  var result = input;

  if (result < inputMin) {
    if (extrapolateLeft === 'identity') {
      return result;
    } else if (extrapolateLeft === 'clamp') {
      result = inputMin;
    } else if (extrapolateLeft === 'extend') {}
  }

  if (result > inputMax) {
    if (extrapolateRight === 'identity') {
      return result;
    } else if (extrapolateRight === 'clamp') {
      result = inputMax;
    } else if (extrapolateRight === 'extend') {}
  }

  if (outputMin === outputMax) {
    return outputMin;
  }

  if (inputMin === inputMax) {
    if (input <= inputMin) {
      return outputMin;
    }
    return outputMax;
  }

  if (inputMin === -Infinity) {
    result = -result;
  } else if (inputMax === Infinity) {
    result = result - inputMin;
  } else {
    result = (result - inputMin) / (inputMax - inputMin);
  }

  result = easing(result);

  if (outputMin === -Infinity) {
    result = -result;
  } else if (outputMax === Infinity) {
    result = result + outputMin;
  } else {
    result = result * (outputMax - outputMin) + outputMin;
  }

  return result;
}

function colorToRgba(input) {
  var int32Color = normalizeColor(input);
  if (int32Color === null) {
    return input;
  }

  int32Color = int32Color || 0;

  var r = (int32Color & 0xff000000) >>> 24;
  var g = (int32Color & 0x00ff0000) >>> 16;
  var b = (int32Color & 0x0000ff00) >>> 8;
  var a = (int32Color & 0x000000ff) / 255;

  return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
}

var stringShapeRegex = /[0-9\.-]+/g;

function createInterpolationFromStringOutputRange(config) {
  var outputRange = config.outputRange;
  invariant(outputRange.length >= 2, 'Bad output range');
  outputRange = outputRange.map(colorToRgba);
  checkPattern(outputRange);

  var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
    return [];
  });
  outputRange.forEach(function (value) {
    value.match(stringShapeRegex).forEach(function (number, i) {
      outputRanges[i].push(+number);
    });
  });

  var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
    return createInterpolation(_extends({}, config, {
      outputRange: outputRanges[i]
    }));
  });

  var shouldRound = isRgbOrRgba(outputRange[0]);

  return function (input) {
    var i = 0;

    return outputRange[0].replace(stringShapeRegex, function () {
      var val = +interpolations[i++](input);
      var rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
      return String(rounded);
    });
  };
}

function isRgbOrRgba(range) {
  return typeof range === 'string' && range.startsWith('rgb');
}

function checkPattern(arr) {
  var pattern = arr[0].replace(stringShapeRegex, '');
  for (var i = 1; i < arr.length; ++i) {
    invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
  }
}

function findRange(input, inputRange) {
  var i = void 0;
  for (i = 1; i < inputRange.length - 1; ++i) {
    if (inputRange[i] >= input) {
      break;
    }
  }
  return i - 1;
}

function checkValidInputRange(arr) {
  invariant(arr.length >= 2, 'inputRange must have at least 2 elements');
  for (var i = 1; i < arr.length; ++i) {
    invariant(arr[i] >= arr[i - 1], 'inputRange must be monotonically non-decreasing ' + arr);
  }
}

function checkInfiniteRange(name, arr) {
  invariant(arr.length >= 2, name + ' must have at least 2 elements');
  invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity, name + 'cannot be ]-infinity;+infinity[ ' + arr);
}

var AnimatedInterpolation = function (_AnimatedWithChildren) {
  _inherits(AnimatedInterpolation, _AnimatedWithChildren);

  function AnimatedInterpolation(parent, config) {
    _classCallCheck(this, AnimatedInterpolation);

    var _this = _possibleConstructorReturn(this, (AnimatedInterpolation.__proto__ || Object.getPrototypeOf(AnimatedInterpolation)).call(this));

    _this._parent = parent;
    _this._config = config;
    _this._interpolation = createInterpolation(config);
    return _this;
  }

  _createClass(AnimatedInterpolation, [{
    key: '__makeNative',
    value: function __makeNative() {
      this._parent.__makeNative();
      _get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), '__makeNative', this).call(this);
    }
  }, {
    key: '__getValue',
    value: function __getValue() {
      var parentValue = this._parent.__getValue();
      invariant(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');
      return this._interpolation(parentValue);
    }
  }, {
    key: 'interpolate',
    value: function interpolate(config) {
      return new AnimatedInterpolation(this, config);
    }
  }, {
    key: '__attach',
    value: function __attach() {
      this._parent.__addChild(this);
    }
  }, {
    key: '__detach',
    value: function __detach() {
      this._parent.__removeChild(this);
      _get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), '__detach', this).call(this);
    }
  }, {
    key: '__transformDataType',
    value: function __transformDataType(range) {
      return range.map(function (value) {
        if (typeof value !== 'string') {
          return value;
        }
        if (/deg$/.test(value)) {
          var degrees = parseFloat(value) || 0;
          var radians = degrees * Math.PI / 180.0;
          return radians;
        } else {
          return parseFloat(value) || 0;
        }
      });
    }
  }, {
    key: '__getNativeConfig',
    value: function __getNativeConfig() {
      if (__DEV__) {
        NativeAnimatedHelper.validateInterpolation(this._config);
      }

      return {
        inputRange: this._config.inputRange,

        outputRange: this.__transformDataType(this._config.outputRange),
        extrapolateLeft: this._config.extrapolateLeft || this._config.extrapolate || 'extend',
        extrapolateRight: this._config.extrapolateRight || this._config.extrapolate || 'extend',
        type: 'interpolation'
      };
    }
  }]);

  return AnimatedInterpolation;
}(AnimatedWithChildren);

AnimatedInterpolation.__createInterpolation = createInterpolation;


module.exports = AnimatedInterpolation;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkFuaW1hdGVkSW50ZXJwb2xhdGlvbi5qcyJdLCJuYW1lcyI6WyJBbmltYXRlZE5vZGUiLCJyZXF1aXJlIiwiQW5pbWF0ZWRXaXRoQ2hpbGRyZW4iLCJOYXRpdmVBbmltYXRlZEhlbHBlciIsImludmFyaWFudCIsIm5vcm1hbGl6ZUNvbG9yIiwibGluZWFyIiwidCIsImNyZWF0ZUludGVycG9sYXRpb24iLCJjb25maWciLCJvdXRwdXRSYW5nZSIsImNyZWF0ZUludGVycG9sYXRpb25Gcm9tU3RyaW5nT3V0cHV0UmFuZ2UiLCJjaGVja0luZmluaXRlUmFuZ2UiLCJpbnB1dFJhbmdlIiwiY2hlY2tWYWxpZElucHV0UmFuZ2UiLCJsZW5ndGgiLCJlYXNpbmciLCJleHRyYXBvbGF0ZUxlZnQiLCJ1bmRlZmluZWQiLCJleHRyYXBvbGF0ZSIsImV4dHJhcG9sYXRlUmlnaHQiLCJpbnB1dCIsInJhbmdlIiwiZmluZFJhbmdlIiwiaW50ZXJwb2xhdGUiLCJpbnB1dE1pbiIsImlucHV0TWF4Iiwib3V0cHV0TWluIiwib3V0cHV0TWF4IiwicmVzdWx0IiwiSW5maW5pdHkiLCJjb2xvclRvUmdiYSIsImludDMyQ29sb3IiLCJyIiwiZyIsImIiLCJhIiwic3RyaW5nU2hhcGVSZWdleCIsIm1hcCIsImNoZWNrUGF0dGVybiIsIm91dHB1dFJhbmdlcyIsIm1hdGNoIiwiZm9yRWFjaCIsInZhbHVlIiwibnVtYmVyIiwiaSIsInB1c2giLCJpbnRlcnBvbGF0aW9ucyIsInNob3VsZFJvdW5kIiwiaXNSZ2JPclJnYmEiLCJyZXBsYWNlIiwidmFsIiwicm91bmRlZCIsIk1hdGgiLCJyb3VuZCIsIlN0cmluZyIsInN0YXJ0c1dpdGgiLCJhcnIiLCJwYXR0ZXJuIiwibmFtZSIsIkFuaW1hdGVkSW50ZXJwb2xhdGlvbiIsInBhcmVudCIsIl9wYXJlbnQiLCJfY29uZmlnIiwiX2ludGVycG9sYXRpb24iLCJfX21ha2VOYXRpdmUiLCJwYXJlbnRWYWx1ZSIsIl9fZ2V0VmFsdWUiLCJfX2FkZENoaWxkIiwiX19yZW1vdmVDaGlsZCIsInRlc3QiLCJkZWdyZWVzIiwicGFyc2VGbG9hdCIsInJhZGlhbnMiLCJQSSIsIl9fREVWX18iLCJ2YWxpZGF0ZUludGVycG9sYXRpb24iLCJfX3RyYW5zZm9ybURhdGFUeXBlIiwidHlwZSIsIl9fY3JlYXRlSW50ZXJwb2xhdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7QUFVQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxlQUFlQyxRQUFRLGdCQUFSLENBQXJCO0FBQ0EsSUFBTUMsdUJBQXVCRCxRQUFRLHdCQUFSLENBQTdCO0FBQ0EsSUFBTUUsdUJBQXVCRixRQUFRLHlCQUFSLENBQTdCOztBQUVBLElBQU1HLFlBQVlILFFBQVEsb0JBQVIsQ0FBbEI7QUFDQSxJQUFNSSxpQkFBaUJKLFFBQVEsZ0JBQVIsQ0FBdkI7O0FBaUJBLElBQU1LLFNBQVMsU0FBVEEsTUFBUztBQUFBLFNBQUtDLENBQUw7QUFBQSxDQUFmOztBQU1BLFNBQVNDLG1CQUFULENBQ0VDLE1BREYsRUFFc0M7QUFDcEMsTUFBSUEsT0FBT0MsV0FBUCxJQUFzQixPQUFPRCxPQUFPQyxXQUFQLENBQW1CLENBQW5CLENBQVAsS0FBaUMsUUFBM0QsRUFBcUU7QUFDbkUsV0FBT0MseUNBQXlDRixNQUF6QyxDQUFQO0FBQ0Q7O0FBRUQsTUFBTUMsY0FBOEJELE9BQU9DLFdBQTNDO0FBQ0FFLHFCQUFtQixhQUFuQixFQUFrQ0YsV0FBbEM7O0FBRUEsTUFBTUcsYUFBYUosT0FBT0ksVUFBMUI7QUFDQUQscUJBQW1CLFlBQW5CLEVBQWlDQyxVQUFqQztBQUNBQyx1QkFBcUJELFVBQXJCOztBQUVBVCxZQUNFUyxXQUFXRSxNQUFYLEtBQXNCTCxZQUFZSyxNQURwQyxFQUVFLGlCQUNFRixXQUFXRSxNQURiLEdBRUUscUJBRkYsR0FHRUwsWUFBWUssTUFIZCxHQUlFLDZCQU5KOztBQVNBLE1BQU1DLFNBQVNQLE9BQU9PLE1BQVAsSUFBaUJWLE1BQWhDOztBQUVBLE1BQUlXLGtCQUFt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ZCxPQUFMLENBQWFyRCxXQUF0QyxDQUhSO0FBSUxPLHlCQUNFLEtBQUs4QyxPQUFMLENBQWE5QyxlQUFiLElBQWdDLEtBQUs4QyxPQUFMLENBQWE1QyxXQUE3QyxJQUE0RCxRQUx6RDtBQU1MQywwQkFDRSxLQUFLMkMsT0FBTCxDQUFhM0MsZ0JBQWIsSUFBaUMsS0FBSzJDLE9BQUwsQ0FBYTVDLFdBQTlDLElBQTZELFFBUDFEO0FBUUwyRCxjQUFNO0FBUkQsT0FBUDtBQVVEOzs7O0VBOUVpQzVFLG9COztBQUE5QjBELHFCLENBRUdtQixxQixHQUF3QnZFLG1COzs7QUErRWpDd0UsT0FBT0MsT0FBUCxHQUFpQnJCLHFCQUFqQiIsImZpbGUiOiJBbmltYXRlZEludGVycG9sYXRpb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmbG93XG4gKiBAZm9ybWF0XG4gKi9cbi8qIGVzbGludCBuby1iaXR3aXNlOiAwICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFuaW1hdGVkTm9kZSA9IHJlcXVpcmUoJy4vQW5pbWF0ZWROb2RlJyk7XG5jb25zdCBBbmltYXRlZFdpdGhDaGlsZHJlbiA9IHJlcXVpcmUoJy4vQW5pbWF0ZWRXaXRoQ2hpbGRyZW4nKTtcbmNvbnN0IE5hdGl2ZUFuaW1hdGVkSGVscGVyID0gcmVxdWlyZSgnLi4vTmF0aXZlQW5pbWF0ZWRIZWxwZXInKTtcblxuY29uc3QgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5jb25zdCBub3JtYWxpemVDb2xvciA9IHJlcXVpcmUoJ25vcm1hbGl6ZUNvbG9yJyk7XG5cbnR5cGUgRXh0cmFwb2xhdGVUeXBlID0gJ2V4dGVuZCcgfCAnaWRlbnRpdHknIHwgJ2NsYW1wJztcblxuZXhwb3J0IHR5cGUgSW50ZXJwb2xhdGlvbkNvbmZpZ1R5cGUgPSB7XG4gIGlucHV0UmFuZ2U6IEFycmF5PG51bWJlcj4sXG4gIC8qICRGbG93Rml4TWUoPj0wLjM4LjAgc2l0ZT1yZWFjdF9uYXRpdmVfZmIscmVhY3RfbmF0aXZlX29zcykgLSBGbG93IGVycm9yXG4gICAqIGRldGVjdGVkIGR1cmluZyB0aGUgZGVwbG95bWVudCBvZiB2MC4zOC4wLiBUbyBzZWUgdGhlIGVycm9yLCByZW1vdmUgdGhpc1xuICAgKiBjb21tZW50IGFuZCBydW4gZmxvd1xuICAgKi9cbiAgb3V0cHV0UmFuZ2U6IEFycmF5PG51bWJlcj4gfCBBcnJheTxzdHJpbmc+LFxuICBlYXNpbmc/OiAoaW5wdXQ6IG51bWJlcikgPT4gbnVtYmVyLFxuICBleHRyYXBvbGF0ZT86IEV4dHJhcG9sYXRlVHlwZSxcbiAgZXh0cmFwb2xhdGVMZWZ0PzogRXh0cmFwb2xhdGVUeXBlLFxuICBleHRyYXBvbGF0ZVJpZ2h0PzogRXh0cmFwb2xhdGVUeXBlLFxufTtcblxuY29uc3QgbGluZWFyID0gdCA9PiB0O1xuXG4vKipcbiAqIFZlcnkgaGFuZHkgaGVscGVyIHRvIG1hcCBpbnB1dCByYW5nZXMgdG8gb3V0cHV0IHJhbmdlcyB3aXRoIGFuIGVhc2luZ1xuICogZnVuY3Rpb24gYW5kIGN1c3RvbSBiZWhhdmlvciBvdXRzaWRlIG9mIHRoZSByYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb24oXG4gIGNvbmZpZzogSW50ZXJwb2xhdGlvbkNvbmZpZ1R5cGUsXG4pOiAoaW5wdXQ6IG51bWJlcikgPT4gbnVtYmVyIHwgc3RyaW5nIHtcbiAgaWYgKGNvbmZpZy5vdXRwdXRSYW5nZSAmJiB0eXBlb2YgY29uZmlnLm91dHB1dFJhbmdlWzBdID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjcmVhdGVJbnRlcnBvbGF0aW9uRnJvbVN0cmluZ091dHB1dFJhbmdlKGNvbmZpZyk7XG4gIH1cblxuICBjb25zdCBvdXRwdXRSYW5nZTogQXJyYXk8bnVtYmVyPiA9IChjb25maWcub3V0cHV0UmFuZ2U6IGFueSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZSgnb3V0cHV0UmFuZ2UnLCBvdXRwdXRSYW5nZSk7XG5cbiAgY29uc3QgaW5wdXRSYW5nZSA9IGNvbmZpZy5pbnB1dFJhbmdlO1xuICBjaGVja0luZmluaXRlUmFuZ2UoJ2lucHV0UmFuZ2UnLCBpbnB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG5cbiAgaW52YXJpYW50KFxuICAgIGlucHV0UmFuZ2UubGVuZ3RoID09PSBvdXRwdXRSYW5nZS5sZW5ndGgsXG4gICAgJ2lucHV0UmFuZ2UgKCcgK1xuICAgICAgaW5wdXRSYW5nZS5sZW5ndGggK1xuICAgICAgJykgYW5kIG91dHB1dFJhbmdlICgnICtcbiAgICAgIG91dHB1dFJhbmdlLmxlbmd0aCArXG4gICAgICAnKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyxcbiAgKTtcblxuICBjb25zdCBlYXNpbmcgPSBjb25maWcuZWFzaW5nIHx8IGxpbmVhcjtcblxuICBsZXQgZXh0cmFwb2xhdGVMZWZ0OiBFeHRyYXBvbGF0ZVR5cGUgPSAnZXh0ZW5kJztcbiAgaWYgKGNvbmZpZy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IGNvbmZpZy5leHRyYXBvbGF0ZUxlZnQ7XG4gIH0gZWxzZSBpZiAoY29uZmlnLmV4dHJhcG9sYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBjb25maWcuZXh0cmFwb2xhdGU7XG4gIH1cblxuICBsZXQgZXh0cmFwb2xhdGVSaWdodDogRXh0cmFwb2xhdGVUeXBlID0gJ2V4dGVuZCc7XG4gIGlmIChjb25maWcuZXh0cmFwb2xhdGVSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVSaWdodCA9IGNvbmZpZy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9IGVsc2UgaWYgKGNvbmZpZy5leHRyYXBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZXh0cmFwb2xhdGVSaWdodCA9IGNvbmZpZy5leHRyYXBvbGF0ZTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dCA9PiB7XG4gICAgaW52YXJpYW50KFxuICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyxcbiAgICAgICdDYW5ub3QgaW50ZXJwb2xhdGlvbiBhbiBpbnB1dCB3aGljaCBpcyBub3QgYSBudW1iZXInLFxuICAgICk7XG5cbiAgICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKFxuICAgICAgaW5wdXQsXG4gICAgICBpbnB1dFJhbmdlW3JhbmdlXSxcbiAgICAgIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXSxcbiAgICAgIG91dHB1dFJhbmdlW3JhbmdlXSxcbiAgICAgIG91dHB1dFJhbmdlW3JhbmdlICsgMV0sXG4gICAgICBlYXNpbmcsXG4gICAgICBleHRyYXBvbGF0ZUxlZnQsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0LFxuICAgICk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKFxuICBpbnB1dDogbnVtYmVyLFxuICBpbnB1dE1pbjogbnVtYmVyLFxuICBpbnB1dE1heDogbnVtYmVyLFxuICBvdXRwdXRNaW46IG51bWJlcixcbiAgb3V0cHV0TWF4OiBudW1iZXIsXG4gIGVhc2luZzogKGlucHV0OiBudW1iZXIpID0+IG51bWJlcixcbiAgZXh0cmFwb2xhdGVMZWZ0OiBFeHRyYXBvbGF0ZVR5cGUsXG4gIGV4dHJhcG9sYXRlUmlnaHQ6IEV4dHJhcG9sYXRlVHlwZSxcbikge1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG5cbiAgLy8gRXh0cmFwb2xhdGVcbiAgaWYgKHJlc3VsdCA8IGlucHV0TWluKSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gJ2NsYW1wJykge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdleHRlbmQnKSB7XG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgaWYgKHJlc3VsdCA+IGlucHV0TWF4KSB7XG4gICAgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09ICdpZGVudGl0eScpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSAnY2xhbXAnKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09ICdleHRlbmQnKSB7XG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuXG4gIGlmIChpbnB1dE1pbiA9PT0gaW5wdXRNYXgpIHtcbiAgICBpZiAoaW5wdXQgPD0gaW5wdXRNaW4pIHtcbiAgICAgIHJldHVybiBvdXRwdXRNaW47XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRNYXg7XG4gIH1cblxuICAvLyBJbnB1dCBSYW5nZVxuICBpZiAoaW5wdXRNaW4gPT09IC1JbmZpbml0eSkge1xuICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gIH0gZWxzZSBpZiAoaW5wdXRNYXggPT09IEluZmluaXR5KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IC0gaW5wdXRNaW47XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHJlc3VsdCAtIGlucHV0TWluKSAvIChpbnB1dE1heCAtIGlucHV0TWluKTtcbiAgfVxuXG4gIC8vIEVhc2luZ1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcblxuICAvLyBPdXRwdXQgUmFuZ2VcbiAgaWYgKG91dHB1dE1pbiA9PT0gLUluZmluaXR5KSB7XG4gICAgcmVzdWx0ID0gLXJlc3VsdDtcbiAgfSBlbHNlIGlmIChvdXRwdXRNYXggPT09IEluZmluaXR5KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgb3V0cHV0TWluO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IHJlc3VsdCAqIChvdXRwdXRNYXggLSBvdXRwdXRNaW4pICsgb3V0cHV0TWluO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29sb3JUb1JnYmEoaW5wdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBpbnQzMkNvbG9yID0gbm9ybWFsaXplQ29sb3IoaW5wdXQpO1xuICBpZiAoaW50MzJDb2xvciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGludDMyQ29sb3IgPSBpbnQzMkNvbG9yIHx8IDA7XG5cbiAgY29uc3QgciA9IChpbnQzMkNvbG9yICYgMHhmZjAwMDAwMCkgPj4+IDI0O1xuICBjb25zdCBnID0gKGludDMyQ29sb3IgJiAweDAwZmYwMDAwKSA+Pj4gMTY7XG4gIGNvbnN0IGIgPSAoaW50MzJDb2xvciAmIDB4MDAwMGZmMDApID4+PiA4O1xuICBjb25zdCBhID0gKGludDMyQ29sb3IgJiAweDAwMDAwMGZmKSAvIDI1NTtcblxuICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthfSlgO1xufVxuXG5jb25zdCBzdHJpbmdTaGFwZVJlZ2V4ID0gL1swLTlcXC4tXSsvZztcblxuLyoqXG4gKiBTdXBwb3J0cyBzdHJpbmcgc2hhcGVzIGJ5IGV4dHJhY3RpbmcgbnVtYmVycyBzbyBuZXcgdmFsdWVzIGNhbiBiZSBjb21wdXRlZCxcbiAqIGFuZCByZWNvbWJpbmVzIHRob3NlIHZhbHVlcyBpbnRvIG5ldyBzdHJpbmdzIG9mIHRoZSBzYW1lIHNoYXBlLiAgU3VwcG9ydHNcbiAqIHRoaW5ncyBsaWtlOlxuICpcbiAqICAgcmdiYSgxMjMsIDQyLCA5OSwgMC4zNikgLy8gY29sb3JzXG4gKiAgIC00NWRlZyAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyB3aXRoIHVuaXRzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRpb25Gcm9tU3RyaW5nT3V0cHV0UmFuZ2UoXG4gIGNvbmZpZzogSW50ZXJwb2xhdGlvbkNvbmZpZ1R5cGUsXG4pOiAoaW5wdXQ6IG51bWJlcikgPT4gc3RyaW5nIHtcbiAgbGV0IG91dHB1dFJhbmdlOiBBcnJheTxzdHJpbmc+ID0gKGNvbmZpZy5vdXRwdXRSYW5nZTogYW55KTtcbiAgaW52YXJpYW50KG91dHB1dFJhbmdlLmxlbmd0aCA+PSAyLCAnQmFkIG91dHB1dCByYW5nZScpO1xuICBvdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcChjb2xvclRvUmdiYSk7XG4gIGNoZWNrUGF0dGVybihvdXRwdXRSYW5nZSk7XG5cbiAgLy8gWydyZ2JhKDAsIDEwMCwgMjAwLCAwKScsICdyZ2JhKDUwLCAxNTAsIDI1MCwgMC41KSddXG4gIC8vIC0+XG4gIC8vIFtcbiAgLy8gICBbMCwgNTBdLFxuICAvLyAgIFsxMDAsIDE1MF0sXG4gIC8vICAgWzIwMCwgMjUwXSxcbiAgLy8gICBbMCwgMC41XSxcbiAgLy8gXVxuICAvKiAkRmxvd0ZpeE1lKD49MC4xOC4wKTogYG91dHB1dFJhbmdlWzBdLm1hdGNoKClgIGNhbiByZXR1cm4gYG51bGxgLiBOZWVkIHRvXG4gICAqIGd1YXJkIGFnYWluc3QgdGhpcyBwb3NzaWJpbGl0eS5cbiAgICovXG4gIGNvbnN0IG91dHB1dFJhbmdlcyA9IG91dHB1dFJhbmdlWzBdLm1hdGNoKHN0cmluZ1NoYXBlUmVnZXgpLm1hcCgoKSA9PiBbXSk7XG4gIG91dHB1dFJhbmdlLmZvckVhY2godmFsdWUgPT4ge1xuICAgIC8qICRGbG93Rml4TWUoPj0wLjE4LjApOiBgdmFsdWUubWF0Y2goKWAgY2FuIHJldHVybiBgbnVsbGAuIE5lZWQgdG8gZ3VhcmRcbiAgICAgKiBhZ2FpbnN0IHRoaXMgcG9zc2liaWxpdHkuXG4gICAgICovXG4gICAgdmFsdWUubWF0Y2goc3RyaW5nU2hhcGVSZWdleCkuZm9yRWFjaCgobnVtYmVyLCBpKSA9PiB7XG4gICAgICBvdXRwdXRSYW5nZXNbaV0ucHVzaCgrbnVtYmVyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyogJEZsb3dGaXhNZSg+PTAuMTguMCk6IGBvdXRwdXRSYW5nZVswXS5tYXRjaCgpYCBjYW4gcmV0dXJuIGBudWxsYC4gTmVlZCB0b1xuICAgKiBndWFyZCBhZ2FpbnN0IHRoaXMgcG9zc2liaWxpdHkuXG4gICAqL1xuICBjb25zdCBpbnRlcnBvbGF0aW9ucyA9IG91dHB1dFJhbmdlWzBdXG4gICAgLm1hdGNoKHN0cmluZ1NoYXBlUmVnZXgpXG4gICAgLm1hcCgodmFsdWUsIGkpID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVJbnRlcnBvbGF0aW9uKHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBvdXRwdXRSYW5nZTogb3V0cHV0UmFuZ2VzW2ldLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgLy8gcmdiYSByZXF1aXJlcyB0aGF0IHRoZSByLGcsYiBhcmUgaW50ZWdlcnMuLi4uIHNvIHdlIHdhbnQgdG8gcm91bmQgdGhlbSwgYnV0IHdlICpkb250KiB3YW50IHRvXG4gIC8vIHJvdW5kIHRoZSBvcGFjaXR5ICg0dGggY29sdW1uKS5cbiAgY29uc3Qgc2hvdWxkUm91bmQgPSBpc1JnYk9yUmdiYShvdXRwdXRSYW5nZVswXSk7XG5cbiAgcmV0dXJuIGlucHV0ID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gJ3JnYmEoMCwgMTAwLCAyMDAsIDApJ1xuICAgIC8vIC0+XG4gICAgLy8gJ3JnYmEoJHtpbnRlcnBvbGF0aW9uc1swXShpbnB1dCl9LCAke2ludGVycG9sYXRpb25zWzFdKGlucHV0KX0sIC4uLidcbiAgICByZXR1cm4gb3V0cHV0UmFuZ2VbMF0ucmVwbGFjZShzdHJpbmdTaGFwZVJlZ2V4LCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSAraW50ZXJwb2xhdGlvbnNbaSsrXShpbnB1dCk7XG4gICAgICBjb25zdCByb3VuZGVkID1cbiAgICAgICAgc2hvdWxkUm91bmQgJiYgaSA8IDQgPyBNYXRoLnJvdW5kKHZhbCkgOiBNYXRoLnJvdW5kKHZhbCAqIDEwMDApIC8gMTAwMDtcbiAgICAgIHJldHVybiBTdHJpbmcocm91bmRlZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzUmdiT3JSZ2JhKHJhbmdlKSB7XG4gIHJldHVybiB0eXBlb2YgcmFuZ2UgPT09ICdzdHJpbmcnICYmIHJhbmdlLnN0YXJ0c1dpdGgoJ3JnYicpO1xufVxuXG5mdW5jdGlvbiBjaGVja1BhdHRlcm4oYXJyOiBBcnJheTxzdHJpbmc+KSB7XG4gIGNvbnN0IHBhdHRlcm4gPSBhcnJbMF0ucmVwbGFjZShzdHJpbmdTaGFwZVJlZ2V4LCAnJyk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgcGF0dGVybiA9PT0gYXJyW2ldLnJlcGxhY2Uoc3RyaW5nU2hhcGVSZWdleCwgJycpLFxuICAgICAgJ2ludmFsaWQgcGF0dGVybiAnICsgYXJyWzBdICsgJyBhbmQgJyArIGFycltpXSxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dDogbnVtYmVyLCBpbnB1dFJhbmdlOiBBcnJheTxudW1iZXI+KSB7XG4gIGxldCBpO1xuICBmb3IgKGkgPSAxOyBpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cblxuZnVuY3Rpb24gY2hlY2tWYWxpZElucHV0UmFuZ2UoYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gIGludmFyaWFudChhcnIubGVuZ3RoID49IDIsICdpbnB1dFJhbmdlIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzJyk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgYXJyW2ldID49IGFycltpIC0gMV0sXG4gICAgICAvKiAkRmxvd0ZpeE1lKD49MC4xMy4wKSAtIEluIHRoZSBhZGRpdGlvbiBleHByZXNzaW9uIGJlbG93IHRoaXMgY29tbWVudCxcbiAgICAgICAqIG9uZSBvciBib3RoIG9mIHRoZSBvcGVyYW5kcyBtYXkgYmUgc29tZXRoaW5nIHRoYXQgZG9lc24ndCBjbGVhbmx5XG4gICAgICAgKiBjb252ZXJ0IHRvIGEgc3RyaW5nLCBsaWtlIHVuZGVmaW5lZCwgbnVsbCwgYW5kIG9iamVjdCwgZXRjLiBJZiB5b3UgcmVhbGx5XG4gICAgICAgKiBtZWFuIHRoaXMgaW1wbGljaXQgc3RyaW5nIGNvbnZlcnNpb24sIHlvdSBjYW4gZG8gc29tZXRoaW5nIGxpa2VcbiAgICAgICAqIFN0cmluZyhteVRoaW5nKVxuICAgICAgICovXG4gICAgICAnaW5wdXRSYW5nZSBtdXN0IGJlIG1vbm90b25pY2FsbHkgbm9uLWRlY3JlYXNpbmcgJyArIGFycixcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5maW5pdGVSYW5nZShuYW1lOiBzdHJpbmcsIGFycjogQXJyYXk8bnVtYmVyPikge1xuICBpbnZhcmlhbnQoYXJyLmxlbmd0aCA+PSAyLCBuYW1lICsgJyBtdXN0IGhhdmUgYXQgbGVhc3QgMiBlbGVtZW50cycpO1xuICBpbnZhcmlhbnQoXG4gICAgYXJyLmxlbmd0aCAhPT0gMiB8fCBhcnJbMF0gIT09IC1JbmZpbml0eSB8fCBhcnJbMV0gIT09IEluZmluaXR5LFxuICAgIC8qICRGbG93Rml4TWUoPj0wLjEzLjApIC0gSW4gdGhlIGFkZGl0aW9uIGV4cHJlc3Npb24gYmVsb3cgdGhpcyBjb21tZW50LFxuICAgICAqIG9uZSBvciBib3RoIG9mIHRoZSBvcGVyYW5kcyBtYXkgYmUgc29tZXRoaW5nIHRoYXQgZG9lc24ndCBjbGVhbmx5IGNvbnZlcnRcbiAgICAgKiB0byBhIHN0cmluZywgbGlrZSB1bmRlZmluZWQsIG51bGwsIGFuZCBvYmplY3QsIGV0Yy4gSWYgeW91IHJlYWxseSBtZWFuXG4gICAgICogdGhpcyBpbXBsaWNpdCBzdHJpbmcgY29udmVyc2lvbiwgeW91IGNhbiBkbyBzb21ldGhpbmcgbGlrZVxuICAgICAqIFN0cmluZyhteVRoaW5nKVxuICAgICAqL1xuICAgIG5hbWUgKyAnY2Fubm90IGJlIF0taW5maW5pdHk7K2luZmluaXR5WyAnICsgYXJyLFxuICApO1xufVxuXG5jbGFzcyBBbmltYXRlZEludGVycG9sYXRpb24gZXh0ZW5kcyBBbmltYXRlZFdpdGhDaGlsZHJlbiB7XG4gIC8vIEV4cG9ydCBmb3IgdGVzdGluZy5cbiAgc3RhdGljIF9fY3JlYXRlSW50ZXJwb2xhdGlvbiA9IGNyZWF0ZUludGVycG9sYXRpb247XG5cbiAgX3BhcmVudDogQW5pbWF0ZWROb2RlO1xuICBfY29uZmlnOiBJbnRlcnBvbGF0aW9uQ29uZmlnVHlwZTtcbiAgX2ludGVycG9sYXRpb246IChpbnB1dDogbnVtYmVyKSA9PiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocGFyZW50OiBBbmltYXRlZE5vZGUsIGNvbmZpZzogSW50ZXJwb2xhdGlvbkNvbmZpZ1R5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5faW50ZXJwb2xhdGlvbiA9IGNyZWF0ZUludGVycG9sYXRpb24oY29uZmlnKTtcbiAgfVxuXG4gIF9fbWFrZU5hdGl2ZSgpIHtcbiAgICB0aGlzLl9wYXJlbnQuX19tYWtlTmF0aXZlKCk7XG4gICAgc3VwZXIuX19tYWtlTmF0aXZlKCk7XG4gIH1cblxuICBfX2dldFZhbHVlKCk6IG51bWJlciB8IHN0cmluZyB7XG4gICAgY29uc3QgcGFyZW50VmFsdWU6IG51bWJlciA9IHRoaXMuX3BhcmVudC5fX2dldFZhbHVlKCk7XG4gICAgaW52YXJpYW50KFxuICAgICAgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICdDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyLicsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGlvbihwYXJlbnRWYWx1ZSk7XG4gIH1cblxuICBpbnRlcnBvbGF0ZShjb25maWc6IEludGVycG9sYXRpb25Db25maWdUeXBlKTogQW5pbWF0ZWRJbnRlcnBvbGF0aW9uIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkSW50ZXJwb2xhdGlvbih0aGlzLCBjb25maWcpO1xuICB9XG5cbiAgX19hdHRhY2goKTogdm9pZCB7XG4gICAgdGhpcy5fcGFyZW50Ll9fYWRkQ2hpbGQodGhpcyk7XG4gIH1cblxuICBfX2RldGFjaCgpOiB2b2lkIHtcbiAgICB0aGlzLl9wYXJlbnQuX19yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICBzdXBlci5fX2RldGFjaCgpO1xuICB9XG5cbiAgX190cmFuc2Zvcm1EYXRhVHlwZShyYW5nZTogQXJyYXk8YW55Pikge1xuICAgIC8vIENoYW5nZSB0aGUgc3RyaW5nIGFycmF5IHR5cGUgdG8gbnVtYmVyIGFycmF5XG4gICAgLy8gU28gd2UgY2FuIHJldXNlIHRoZSBzYW1lIGxvZ2ljIGluIGlPUyBhbmQgQW5kcm9pZCBwbGF0Zm9ybVxuICAgIC8qICRGbG93Rml4TWUoPj0wLjcwLjAgc2l0ZT1yZWFjdF9uYXRpdmVfZmIpIFRoaXMgY29tbWVudCBzdXBwcmVzc2VzIGFuXG4gICAgICogZXJyb3IgZm91bmQgd2hlbiBGbG93IHYwLjcwIHdhcyBkZXBsb3llZC4gVG8gc2VlIHRoZSBlcnJvciBkZWxldGUgdGhpc1xuICAgICAqIGNvbW1lbnQgYW5kIHJ1biBGbG93LiAqL1xuICAgIHJldHVybiByYW5nZS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgvZGVnJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZGVncmVlcyA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgICAgIGNvbnN0IHJhZGlhbnMgPSAoZGVncmVlcyAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICAgIHJldHVybiByYWRpYW5zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXNzdW1lIHJhZGlhbnNcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfX2dldE5hdGl2ZUNvbmZpZygpOiBhbnkge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICBOYXRpdmVBbmltYXRlZEhlbHBlci52YWxpZGF0ZUludGVycG9sYXRpb24odGhpcy5fY29uZmlnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRSYW5nZTogdGhpcy5fY29uZmlnLmlucHV0UmFuZ2UsXG4gICAgICAvLyBPbmx5IHRoZSBgb3V0cHV0UmFuZ2VgIGNhbiBjb250YWluIHN0cmluZ3Mgc28gd2UgZG9uJ3QgbmVlZCB0byB0cmFuc2Zvcm0gYGlucHV0UmFuZ2VgIGhlcmVcbiAgICAgIG91dHB1dFJhbmdlOiB0aGlzLl9fdHJhbnNmb3JtRGF0YVR5cGUodGhpcy5fY29uZmlnLm91dHB1dFJhbmdlKSxcbiAgICAgIGV4dHJhcG9sYXRlTGVmdDpcbiAgICAgICAgdGhpcy5fY29uZmlnLmV4dHJhcG9sYXRlTGVmdCB8fCB0aGlzLl9jb25maWcuZXh0cmFwb2xhdGUgfHwgJ2V4dGVuZCcsXG4gICAgICBleHRyYXBvbGF0ZVJpZ2h0OlxuICAgICAgICB0aGlzLl9jb25maWcuZXh0cmFwb2xhdGVSaWdodCB8fCB0aGlzLl9jb25maWcuZXh0cmFwb2xhdGUgfHwgJ2V4dGVuZCcsXG4gICAgICB0eXBlOiAnaW50ZXJwb2xhdGlvbicsXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGVkSW50ZXJwb2xhdGlvbjtcbiJdfQ==