240552480a23f0b9d31a87f008b29da3


'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _shouldPolyfillES6Collection = require('_shouldPolyfillES6Collection');
var guid = require('guid');
var isNode = require('fbjs/lib/isNode');
var toIterator = require('toIterator');

module.exports = function (global, undefined) {
  if (!_shouldPolyfillES6Collection('Map')) {
    return global.Map;
  }

  var KIND_KEY = 'key';
  var KIND_VALUE = 'value';
  var KIND_KEY_VALUE = 'key+value';

  var KEY_PREFIX = '$map_';

  var SECRET_SIZE_PROP = void 0;
  if (__DEV__) {
    SECRET_SIZE_PROP = '$size' + guid();
  }

  var OLD_IE_HASH_PREFIX = 'IE_HASH_';

  var Map = function () {
    function Map(iterable) {
      _classCallCheck(this, Map);

      if (!isObject(this)) {
        throw new TypeError('Wrong map object type.');
      }

      initMap(this);

      if (iterable != null) {
        var it = toIterator(iterable);
        var next = void 0;
        while (!(next = it.next()).done) {
          if (!isObject(next.value)) {
            throw new TypeError('Expected iterable items to be pair objects.');
          }
          this.set(next.value[0], next.value[1]);
        }
      }
    }

    _createClass(Map, [{
      key: 'clear',
      value: function clear() {
        initMap(this);
      }
    }, {
      key: 'has',
      value: function has(key) {
        var index = getIndex(this, key);
        return !!(index != null && this._mapData[index]);
      }
    }, {
      key: 'set',
      value: function set(key, value) {
        var index = getIndex(this, key);

        if (index != null && this._mapData[index]) {
          this._mapData[index][1] = value;
        } else {
          index = this._mapData.push([key, value]) - 1;
          setIndex(this, key, index);
          if (__DEV__) {
            this[SECRET_SIZE_PROP] += 1;
          } else {
            this.size += 1;
          }
        }

        return this;
      }
    }, {
      key: 'get',
      value: function get(key) {
        var index = getIndex(this, key);
        if (index == null) {
          return undefined;
        } else {
          return this._mapData[index][1];
        }
      }
    }, {
      key: 'delete',
      value: function _delete(key) {
        var index = getIndex(this, key);
        if (index != null && this._mapData[index]) {
          setIndex(this, key, undefined);
          this._mapData[index] = undefined;
          if (__DEV__) {
            this[SECRET_SIZE_PROP] -= 1;
          } else {
            this.size -= 1;
          }
          return true;
        } else {
          return false;
        }
      }
    }, {
      key: 'entries',
      value: function entries() {
        return new MapIterator(this, KIND_KEY_VALUE);
      }
    }, {
      key: 'keys',
      value: function keys() {
        return new MapIterator(this, KIND_KEY);
      }
    }, {
      key: 'values',
      value: function values() {
        return new MapIterator(this, KIND_VALUE);
      }
    }, {
      key: 'forEach',
      value: function forEach(callback, thisArg) {
        if (typeof callback !== 'function') {
          throw new TypeError('Callback must be callable.');
        }

        var boundCallback = callback.bind(thisArg || undefined);
        var mapData = this._mapData;

        for (var i = 0; i < mapData.length; i++) {
          var entry = mapData[i];
          if (entry != null) {
            boundCallback(entry[1], entry[0], this);
          }
        }
      }
    }]);

    return Map;
  }();

  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;

  var MapIterator = function () {
    function MapIterator(map, kind) {
      _classCallCheck(this, MapIterator);

      if (!(isObject(map) && map._mapData)) {
        throw new TypeError('Object is not a map.');
      }

      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {
        throw new Error('Invalid iteration kind.');
      }

      this._map = map;
      this._nextIndex = 0;
      this._kind = kind;
    }

    _createClass(MapIterator, [{
      key: 'next',
      value: function next() {
        if (!this instanceof Map) {
          throw new TypeError('Expected to be called on a MapIterator.');
        }

        var map = this._map;
        var index = this._nextIndex;
        var kind = this._kind;

        if (map == null) {
          return createIterResultObject(undefined, true);
        }

        var entries = map._mapData;

        while (index < entries.length) {
          var record = entries[index];

          index += 1;
          this._nextIndex = index;

          if (record) {
            if (kind === KIND_KEY) {
              return createIterResultObject(record[0], false);
            } else if (kind === KIND_VALUE) {
              return createIterResultObject(record[1], false);
            } else if (kind) {
              return createIterResultObject(record, false);
            }
          }
        }

        this._map = undefined;

        return createIterResultObject(undefined, true);
      }
    }]);

    return MapIterator;
  }();

  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function () {
    return this;
  };

  function getIndex(map, key) {
    if (isObject(key)) {
      var hash = getHash(key);
      return map._objectIndex[hash];
    } else {
      var prefixedKey = KEY_PREFIX + key;
      if (typeof key === 'string') {
        return map._stringIndex[prefixedKey];
      } else {
        return map._otherIndex[prefixedKey];
      }
    }
  }

  function setIndex(map, key, index) {
    var shouldDelete = index == null;

    if (isObject(key)) {
      var hash = getHash(key);
      if (shouldDelete) {
        delete map._objectIndex[hash];
      } else {
        map._objectIndex[hash] = index;
      }
    } else {
      var prefixedKey = KEY_PREFIX + key;
      if (typeof key === 'string') {
        if (shouldDelete) {
          delete map._stringIndex[prefixedKey];
        } else {
          map._stringIndex[prefixedKey] = index;
        }
      } else {
        if (shouldDelete) {
          delete map._otherIndex[prefixedKey];
        } else {
          map._otherIndex[prefixedKey] = index;
        }
      }
    }
  }

  function initMap(map) {
    map._mapData = [];

    map._objectIndex = {};

    map._stringIndex = {};

    map._otherIndex = {};

    if (__DEV__) {
      if (isES5) {
        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {
          map[SECRET_SIZE_PROP] = 0;
        } else {
          Object.defineProperty(map, SECRET_SIZE_PROP, {
            value: 0,
            writable: true
          });
          Object.defineProperty(map, 'size', {
            set: function set(v) {
              console.error('PLEASE FIX ME: You are changing the map size property which ' + 'should not be writable and will break in production.');
              throw new Error('The map size property is not writable.');
            },
            get: function get() {
              return map[SECRET_SIZE_PROP];
            }
          });
        }

        return;
      }
    }

    map.size = 0;
  }

  function isObject(o) {
    return o != null && (typeof o === 'object' || typeof o === 'function');
  }

  function createIterResultObject(value, done) {
    return { value: value, done: done };
  }

  var isES5 = function () {
    try {
      Object.defineProperty({}, 'x', {});
      return true;
    } catch (e) {
      return false;
    }
  }();

  function isExtensible(o) {
    if (!isES5) {
      return true;
    } else {
      return Object.isExtensible(o);
    }
  }

  function getIENodeHash(node) {
    var uniqueID = void 0;
    switch (node.nodeType) {
      case 1:
        uniqueID = node.uniqueID;
        break;
      case 9:
        uniqueID = node.documentElement.uniqueID;
        break;
      default:
        return null;
    }

    if (uniqueID) {
      return OLD_IE_HASH_PREFIX + uniqueID;
    } else {
      return null;
    }
  }

  var getHash = function () {
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    var hashProperty = guid();
    var hashCounter = 0;

    return function getHash(o) {
      if (o[hashProperty]) {
        return o[hashProperty];
      } else if (!isES5 && o.propertyIsEnumerable && o.propertyIsEnumerable[hashProperty]) {
        return o.propertyIsEnumerable[hashProperty];
      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {
        return getIENodeHash(o);
      } else if (!isES5 && o[hashProperty]) {
        return o[hashProperty];
      }

      if (isExtensible(o)) {
        hashCounter += 1;
        if (isES5) {
          Object.defineProperty(o, hashProperty, {
            enumerable: false,
            writable: false,
            configurable: false,
            value: hashCounter
          });
        } else if (o.propertyIsEnumerable) {
          o.propertyIsEnumerable = function () {
            return propIsEnumerable.apply(this, arguments);
          };
          o.propertyIsEnumerable[hashProperty] = hashCounter;
        } else if (isNode(o)) {
          o[hashProperty] = hashCounter;
        } else {
          throw new Error('Unable to set a non-enumerable property on object.');
        }
        return hashCounter;
      } else {
        throw new Error('Non-extensible objects are not allowed as keys.');
      }
    };
  }();

  return Map;
}(Function('return this')());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIk1hcC5qcyJdLCJuYW1lcyI6WyJfc2hvdWxkUG9seWZpbGxFUzZDb2xsZWN0aW9uIiwicmVxdWlyZSIsImd1aWQiLCJpc05vZGUiLCJ0b0l0ZXJhdG9yIiwibW9kdWxlIiwiZXhwb3J0cyIsImdsb2JhbCIsInVuZGVmaW5lZCIsIk1hcCIsIktJTkRfS0VZIiwiS0lORF9WQUxVRSIsIktJTkRfS0VZX1ZBTFVFIiwiS0VZX1BSRUZJWCIsIlNFQ1JFVF9TSVpFX1BST1AiLCJfX0RFVl9fIiwiT0xEX0lFX0hBU0hfUFJFRklYIiwiaXRlcmFibGUiLCJpc09iamVjdCIsIlR5cGVFcnJvciIsImluaXRNYXAiLCJpdCIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJzZXQiLCJrZXkiLCJpbmRleCIsImdldEluZGV4IiwiX21hcERhdGEiLCJwdXNoIiwic2V0SW5kZXgiLCJzaXplIiwiTWFwSXRlcmF0b3IiLCJjYWxsYmFjayIsInRoaXNBcmciLCJib3VuZENhbGxiYWNrIiwiYmluZCIsIm1hcERhdGEiLCJpIiwibGVuZ3RoIiwiZW50cnkiLCJwcm90b3R5cGUiLCJJVEVSQVRPUl9TWU1CT0wiLCJlbnRyaWVzIiwibWFwIiwia2luZCIsImluZGV4T2YiLCJFcnJvciIsIl9tYXAiLCJfbmV4dEluZGV4IiwiX2tpbmQiLCJjcmVhdGVJdGVyUmVzdWx0T2JqZWN0IiwicmVjb3JkIiwiaGFzaCIsImdldEhhc2giLCJfb2JqZWN0SW5kZXgiLCJwcmVmaXhlZEtleSIsIl9zdHJpbmdJbmRleCIsIl9vdGhlckluZGV4Iiwic2hvdWxkRGVsZXRlIiwiaXNFUzUiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXQiLCJvIiwiZSIsImlzRXh0ZW5zaWJsZSIsImdldElFTm9kZUhhc2giLCJub2RlIiwidW5pcXVlSUQiLCJub2RlVHlwZSIsImRvY3VtZW50RWxlbWVudCIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImhhc2hQcm9wZXJ0eSIsImhhc2hDb3VudGVyIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImFwcGx5IiwiYXJndW1lbnRzIiwiRnVuY3Rpb24iXSwibWFwcGluZ3MiOiI7O0FBYUE7Ozs7OztBQUVBLElBQU1BLCtCQUErQkMsUUFBUSw4QkFBUixDQUFyQztBQUNBLElBQU1DLE9BQU9ELFFBQVEsTUFBUixDQUFiO0FBQ0EsSUFBTUUsU0FBU0YsUUFBUSxpQkFBUixDQUFmO0FBQ0EsSUFBTUcsYUFBYUgsUUFBUSxZQUFSLENBQW5COztBQUVBSSxPQUFPQyxPQUFQLEdBQWtCLFVBQVNDLE1BQVQsRUFBaUJDLFNBQWpCLEVBQTRCO0FBSzVDLE1BQUksQ0FBQ1IsNkJBQTZCLEtBQTdCLENBQUwsRUFBMEM7QUFDeEMsV0FBT08sT0FBT0UsR0FBZDtBQUNEOztBQXlERCxNQUFNQyxXQUFXLEtBQWpCO0FBQ0EsTUFBTUMsYUFBYSxPQUFuQjtBQUNBLE1BQU1DLGlCQUFpQixXQUF2Qjs7QUFJQSxNQUFNQyxhQUFhLE9BQW5COztBQUlBLE1BQUlDLHlCQUFKO0FBQ0EsTUFBSUMsT0FBSixFQUFhO0FBQ1hELHVCQUFtQixVQUFVWixNQUE3QjtBQUNEOztBQUdELE1BQU1jLHFCQUFxQixVQUEzQjs7QUFoRjRDLE1Ba0Z0Q1AsR0FsRnNDO0FBNEYxQyxpQkFBWVEsUUFBWixFQUFzQjtBQUFBOztBQUNwQixVQUFJLENBQUNDLFNBQVMsSUFBVCxDQUFMLEVBQXFCO0FBQ25CLGNBQU0sSUFBSUMsU0FBSixDQUFjLHdCQUFkLENBQU47QUFDRDs7QUFFREMsY0FBUSxJQUFSOztBQUVBLFVBQUlILFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsWUFBTUksS0FBS2pCLFdBQVdhLFFBQVgsQ0FBWDtBQUNBLFlBQUlLLGFBQUo7QUFDQSxlQUFPLENBQUMsQ0FBQ0EsT0FBT0QsR0FBR0MsSUFBSCxFQUFSLEVBQW1CQyxJQUEzQixFQUFpQztBQUMvQixjQUFJLENBQUNMLFNBQVNJ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M0RlLEVBQWhCOztBQTZEQSxTQUFPdkMsR0FBUDtBQUNELENBbmxCZ0IsQ0FtbEJkNEUsU0FBUyxhQUFULEdBbmxCYyxDQUFqQiIsImZpbGUiOiJNYXAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBmb3JtYXRcbiAqIEBwcmV2ZW50TXVuZ2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSwgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXMgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfc2hvdWxkUG9seWZpbGxFUzZDb2xsZWN0aW9uID0gcmVxdWlyZSgnX3Nob3VsZFBvbHlmaWxsRVM2Q29sbGVjdGlvbicpO1xuY29uc3QgZ3VpZCA9IHJlcXVpcmUoJ2d1aWQnKTtcbmNvbnN0IGlzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2lzTm9kZScpO1xuY29uc3QgdG9JdGVyYXRvciA9IHJlcXVpcmUoJ3RvSXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgLy8gU2luY2Ugb3VyIGltcGxlbWVudGF0aW9uIGlzIHNwZWMtY29tcGxpYW50IGZvciB0aGUgbW9zdCBwYXJ0IHdlIGNhbiBzYWZlbHlcbiAgLy8gZGVsZWdhdGUgdG8gYSBidWlsdC1pbiB2ZXJzaW9uIGlmIGV4aXN0cyBhbmQgaXMgaW1wbGVtZW50ZWQgY29ycmVjdGx5LlxuICAvLyBGaXJlZm94IGhhZCBnb3R0ZW4gYSBmZXcgaW1wbGVtZW50YXRpb24gZGV0YWlscyB3cm9uZyBhY3Jvc3MgZGlmZmVyZW50XG4gIC8vIHZlcnNpb25zIHNvIHdlIGd1YXJkIGFnYWluc3QgdGhhdC5cbiAgaWYgKCFfc2hvdWxkUG9seWZpbGxFUzZDb2xsZWN0aW9uKCdNYXAnKSkge1xuICAgIHJldHVybiBnbG9iYWwuTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqID09IEVTNiBNYXAgQ29sbGVjdGlvbiA9PVxuICAgKlxuICAgKiBUaGlzIG1vZHVsZSBpcyBtZWFudCB0byBpbXBsZW1lbnQgYSBNYXAgY29sbGVjdGlvbiBhcyBkZXNjcmliZWQgaW4gY2hhcHRlclxuICAgKiAyMy4xIG9mIHRoZSBFUzYgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogTWFwIG9iamVjdHMgYXJlIGNvbGxlY3Rpb25zIG9mIGtleS92YWx1ZSBwYWlycyB3aGVyZSBib3RoIHRoZSBrZXlzIGFuZFxuICAgKiB2YWx1ZXMgbWF5IGJlIGFyYml0cmFyeSBFQ01BU2NyaXB0IGxhbmd1YWdlIHZhbHVlcy4gQSBkaXN0aW5jdCBrZXkgdmFsdWVcbiAgICogbWF5IG9ubHkgb2NjdXIgaW4gb25lIGtleS92YWx1ZSBwYWlyIHdpdGhpbiB0aGUgTWFwJ3MgY29sbGVjdGlvbi5cbiAgICpcbiAgICogaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW1hcC1vYmplY3RzXG4gICAqXG4gICAqIFRoZXJlIG9ubHkgdHdvIC0tIHJhdGhlciBzbWFsbCAtLSBkaXZpYXRpb25zIGZyb20gdGhlIHNwZWM6XG4gICAqXG4gICAqIDEuIFRoZSB1c2Ugb2YgZnJvemVuIG9iamVjdHMgYXMga2V5cy5cbiAgICogICAgV2UgZGVjaWRlZCBub3QgdG8gYWxsb3cgYW5kIHNpbXBseSB0aHJvdyBhbiBlcnJvci4gVGhlIHJlYXNvbiBiZWluZyBpc1xuICAgKiAgICB3ZSBzdG9yZSBhIFwiaGFzaFwiIG9uIHRoZSBvYmplY3QgZm9yIGZhc3QgYWNjZXNzIHRvIGl0J3MgcGxhY2UgaW4gdGhlXG4gICAqICAgIGludGVybmFsIG1hcCBlbnRyaWVzLlxuICAgKiAgICBJZiB0aGlzIHR1cm5zIG91dCB0byBiZSBhIHBvcHVsYXIgdXNlIGNhc2UgaXQncyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgYnlcbiAgICogICAgb3ZlcmlkaW5nIGBPYmplY3QuZnJlZXplYCB0byBzdG9yZSBhIFwiaGFzaFwiIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICogICAgZm9yIGxhdGVyIHVzZSB3aXRoIHRoZSBtYXAuXG4gICAqXG4gICAqIDIuIFRoZSBgc2l6ZWAgcHJvcGVydHkgb24gYSBtYXAgb2JqZWN0IGlzIGEgcmVndWxhciBwcm9wZXJ0eSBhbmQgbm90IGFcbiAgICogICAgY29tcHV0ZWQgcHJvcGVydHkgb24gdGhlIHByb3RvdHlwZSBhcyBkZXNjcmliZWQgYnkgdGhlIHNwZWMuXG4gICAqICAgIFRoZSByZWFzb24gYmVpbmcgaXMgdGhhdCB3ZSBzaW1wbHkgd2FudCB0byBzdXBwb3J0IEVTMyBlbnZpcm9ubWVudHNcbiAgICogICAgd2hpY2ggZG9lc24ndCBpbXBsZW1lbnQgY29tcHV0ZWQgcHJvcGVydGllcy5cbiAgICpcbiAgICogPT0gVXNhZ2UgPT1cbiAgICpcbiAgICogdmFyIG1hcCA9IG5ldyBNYXAoaXRlcmFibGUpO1xuICAgKlxuICAgKiBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgKiBtYXAuZ2V0KGtleSk7IC8vIHZhbHVlXG4gICAqIG1hcC5oYXMoa2V5KTsgLy8gdHJ1ZVxuICAgKiBtYXAuZGVsZXRlKGtleSk7IC8vIHRydWVcbiAgICpcbiAgICogdmFyIGl0ZXJhdG9yID0gbWFwLmtleXMoKTtcbiAgICogaXRlcmF0b3IubmV4dCgpOyAvLyB7dmFsdWU6IGtleSwgZG9uZTogZmFsc2V9XG4gICAqXG4gICAqIHZhciBpdGVyYXRvciA9IG1hcC52YWx1ZXMoKTtcbiAgICogaXRlcmF0b3IubmV4dCgpOyAvLyB7dmFsdWU6IHZhbHVlLCBkb25lOiBmYWxzZX1cbiAgICpcbiAgICogdmFyIGl0ZXJhdG9yID0gbWFwLmVudHJpZXMoKTtcbiAgICogaXRlcmF0b3IubmV4dCgpOyAvLyB7dmFsdWU6IFtrZXksIHZhbHVlXSwgZG9uZTogZmFsc2V9XG4gICAqXG4gICAqIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpeyB0aGlzID09PSB0aGlzQXJnIH0sIHRoaXNBcmcpO1xuICAgKlxuICAgKiBtYXAuY2xlYXIoKTsgLy8gcmVzZXRzIG1hcC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICAvLyBLaW5kcyBvZiBtYXAgaXRlcmF0aW9ucyAyMy4xLjUuM1xuICBjb25zdCBLSU5EX0tFWSA9ICdrZXknO1xuICBjb25zdCBLSU5EX1ZBTFVFID0gJ3ZhbHVlJztcbiAgY29uc3QgS0lORF9LRVlfVkFMVUUgPSAna2V5K3ZhbHVlJztcblxuICAvLyBJbiBvbGRlciBicm93c2VycyB3ZSBjYW4ndCBjcmVhdGUgYSBudWxsLXByb3RvdHlwZSBvYmplY3Qgc28gd2UgaGF2ZSB0b1xuICAvLyBkZWZlbmQgYWdhaW5zdCBrZXkgY29sbGlzaW9ucyB3aXRoIGJ1aWx0LWluIG1ldGhvZHMuXG4gIGNvbnN0IEtFWV9QUkVGSVggPSAnJG1hcF8nO1xuXG4gIC8vIFRoaXMgcHJvcGVydHkgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbnRlcm5hbCBzaXplIHZhcmlhYmxlIHRvIGRpc2FsbG93XG4gIC8vIHdyaXRpbmcgYW5kIHRvIGlzc3VlIHdhcm5pbmdzIGZvciB3cml0aW5ncyBpbiBkZXZlbG9wbWVudC5cbiAgbGV0IFNFQ1JFVF9TSVpFX1BST1A7XG4gIGlmIChfX0RFVl9fKSB7XG4gICAgU0VDUkVUX1NJWkVfUFJPUCA9ICckc2l6ZScgKyBndWlkKCk7XG4gIH1cblxuICAvLyBJbiBvbGRJRSB3ZSB1c2UgdGhlIERPTSBOb2RlIGB1bmlxdWVJRGAgcHJvcGVydHkgdG8gZ2V0IGNyZWF0ZSB0aGUgaGFzaC5cbiAgY29uc3QgT0xEX0lFX0hBU0hfUFJFRklYID0gJ0lFX0hBU0hfJztcblxuICBjbGFzcyBNYXAge1xuICAgIC8qKlxuICAgICAqIDIzLjEuMS4xXG4gICAgICogVGFrZXMgYW4gYGl0ZXJhYmxlYCB3aGljaCBpcyBiYXNpY2FsbHkgYW55IG9iamVjdCB0aGF0IGltcGxlbWVudHMgYVxuICAgICAqIFN5bWJvbC5pdGVyYXRvciAoQEBpdGVyYXRvcikgbWV0aG9kLiBUaGUgaXRlcmFibGUgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICAgICAqIGNvbGxlY3Rpb24gb2YgcGFpcnMuIEVhY2ggcGFpciBpcyBhIGtleS92YWx1ZSBwYWlyIHRoYXQgd2lsbCBiZSB1c2VkXG4gICAgICogdG8gaW5zdGFudGlhdGUgdGhlIG1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlcmFibGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpdGVyYWJsZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcm9uZyBtYXAgb2JqZWN0IHR5cGUuJyk7XG4gICAgICB9XG5cbiAgICAgIGluaXRNYXAodGhpcyk7XG5cbiAgICAgIGlmIChpdGVyYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gdG9JdGVyYXRvcihpdGVyYWJsZSk7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gaXQubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgaXRlcmFibGUgaXRlbXMgdG8gYmUgcGFpciBvYmplY3RzLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldChuZXh0LnZhbHVlWzBdLCBuZXh0LnZhbHVlWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy4xXG4gICAgICogQ2xlYXJzIHRoZSBtYXAgZnJvbSBhbGwga2V5cyBhbmQgdmFsdWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgaW5pdE1hcCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAyMy4xLjMuN1xuICAgICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KHRoaXMsIGtleSk7XG4gICAgICByZXR1cm4gISEoaW5kZXggIT0gbnVsbCAmJiB0aGlzLl9tYXBEYXRhW2luZGV4XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS4zLjlcbiAgICAgKiBBZGRzIGEga2V5L3ZhbHVlIHBhaXIgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHttYXB9XG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgIGxldCBpbmRleCA9IGdldEluZGV4KHRoaXMsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCAhPSBudWxsICYmIHRoaXMuX21hcERhdGFbaW5kZXhdKSB7XG4gICAgICAgIHRoaXMuX21hcERhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IHRoaXMuX21hcERhdGEucHVzaChba2V5LCB2YWx1ZV0pIC0gMTtcbiAgICAgICAgc2V0SW5kZXgodGhpcywga2V5LCBpbmRleCk7XG4gICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgdGhpc1tTRUNSRVRfU0laRV9QUk9QXSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2l6ZSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy42XG4gICAgICogR2V0cyBhIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleSBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5XG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4KHRoaXMsIGtleSk7XG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcERhdGFbaW5kZXhdWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy4zXG4gICAgICogRGVsZXRlIGEga2V5L3ZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGtleVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGtleSB3YXMgZm91bmQgYW5kIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleCh0aGlzLCBrZXkpO1xuICAgICAgaWYgKGluZGV4ICE9IG51bGwgJiYgdGhpcy5fbWFwRGF0YVtpbmRleF0pIHtcbiAgICAgICAgc2V0SW5kZXgodGhpcywga2V5LCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9tYXBEYXRhW2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICB0aGlzW1NFQ1JFVF9TSVpFX1BST1BdIC09IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaXplIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS4zLjRcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGtleS92YWx1ZSBwYWlycyAoaW4gdGhlIGZvcm0gb2YgYW4gQXJyYXkpIGluXG4gICAgICogdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICBlbnRyaWVzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCBLSU5EX0tFWV9WQUxVRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS4zLjhcbiAgICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGtleXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLCBLSU5EX0tFWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS4zLjExXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSB2YWx1ZXMgcGFpcnMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIEtJTkRfVkFMVUUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDIzLjEuMy41XG4gICAgICogSXRlcmF0ZXMgb3ZlciB0aGUga2V5L3ZhbHVlIHBhaXJzIGluIHRoZSBjb2xsZWN0aW9uIGNhbGxpbmcgYGNhbGxiYWNrYFxuICAgICAqIHdpdGggW3ZhbHVlLCBrZXksIG1hcF0uIEFuIG9wdGlvbmFsIGB0aGlzQXJnYCBjYW4gYmUgcGFzc2VkIHRvIHNldCB0aGVcbiAgICAgKiBjb250ZXh0IHdoZW4gYGNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gdGhpc0FyZ1xuICAgICAqL1xuICAgIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2FsbGJhY2sgbXVzdCBiZSBjYWxsYWJsZS4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm91bmRDYWxsYmFjayA9IGNhbGxiYWNrLmJpbmQodGhpc0FyZyB8fCB1bmRlZmluZWQpO1xuICAgICAgY29uc3QgbWFwRGF0YSA9IHRoaXMuX21hcERhdGE7XG5cbiAgICAgIC8vIE5vdGUgdGhhdCBgbWFwRGF0YS5sZW5ndGhgIHNob3VsZCBiZSBjb21wdXRlZCBvbiBlYWNoIGl0ZXJhdGlvbiB0b1xuICAgICAgLy8gc3VwcG9ydCBpdGVyYXRpbmcgb3ZlciBuZXcgaXRlbXMgaW4gdGhlIG1hcCB0aGF0IHdlcmUgYWRkZWQgYWZ0ZXIgdGhlXG4gICAgICAvLyBzdGFydCBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gbWFwRGF0YVtpXTtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICBib3VuZENhbGxiYWNrKGVudHJ5WzFdLCBlbnRyeVswXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAyMy4xLjMuMTJcbiAgTWFwLnByb3RvdHlwZVt0b0l0ZXJhdG9yLklURVJBVE9SX1NZTUJPTF0gPSBNYXAucHJvdG90eXBlLmVudHJpZXM7XG5cbiAgY2xhc3MgTWFwSXRlcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIDIzLjEuNS4xXG4gICAgICogQ3JlYXRlIGEgYE1hcEl0ZXJhdG9yYCBmb3IgYSBnaXZlbiBgbWFwYC4gV2hpbGUgdGhpcyBjbGFzcyBpcyBwcml2YXRlIGl0XG4gICAgICogd2lsbCBjcmVhdGUgb2JqZWN0cyB0aGF0IHdpbGwgYmUgcGFzc2VkIGFyb3VuZCBwdWJsaWNpbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge21hcH0gbWFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtpbmRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYXAsIGtpbmQpIHtcbiAgICAgIGlmICghKGlzT2JqZWN0KG1hcCkgJiYgbWFwLl9tYXBEYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QgaXMgbm90IGEgbWFwLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoW0tJTkRfS0VZLCBLSU5EX0tFWV9WQUxVRSwgS0lORF9WQUxVRV0uaW5kZXhPZihraW5kKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGl0ZXJhdGlvbiBraW5kLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICB0aGlzLl9uZXh0SW5kZXggPSAwO1xuICAgICAgdGhpcy5fa2luZCA9IGtpbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogMjMuMS41LjIuMVxuICAgICAqIEdldCB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgIGlmICghdGhpcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0byBiZSBjYWxsZWQgb24gYSBNYXBJdGVyYXRvci4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5fbmV4dEluZGV4O1xuICAgICAgY29uc3Qga2luZCA9IHRoaXMuX2tpbmQ7XG5cbiAgICAgIGlmIChtYXAgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbnRyaWVzID0gbWFwLl9tYXBEYXRhO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWNvcmQgPSBlbnRyaWVzW2luZGV4XTtcblxuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB0aGlzLl9uZXh0SW5kZXggPSBpbmRleDtcblxuICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IEtJTkRfS0VZKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChyZWNvcmRbMF0sIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEtJTkRfVkFMVUUpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHJlY29yZFsxXSwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVjb3JkLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcCA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodW5kZWZpbmVkLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSBjYW4gcHV0IHRoaXMgaW4gdGhlIGNsYXNzIGRlZmluaXRpb24gb25jZSB3ZSBoYXZlIGNvbXB1dGVkIHByb3BzXG4gIC8vIHRyYW5zZm9ybS5cbiAgLy8gMjMuMS41LjIuMlxuICBNYXBJdGVyYXRvci5wcm90b3R5cGVbdG9JdGVyYXRvci5JVEVSQVRPUl9TWU1CT0xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlciBGdW5jdGlvbnMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gaW5kZXggdG8gbWFwLltbTWFwRGF0YV1dIGFycmF5IGZvciBhIGdpdmVuIEtleS5cbiAgICpcbiAgICogQHBhcmFtIHttYXB9IG1hcFxuICAgKiBAcGFyYW0geyp9IGtleVxuICAgKiBAcmV0dXJuIHs/bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW5kZXgobWFwLCBrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgY29uc3QgaGFzaCA9IGdldEhhc2goa2V5KTtcbiAgICAgIHJldHVybiBtYXAuX29iamVjdEluZGV4W2hhc2hdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVmaXhlZEtleSA9IEtFWV9QUkVGSVggKyBrZXk7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5fc3RyaW5nSW5kZXhbcHJlZml4ZWRLZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hcC5fb3RoZXJJbmRleFtwcmVmaXhlZEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGFuIGluZGV4IHRoYXQgcmVmZXIgdG8gdGhlIGtleSdzIGxvY2F0aW9uIGluIG1hcC5bW01hcERhdGFdXS5cbiAgICpcbiAgICogQHBhcmFtIHttYXB9IG1hcFxuICAgKiBAcGFyYW0geyp9IGtleVxuICAgKi9cbiAgZnVuY3Rpb24gc2V0SW5kZXgobWFwLCBrZXksIGluZGV4KSB7XG4gICAgY29uc3Qgc2hvdWxkRGVsZXRlID0gaW5kZXggPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICBjb25zdCBoYXNoID0gZ2V0SGFzaChrZXkpO1xuICAgICAgaWYgKHNob3VsZERlbGV0ZSkge1xuICAgICAgICBkZWxldGUgbWFwLl9vYmplY3RJbmRleFtoYXNoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5fb2JqZWN0SW5kZXhbaGFzaF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJlZml4ZWRLZXkgPSBLRVlfUFJFRklYICsga2V5O1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChzaG91bGREZWxldGUpIHtcbiAgICAgICAgICBkZWxldGUgbWFwLl9zdHJpbmdJbmRleFtwcmVmaXhlZEtleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFwLl9zdHJpbmdJbmRleFtwcmVmaXhlZEtleV0gPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNob3VsZERlbGV0ZSkge1xuICAgICAgICAgIGRlbGV0ZSBtYXAuX290aGVySW5kZXhbcHJlZml4ZWRLZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcC5fb3RoZXJJbmRleFtwcmVmaXhlZEtleV0gPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIG1hcCB3aXRoIGludGVybmFsIHNsb3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge21hcH0gbWFwXG4gICAqL1xuICBmdW5jdGlvbiBpbml0TWFwKG1hcCkge1xuICAgIC8vIERhdGEgc3RydWN0dXJlIGRlc2lnbiBpbnNwaXJlZCBieSBUcmFjZXVyJ3MgTWFwIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIFdlIG1haW50YWluIGFuIGludGVybmFsIGFycmF5IGZvciBhbGwgdGhlIGVudHJpZXMuIFRoZSBhcnJheSBpcyBuZWVkZWRcbiAgICAvLyB0byByZW1lbWJlciBvcmRlci4gSG93ZXZlciwgdG8gaGF2ZSBhIHJlYXNvbmFibGUgSGFzaE1hcCBwZXJmb3JtYW5jZVxuICAgIC8vIGkuZS4gTygxKSBmb3IgaW5zZXJ0aW9uLCBkZWxldGlvbiwgYW5kIHJldHJpZXZhbC4gV2UgbWFpbnRhaW4gaW5kaWNlc1xuICAgIC8vIGluIG9iamVjdHMgZm9yIGZhc3QgbG9vayB1cHMuIEluZGljZXMgYXJlIHNwbGl0IHVwIGFjY29yZGluZyB0byBkYXRhXG4gICAgLy8gdHlwZXMgdG8gYXZvaWQgY29sbGlzaW9ucy5cbiAgICBtYXAuX21hcERhdGEgPSBbXTtcblxuICAgIC8vIE9iamVjdCBpbmRleCBtYXBzIGZyb20gYW4gb2JqZWN0IFwiaGFzaFwiIHRvIGluZGV4LiBUaGUgaGFzaCBiZWluZyBhIHVuaXF1ZVxuICAgIC8vIHByb3BlcnR5IG9mIG91ciBjaG9vc2luZyB0aGF0IHdlIGFzc29jaWF0ZSB3aXRoIHRoZSBvYmplY3QuIEFzc29jaWF0aW9uXG4gICAgLy8gaXMgZG9uZSBieSB3YXlzIG9mIGtlZXBpbmcgYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxuICAgIC8vIElkZWFsbHkgdGhlc2Ugd291bGQgYmUgYE9iamVjdC5jcmVhdGUobnVsbClgIG9iamVjdHMgYnV0IHNpbmNlIHdlJ3JlXG4gICAgLy8gdHJ5aW5nIHRvIHN1cHBvcnQgRVMzIHdlJ2xsIGhhdmUgdG8gZ3VhcmQgYWdhaW5zdCBjb2xsaXNpb25zIHVzaW5nXG4gICAgLy8gcHJlZml4ZXMgb24gdGhlIGtleXMgcmF0aGVyIHRoYW4gcmVseSBvbiBudWxsIHByb3RvdHlwZSBvYmplY3RzLlxuICAgIG1hcC5fb2JqZWN0SW5kZXggPSB7fTtcblxuICAgIC8vIFN0cmluZyBpbmRleCBtYXBzIGZyb20gc3RyaW5ncyB0byBpbmRleC5cbiAgICBtYXAuX3N0cmluZ0luZGV4ID0ge307XG5cbiAgICAvLyBOdW1iZXJzLCBib29sZWFucywgdW5kZWZpbmVkLCBhbmQgbnVsbC5cbiAgICBtYXAuX290aGVySW5kZXggPSB7fTtcblxuICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgaGF2ZSB0byBzdXBwb3J0IEVTMyBhbmQgY2Fubm90IGhhdmUgYE1hcC5wcm90b3R5cGUuc2l6ZWBcbiAgICAvLyBiZSBhIGdldHRlciBtZXRob2QgYnV0IGp1c3QgYSByZWd1bGFyIG1ldGhvZC4gVGhlIGJpZ2dlc3QgcHJvYmxlbSB3aXRoXG4gICAgLy8gdGhpcyBpcyBzYWZldHkuIENsaWVudHMgY2FuIGNoYW5nZSB0aGUgc2l6ZSBwcm9wZXJ0eSBlYXNpbHkgYW5kIHBvc3NpYmx5XG4gICAgLy8gd2l0aG91dCBub3RpY2luZyAoZS5nLiBgaWYgKG1hcC5zaXplID0gMSkgey4ufWAga2luZCBvZiB0eXBvKS4gV2hhdCB3ZVxuICAgIC8vIGNhbiBkbyB0byBtaXRpZ2F0ZSB1c2UgZ2V0dGVycyBhbmQgc2V0dGVycyBpbiBkZXZlbG9wbWVudCB0byBkaXNhbGxvd1xuICAgIC8vIGFuZCBpc3N1ZSBhIHdhcm5pbmcgZm9yIGNoYW5naW5nIHRoZSBgc2l6ZWAgcHJvcGVydHkuXG4gICAgaWYgKF9fREVWX18pIHtcbiAgICAgIGlmIChpc0VTNSkge1xuICAgICAgICAvLyBJZiB0aGUgYFNFQ1JFVF9TSVpFX1BST1BgIHByb3BlcnR5IGlzIGFscmVhZHkgZGVmaW5lZCB0aGVuIHdlJ3JlIG5vdFxuICAgICAgICAvLyBpbiB0aGUgZmlyc3QgY2FsbCB0byBgaW5pdE1hcGAgKGUuZy4gY29taW5nIGZyb20gYG1hcC5jbGVhcigpYCkgc29cbiAgICAgICAgLy8gYWxsIHdlIG5lZWQgdG8gZG8gaXMgcmVzZXQgdGhlIHNpemUgd2l0aG91dCBkZWZpbmluZyB0aGUgcHJvcGVydGllcy5cbiAgICAgICAgaWYgKG1hcC5oYXNPd25Qcm9wZXJ0eShTRUNSRVRfU0laRV9QUk9QKSkge1xuICAgICAgICAgIG1hcFtTRUNSRVRfU0laRV9QUk9QXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgU0VDUkVUX1NJWkVfUFJPUCwge1xuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCAnc2l6ZScsIHtcbiAgICAgICAgICAgIHNldDogdiA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1BMRUFTRSBGSVggTUU6IFlvdSBhcmUgY2hhbmdpbmcgdGhlIG1hcCBzaXplIHByb3BlcnR5IHdoaWNoICcgK1xuICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBub3QgYmUgd3JpdGFibGUgYW5kIHdpbGwgYnJlYWsgaW4gcHJvZHVjdGlvbi4nLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtYXAgc2l6ZSBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBtYXBbU0VDUkVUX1NJWkVfUFJPUF0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOT1RFOiBFYXJseSByZXR1cm4gdG8gaW1wbGVtZW50IGltbXV0YWJsZSBgLnNpemVgIGluIERFVi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBkaXZpYXRpb24gZnJvbSB0aGUgc3BlYy4gYHNpemVgIHNob3VsZCBiZSBhIGdldHRlciBvblxuICAgIC8vIGBNYXAucHJvdG90eXBlYC4gSG93ZXZlciwgd2UgaGF2ZSB0byBzdXBwb3J0IElFOC5cbiAgICBtYXAuc2l6ZSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc29tZXRoaW5nIGlzIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdChvKSB7XG4gICAgcmV0dXJuIG8gIT0gbnVsbCAmJiAodHlwZW9mIG8gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvID09PSAnZnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaXRlcmF0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvbmVcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdE9iamVjdCh2YWx1ZSwgZG9uZSkge1xuICAgIHJldHVybiB7dmFsdWUsIGRvbmV9O1xuICB9XG5cbiAgLy8gQXJlIHdlIGluIGEgbGVnaXQgRVM1IGVudmlyb25tZW50LiBTcG9pbGVyIGFsZXJ0OiB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBJRTguXG4gIGNvbnN0IGlzRVM1ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGNhbiBiZSBleHRlbmRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8YXJyYXl8ZnVuY3Rpb258cmVnZXhwfSBvXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpc0V4dGVuc2libGUobykge1xuICAgIGlmICghaXNFUzUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShvKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSUUgaGFzIGEgYHVuaXF1ZUlEYCBzZXQgb24gZXZlcnkgRE9NIG5vZGUuIFNvIHdlIGNvbnN0cnVjdCB0aGUgaGFzaCBmcm9tXG4gICAqIHRoaXMgdW5pcXVlSUQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzIGFuZCB0aGUgSUUgY2xvbmVOb2RlIGJ1ZyB3aGVyZSBpdFxuICAgKiBjbG9uZXMgcHJvcGVydGllcyBpbiBhZGRpdGlvbiB0byB0aGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5vZGVcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGdldElFTm9kZUhhc2gobm9kZSkge1xuICAgIGxldCB1bmlxdWVJRDtcbiAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgMTogLy8gRWxlbWVudFxuICAgICAgICB1bmlxdWVJRCA9IG5vZGUudW5pcXVlSUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OiAvLyBEb2N1bWVudFxuICAgICAgICB1bmlxdWVJRCA9IG5vZGUuZG9jdW1lbnRFbGVtZW50LnVuaXF1ZUlEO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh1bmlxdWVJRCkge1xuICAgICAgcmV0dXJuIE9MRF9JRV9IQVNIX1BSRUZJWCArIHVuaXF1ZUlEO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBnZXRIYXNoID0gKGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICAgIGNvbnN0IGhhc2hQcm9wZXJ0eSA9IGd1aWQoKTtcbiAgICBsZXQgaGFzaENvdW50ZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBcImhhc2hcIiBhc3NvY2lhdGVkIHdpdGggYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8YXJyYXl8ZnVuY3Rpb258cmVnZXhwfSBvXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBnZXRIYXNoKG8pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG4gICAgICBpZiAob1toYXNoUHJvcGVydHldKSB7XG4gICAgICAgIHJldHVybiBvW2hhc2hQcm9wZXJ0eV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAhaXNFUzUgJiZcbiAgICAgICAgby5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJlxuICAgICAgICBvLnByb3BlcnR5SXNFbnVtZXJhYmxlW2hhc2hQcm9wZXJ0eV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gby5wcm9wZXJ0eUlzRW51bWVyYWJsZVtoYXNoUHJvcGVydHldO1xuICAgICAgfSBlbHNlIGlmICghaXNFUzUgJiYgaXNOb2RlKG8pICYmIGdldElFTm9kZUhhc2gobykpIHtcbiAgICAgICAgcmV0dXJuIGdldElFTm9kZUhhc2gobyk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VTNSAmJiBvW2hhc2hQcm9wZXJ0eV0pIHtcbiAgICAgICAgcmV0dXJuIG9baGFzaFByb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRXh0ZW5zaWJsZShvKSkge1xuICAgICAgICBoYXNoQ291bnRlciArPSAxO1xuICAgICAgICBpZiAoaXNFUzUpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgaGFzaFByb3BlcnR5LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogaGFzaENvdW50ZXIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoby5wcm9wZXJ0eUlzRW51bWVyYWJsZSkge1xuICAgICAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBvYmplY3RcbiAgICAgICAgICAvLyB3ZSdsbCBoaWphY2sgb25lIG9mIHRoZSBsZXNzLXVzZWQgbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyB0b1xuICAgICAgICAgIC8vIHNhdmUgb3VyIGhhc2ggb24gaXQuIEFkZGlvdGlvbmFsbHksIHNpbmNlIHRoaXMgaXMgYSBmdW5jdGlvbiBpdFxuICAgICAgICAgIC8vIHdpbGwgbm90IHNob3cgdXAgaW4gYEpTT04uc3RyaW5naWZ5YCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICAgICAgby5wcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BJc0VudW1lcmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG8ucHJvcGVydHlJc0VudW1lcmFibGVbaGFzaFByb3BlcnR5XSA9IGhhc2hDb3VudGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShvKSkge1xuICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY291bGRuJ3QgZ2V0IHRoZSBJRSBgdW5pcXVlSURgIHRvIHVzZSBhcyBhIGhhc2hcbiAgICAgICAgICAvLyBhbmQgd2UgY291bGRuJ3QgdXNlIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgdG8gZXhwbG9pdCB0aGVcbiAgICAgICAgICAvLyBkb250RW51bSBidWcgc28gd2Ugc2ltcGx5IGFkZCB0aGUgYGhhc2hQcm9wZXJ0eWAgb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgb1toYXNoUHJvcGVydHldID0gaGFzaENvdW50ZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gc2V0IGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgb24gb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNoQ291bnRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWV4dGVuc2libGUgb2JqZWN0cyBhcmUgbm90IGFsbG93ZWQgYXMga2V5cy4nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIHJldHVybiBNYXA7XG59KShGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuIl19