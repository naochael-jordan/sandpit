98f9cee4513c1d1a57604bbd07b7363c


'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

if (__DEV__) {
  (function () {
    "use strict";

    require("InitializeCore");
    var ReactNativeViewConfigRegistry = require("ReactNativeViewConfigRegistry");
    var UIManager = require("UIManager");
    var RCTEventEmitter = require("RCTEventEmitter");
    var React = require("react");
    var deepFreezeAndThrowOnMutationInDev = require("deepFreezeAndThrowOnMutationInDev");
    var deepDiffer = require("deepDiffer");
    var flattenStyle = require("flattenStyle");
    var TextInputState = require("TextInputState");
    var checkPropTypes = require("prop-types/checkPropTypes");
    var tracing = require("scheduler/tracing");
    var ExceptionsManager = require("ExceptionsManager");

    var validateFormat = function validateFormat() {};

    {
      validateFormat = function validateFormat(format) {
        if (format === undefined) {
          throw new Error("invariant requires an error message argument");
        }
      };
    }

    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);

      if (!condition) {
        var error = void 0;
        if (format === undefined) {
          error = new Error("Minified exception occurred; use the non-minified dev environment " + "for the full error message and additional helpful warnings.");
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = "Invariant Violation";
        }

        error.framesToPop = 1;
        throw error;
      }
    }

    var invokeGuardedCallbackImpl = function invokeGuardedCallbackImpl(name, func, context, a, b, c, d, e, f) {
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      try {
        func.apply(context, funcArgs);
      } catch (error) {
        this.onError(error);
      }
    };

    {
      if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
        var fakeNode = document.createElement("react");

        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
          invariant(typeof document !== "undefined", "The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
          var evt = document.createEvent("Event");

          var didError = true;

          var windowEvent = window.event;

          var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");

          var funcArgs = Array.prototype.slice.call(arguments, 3);
          function callCallback() {
            fakeNode.removeEventListener(evtType, callCallback, false);

            if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
              window.event = windowEvent;
            }

            func.apply(context, funcArgs);
            didError = false;
          }

          var error = void 0;

          var didSetError = false;
          var isCrossOriginError = false;

          function handleWindowError(event) {
            error = event.error;
            didSetError = true;
            if (error === null && event.colno === 0 && event.lineno === 0) {
              isCrossOriginError = true;
            }
            if (event.defaultPrevented) {
              if (error != null && typeof error === "object") {
                try {
                  error._suppressLogging = true;
                } catch (inner) {}
              }
            }
          }

          var evtType = "react-" + (name ? name : "invokeguardedcallback");

          window.addEventListener("error", handleWindowError);
          fakeNode.addEventListener(evtType, callCallback, false);

          evt.initEvent(evtType, false, false);
          fakeNode.dispatchEvent(evt);

          if (windowEventDescriptor) {
            Object.defineProperty(window, "event", windowEventDescriptor);
          }

          if (didError) {
            if (!didSetError) {
              error = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
            } else if (isCrossOriginError) {
              error = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://fb.me/react-crossorigin-error for more information.");
            }
            this.onError(error);
          }

          window.removeEventListener("error", handleWindowError);
        };

        invokeGuardedCallbackImpl = invokeGuardedCallbackDev;
      }
    }

    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

    var hasError = false;
    var caughtError = null;

    var hasRethrowError = false;
    var rethrowError = null;

    var reporter = {
      onError: function onError(error) {
        hasError = true;
        caughtError = error;
      }
    };

    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
      hasError = false;
      caughtError = null;
      invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }

    function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
      invokeGuardedCallback.apply(this, arguments);
      if (hasError) {
        var error = clearCaughtError();
        if (!hasRethrowError) {
          hasRethrowError = true;
          rethrowError = error;
        }
      }
    }

    function rethrowCaughtError() {
      if (hasRethrowError) {
        var error = rethrowError;
        hasRethrowError = false;
        rethrowError = null;
        throw error;
      }
    }

    function hasCaughtError() {
      return hasError;
    }

    function clearCaughtError() {
      if (hasError) {
        var error = caughtError;
        hasError = false;
        caughtError = null;
        return error;
      } else {
        invariant(false, "clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
      }
    }

    var eventPluginOrder = null;

    var namesToPlugins = {};

    function recomputePluginOrdering() {
      if (!eventPluginOrder) {
        return;
      }
      for (var pluginName in namesToPlugins) {
        var pluginModule = namesToPlugins[pluginName];
        var pluginIndex = eventPluginOrder.indexOf(pluginName);
        invariant(pluginIndex > -1, "EventPluginRegistry: Cannot inject event plugins that do not exist in " + "the plugin ordering, `%s`.", pluginName);
        if (plugins[pluginIndex]) {
          continue;
        }
        invariant(pluginModule.extractEvents, "EventPluginRegistry: Event plugins must implement an `extractEvents` " + "method, but `%s` does not.", pluginName);
        plugins[pluginIndex] = pluginModule;
        var publishedEvents = pluginModule.eventTypes;
        for (var eventName in publishedEvents) {
          invariant(publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName), "EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.", eventName, pluginName);
        }
      }
    }

    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
      invariant(!eventNameDispatchConfigs.hasOwnProperty(eventName), "EventPluginHub: More than one plugin attempted to publish the same " + "event name, `%s`.", eventName);
      eventNameDispatchConfigs[eventName] = dispatchConfig;

      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
      if (phasedRegistrationNames) {
        for (var phaseName in phasedRegistrationNames) {
          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            var phasedRegistrationName = phasedRegistrationNames[phaseName];
            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
          }
        }
        return true;
      } else if (dispatchConfig.registrationName) {
        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
        return true;
      }
      return false;
    }

    function publishRegistrationName(registrationName, pluginModule, eventName) {
      invariant(!registrationNameModules[registrationName], "EventPluginHub: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
      registrationNameModules[registrationName] = pluginModule;
      registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

      {
        var lowerCasedName = registrationName.toLowerCase();
      }
    }

    var plugins = [];

    var eventNameDispatchConfigs = {};

    var registrationNameModules = {};

    var registrationNameDependencies = {};

    function injectEventPluginOrder(injectedEventPluginOrder) {
      invariant(!eventPluginOrder, "EventPluginRegistry: Cannot inject event plugin ordering more than " + "once. You are likely trying to load more than one copy of React.");

      eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
      recomputePluginOrdering();
    }

    function injectEventPluginsByName(injectedNamesToPlugins) {
      var isOrderingDirty = false;
      for (var pluginName in injectedNamesToPlugins) {
        if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
          continue;
        }
        var pluginModule = injectedNamesToPlugins[pluginName];
        if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
          invariant(!namesToPlugins[pluginName], "EventPluginRegistry: Cannot inject two different event plugins " + "using the same name, `%s`.", pluginName);
          namesToPlugins[pluginName] = pluginModule;
          isOrderingDirty = true;
        }
      }
      if (isOrderingDirty) {
        recomputePluginOrdering();
      }
    }

    var warningWithoutStack = function warningWithoutStack() {};

    {
      warningWithoutStack = function warningWithoutStack(condition, format) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        if (format === undefined) {
          throw new Error("`warningWithoutStack(condition, format, ...args)` requires a warning " + "message argument");
        }
        if (args.length > 8) {
          throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
        }
        if (condition) {
          return;
        }
        if (typeof console !== "undefined") {
          var _args$map = args.map(function (item) {
            return "" + item;
          }),
              a = _args$map[0],
              b = _args$map[1],
              c = _args$map[2],
              d = _args$map[3],
              e = _args$map[4],
              f = _args$map[5],
              g = _args$map[6],
              h = _args$map[7];

          var message = "Warning: " + format;

          switch (args.length) {
            case 0:
              console.error(message);
              break;
            case 1:
              console.error(message, a);
              break;
            case 2:
              console.error(message, a, b);
              break;
            case 3:
              console.error(message, a, b, c);
              break;
            case 4:
              console.error(message, a, b, c, d);
              break;
            case 5:
              console.error(message, a, b, c, d, e);
              break;
            case 6:
              console.error(message, a, b, c, d, e, f);
              break;
            case 7:
              console.error(message, a, b, c, d, e, f, g);
              break;
            case 8:
              console.error(message, a, b, c, d, e, f, g, h);
              break;
            default:
              throw new Error("warningWithoutStack() currently supports at most 8 arguments.");
          }
        }
        try {
          var argIndex = 0;
          var _message = "Warning: " + format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          throw new Error(_message);
        } catch (x) {}
      };
    }

    var warningWithoutStack$1 = warningWithoutStack;

    var getFiberCurrentPropsFromNode = null;
    var getInstanceFromNode = null;
    var getNodeFromInstance = null;

    function setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {
      getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;
      getInstanceFromNode = getInstanceFromNodeImpl;
      getNodeFromInstance = getNodeFromInstanceImpl;
      {
        !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, "EventPluginUtils.setComponentTree(...): Injected " + "module is missing getNodeFromInstance or getInstanceFromNode.") : void 0;
      }
    }

    var validateEventDispatches = void 0;
    {
      validateEventDispatches = function validateEventDispatches(event) {
        var dispatchListeners = event._dispatchListeners;
        var dispatchInstances = event._dispatchInstances;

        var listenersIsArr = Array.isArray(dispatchListeners);
        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

        var instancesIsArr = Array.isArray(dispatchInstances);
        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

        !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, "EventPluginUtils: Invalid `event`.") : void 0;
      };
    }

    function executeDispatch(event, simulated, listener, inst) {
      var type = event.type || "unknown-event";
      event.currentTarget = getNodeFromInstance(inst);
      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
      event.currentTarget = null;
    }

    function executeDispatchesInOrder(event, simulated) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }

          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
        }
      } else if (dispatchListeners) {
        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
      }
      event._dispatchListeners = null;
      event._dispatchInstances = null;
    }

    function executeDispatchesInOrderStopAtTrueImpl(event) {
      var dispatchListeners = event._dispatchListeners;
      var dispatchInstances = event._dispatchInstances;
      {
        validateEventDispatches(event);
      }
      if (Array.isArray(dispatchListeners)) {
        for (var i = 0; i < dispatchListeners.length; i++) {
          if (event.isPropagationStopped()) {
            break;
          }

          if (dispatchListeners[i](event, dispatchInstances[i])) {
            return dispatchInstances[i];
          }
        }
      } else if (dispatchListeners) {
        if (dispatchListeners(event, dispatchInstances)) {
          return dispatchInstances;
        }
      }
      return null;
    }

    function executeDispatchesInOrderStopAtTrue(event) {
      var ret = executeDispatchesInOrderStopAtTrueImpl(event);
      event._dispatchInstances = null;
      event._dispatchListeners = null;
      return ret;
    }

    function executeDirectDispatch(event) {
      {
        validateEventDispatches(event);
      }
      var dispatchListener = event._dispatchListeners;
      var dispatchInstance = event._dispatchInstances;
      invariant(!Array.isArray(dispatchListener), "executeDirectDispatch(...): Invalid `event`.");
      event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;
      var res = dispatchListener ? dispatchListener(event) : null;
      event.currentTarget = null;
      event._dispatchListeners = null;
      event._dispatchInstances = null;
      return res;
    }

    function hasDispatches(event) {
      return !!event._dispatchListeners;
    }

    function accumulateInto(current, next) {
      invariant(next != null, "accumulateInto(...): Accumulated items must not be null or undefined.");

      if (current == null) {
        return next;
      }

      if (Array.isArray(current)) {
        if (Array.isArray(next)) {
          current.push.apply(current, next);
          return current;
        }
        current.push(next);
        return current;
      }

      if (Array.isArray(next)) {
        return [current].concat(next);
      }

      return [current, next];
    }

    function forEachAccumulated(arr, cb, scope) {
      if (Array.isArray(arr)) {
        arr.forEach(cb, scope);
      } else if (arr) {
        cb.call(scope, arr);
      }
    }

    var eventQueue = null;

    var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
      if (event) {
        executeDispatchesInOrder(event, simulated);

        if (!event.isPersistent()) {
          event.constructor.release(event);
        }
      }
    };
    var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
      return executeDispatchesAndRelease(e, true);
    };
    var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
      return executeDispatchesAndRelease(e, false);
    };

    function isInteractive(tag) {
      return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
    }

    function shouldPreventMouseEvent(name, type, props) {
      switch (name) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
          return !!(props.disabled && isInteractive(type));
        default:
          return false;
      }
    }

    var injection = {
      injectEventPluginOrder: injectEventPluginOrder,

      injectEventPluginsByName: injectEventPluginsByName
    };

    function getListener(inst, registrationName) {
      var listener = void 0;

      var stateNode = inst.stateNode;
      if (!stateNode) {
        return null;
      }
      var props = getFiberCurrentPropsFromNode(stateNode);
      if (!props) {
        return null;
      }
      listener = props[registrationName];
      if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
        return null;
      }
      invariant(!listener || typeof listener === "function", "Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
      return listener;
    }

    function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = null;
      for (var i = 0; i < plugins.length; i++) {
        var possiblePlugin = plugins[i];
        if (possiblePlugin) {
          var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
          if (extractedEvents) {
            events = accumulateInto(events, extractedEvents);
          }
        }
      }
      return events;
    }

    function runEventsInBatch(events, simulated) {
      if (events !== null) {
        eventQueue = accumulateInto(eventQueue, events);
      }

      var processingEventQueue = eventQueue;
      eventQueue = null;

      if (!processingEventQueue) {
        return;
      }

      if (simulated) {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
      } else {
        forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
      }
      invariant(!eventQueue, "processEventQueue(): Additional events were enqueued while processing " + "an event queue. Support for this has not yet been implemented.");

      rethrowCaughtError();
    }

    function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      runEventsInBatch(events, false);
    }

    var FunctionComponent = 0;
    var FunctionComponentLazy = 1;
    var ClassComponent = 2;
    var ClassComponentLazy = 3;
    var IndeterminateComponent = 4;
    var HostRoot = 5;
    var HostPortal = 6;
    var HostComponent = 7;
    var HostText = 8;
    var Fragment = 9;
    var Mode = 10;
    var ContextConsumer = 11;
    var ContextProvider = 12;
    var ForwardRef = 13;
    var ForwardRefLazy = 14;
    var Profiler = 15;
    var PlaceholderComponent = 16;
    var PureComponent = 17;
    var PureComponentLazy = 18;

    function getParent(inst) {
      do {
        inst = inst.return;
      } while (inst && inst.tag !== HostComponent);
      if (inst) {
        return inst;
      }
      return null;
    }

    function getLowestCommonAncestor(instA, instB) {
      var depthA = 0;
      for (var tempA = instA; tempA; tempA = getParent(tempA)) {
        depthA++;
      }
      var depthB = 0;
      for (var tempB = instB; tempB; tempB = getParent(tempB)) {
        depthB++;
      }

      while (depthA - depthB > 0) {
        instA = getParent(instA);
        depthA--;
      }

      while (depthB - depthA > 0) {
        instB = getParent(instB);
        depthB--;
      }

      var depth = depthA;
      while (depth--) {
        if (instA === instB || instA === instB.alternate) {
          return instA;
        }
        instA = getParent(instA);
        instB = getParent(instB);
      }
      return null;
    }

    function isAncestor(instA, instB) {
      while (instB) {
        if (instA === instB || instA === instB.alternate) {
          return true;
        }
        instB = getParent(instB);
      }
      return false;
    }

    function getParentInstance(inst) {
      return getParent(inst);
    }

    function traverseTwoPhase(inst, fn, arg) {
      var path = [];
      while (inst) {
        path.push(inst);
        inst = getParent(inst);
      }
      var i = void 0;
      for (i = path.length; i-- > 0;) {
        fn(path[i], "captured", arg);
      }
      for (i = 0; i < path.length; i++) {
        fn(path[i], "bubbled", arg);
      }
    }

    function listenerAtPhase(inst, event, propagationPhase) {
      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
      return getListener(inst, registrationName);
    }

    function accumulateDirectionalDispatches(inst, phase, event) {
      {
        !inst ? warningWithoutStack$1(false, "Dispatching inst must not be null") : void 0;
      }
      var listener = listenerAtPhase(inst, event, phase);
      if (listener) {
        event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
        event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
      }
    }

    function accumulateTwoPhaseDispatchesSingle(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
      }
    }

    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
      if (event && event.dispatchConfig.phasedRegistrationNames) {
        var targetInst = event._targetInst;
        var parentInst = targetInst ? getParentInstance(targetInst) : null;
        traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
      }
    }

    function accumulateDispatches(inst, ignoredDirection, event) {
      if (inst && event && event.dispatchConfig.registrationName) {
        var registrationName = event.dispatchConfig.registrationName;
        var listener = getListener(inst, registrationName);
        if (listener) {
          event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
          event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
        }
      }
    }

    function accumulateDirectDispatchesSingle(event) {
      if (event && event.dispatchConfig.registrationName) {
        accumulateDispatches(event._targetInst, null, event);
      }
    }

    function accumulateTwoPhaseDispatches(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
    }

    function accumulateTwoPhaseDispatchesSkipTarget(events) {
      forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
    }

    function accumulateDirectDispatches(events) {
      forEachAccumulated(events, accumulateDirectDispatchesSingle);
    }

    var EVENT_POOL_SIZE = 10;

    var EventInterface = {
      type: null,
      target: null,

      currentTarget: function currentTarget() {
        return null;
      },
      eventPhase: null,
      bubbles: null,
      cancelable: null,
      timeStamp: function timeStamp(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: null,
      isTrusted: null
    };

    function functionThatReturnsTrue() {
      return true;
    }

    function functionThatReturnsFalse() {
      return false;
    }

    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
      {
        delete this.nativeEvent;
        delete this.preventDefault;
        delete this.stopPropagation;
        delete this.isDefaultPrevented;
        delete this.isPropagationStopped;
      }

      this.dispatchConfig = dispatchConfig;
      this._targetInst = targetInst;
      this.nativeEvent = nativeEvent;

      var Interface = this.constructor.Interface;
      for (var propName in Interface) {
        if (!Interface.hasOwnProperty(propName)) {
          continue;
        }
        {
          delete this[propName];
        }
        var normalize = Interface[propName];
        if (normalize) {
          this[propName] = normalize(nativeEvent);
        } else {
          if (propName === "target") {
            this.target = nativeEventTarget;
          } else {
            this[propName] = nativeEvent[propName];
          }
        }
      }

      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
      if (defaultPrevented) {
        this.isDefaultPrevented = functionThatReturnsTrue;
      } else {
        this.isDefaultPrevented = functionThatReturnsFalse;
      }
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }

    _extends(SyntheticEvent.prototype, {
      preventDefault: function preventDefault() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        if (!event) {
          return;
        }

        if (event.preventDefault) {
          event.preventDefault();
        } else if (typeof event.returnValue !== "unknown") {
          event.returnValue = false;
        }
        this.isDefaultPrevented = functionThatReturnsTrue;
      },

      stopPropagation: function stopPropagation() {
        var event = this.nativeEvent;
        if (!event) {
          return;
        }

        if (event.stopPropagation) {
          event.stopPropagation();
        } else if (typeof event.cancelBubble !== "unknown") {
          event.cancelBubble = true;
        }

        this.isPropagationStopped = functionThatReturnsTrue;
      },

      persist: function persist() {
        this.isPersistent = functionThatReturnsTrue;
      },

      isPersistent: functionThatReturnsFalse,

      destructor: function destructor() {
        var Interface = this.constructor.Interface;
        for (var propName in Interface) {
          {
            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
          }
        }
        this.dispatchConfig = null;
        this._targetInst = null;
        this.nativeEvent = null;
        this.isDefaultPrevented = functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        this._dispatchListeners = null;
        this._dispatchInstances = null;
        {
          Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
          Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
          Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
          Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function () {}));
          Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function () {}));
        }
      }
    });

    SyntheticEvent.Interface = EventInterface;

    SyntheticEvent.extend = function (Interface) {
      var Super = this;

      var E = function E() {};
      E.prototype = Super.prototype;
      var prototype = new E();

      function Class() {
        return Super.apply(this, arguments);
      }
      _extends(prototype, Class.prototype);
      Class.prototype = prototype;
      Class.prototype.constructor = Class;

      Class.Interface = _extends({}, Super.Interface, Interface);
      Class.extend = Super.extend;
      addEventPoolingTo(Class);

      return Class;
    };

    addEventPoolingTo(SyntheticEvent);

    function getPooledWarningPropertyDefinition(propName, getVal) {
      var isFunction = typeof getVal === "function";
      return {
        configurable: true,
        set: set,
        get: get$$1
      };

      function set(val) {
        var action = isFunction ? "setting the method" : "setting the property";
        warn(action, "This is effectively a no-op");
        return val;
      }

      function get$$1() {
        var action = isFunction ? "accessing the method" : "accessing the property";
        var result = isFunction ? "This is a no-op function" : "This is set to null";
        warn(action, result);
        return getVal;
      }

      function warn(action, result) {
        var warningCondition = false;
        !warningCondition ? warningWithoutStack$1(false, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + "If you must keep the original synthetic event around, use event.persist(). " + "See https://fb.me/react-event-pooling for more information.", action, propName, result) : void 0;
      }
    }

    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
      var EventConstructor = this;
      if (EventConstructor.eventPool.length) {
        var instance = EventConstructor.eventPool.pop();
        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
        return instance;
      }
      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
    }

    function releasePooledEvent(event) {
      var EventConstructor = this;
      invariant(event instanceof EventConstructor, "Trying to release an event instance into a pool of a different type.");
      event.destructor();
      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
        EventConstructor.eventPool.push(event);
      }
    }

    function addEventPoolingTo(EventConstructor) {
      EventConstructor.eventPool = [];
      EventConstructor.getPooled = getPooledEvent;
      EventConstructor.release = releasePooledEvent;
    }

    var ResponderSyntheticEvent = SyntheticEvent.extend({
      touchHistory: function touchHistory(nativeEvent) {
        return null;
      }
    });

    var TOP_TOUCH_START = "topTouchStart";
    var TOP_TOUCH_MOVE = "topTouchMove";
    var TOP_TOUCH_END = "topTouchEnd";
    var TOP_TOUCH_CANCEL = "topTouchCancel";
    var TOP_SCROLL = "topScroll";
    var TOP_SELECTION_CHANGE = "topSelectionChange";

    function isStartish(topLevelType) {
      return topLevelType === TOP_TOUCH_START;
    }

    function isMoveish(topLevelType) {
      return topLevelType === TOP_TOUCH_MOVE;
    }

    function isEndish(topLevelType) {
      return topLevelType === TOP_TOUCH_END || topLevelType === TOP_TOUCH_CANCEL;
    }

    var startDependencies = [TOP_TOUCH_START];
    var moveDependencies = [TOP_TOUCH_MOVE];
    var endDependencies = [TOP_TOUCH_CANCEL, TOP_TOUCH_END];

    var MAX_TOUCH_BANK = 20;
    var touchBank = [];
    var touchHistory = {
      touchBank: touchBank,
      numberActiveTouches: 0,

      indexOfSingleActiveTouch: -1,
      mostRecentTimeStamp: 0
    };

    function timestampForTouch(touch) {
      return touch.timeStamp || touch.timestamp;
    }

    function createTouchRecord(touch) {
      return {
        touchActive: true,
        startPageX: touch.pageX,
        startPageY: touch.pageY,
        startTimeStamp: timestampForTouch(touch),
        currentPageX: touch.pageX,
        currentPageY: touch.pageY,
        currentTimeStamp: timestampForTouch(touch),
        previousPageX: touch.pageX,
        previousPageY: touch.pageY,
        previousTimeStamp: timestampForTouch(touch)
      };
    }

    function resetTouchRecord(touchRecord, touch) {
      touchRecord.touchActive = true;
      touchRecord.startPageX = touch.pageX;
      touchRecord.startPageY = touch.pageY;
      touchRecord.startTimeStamp = timestampForTouch(touch);
      touchRecord.currentPageX = touch.pageX;
      touchRecord.currentPageY = touch.pageY;
      touchRecord.currentTimeStamp = timestampForTouch(touch);
      touchRecord.previousPageX = touch.pageX;
      touchRecord.previousPageY = touch.pageY;
      touchRecord.previousTimeStamp = timestampForTouch(touch);
    }

    function getTouchIdentifier(_ref) {
      var identifier = _ref.identifier;

      invariant(identifier != null, "Touch object is missing identifier.");
      {
        !(identifier <= MAX_TOUCH_BANK) ? warningWithoutStack$1(false, "Touch identifier %s is greater than maximum supported %s which causes " + "performance issues backfilling array locations for all of the indices.", identifier, MAX_TOUCH_BANK) : void 0;
      }
      return identifier;
    }

    function recordTouchStart(touch) {
      var identifier = getTouchIdentifier(touch);
      var touchRecord = touchBank[identifier];
      if (touchRecord) {
        resetTouchRecord(touchRecord, touch);
      } else {
        touchBank[identifier] = createTouchRecord(touch);
      }
      touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
    }

    function recordTouchMove(touch) {
      var touchRecord = touchBank[getTouchIdentifier(touch)];
      if (touchRecord) {
        touchRecord.touchActive = true;
        touchRecord.previousPageX = touchRecord.currentPageX;
        touchRecord.previousPageY = touchRecord.currentPageY;
        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      } else {
        console.error("Cannot record touch move without a touch start.\n" + "Touch Move: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
      }
    }

    function recordTouchEnd(touch) {
      var touchRecord = touchBank[getTouchIdentifier(touch)];
      if (touchRecord) {
        touchRecord.touchActive = false;
        touchRecord.previousPageX = touchRecord.currentPageX;
        touchRecord.previousPageY = touchRecord.currentPageY;
        touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
        touchRecord.currentPageX = touch.pageX;
        touchRecord.currentPageY = touch.pageY;
        touchRecord.currentTimeStamp = timestampForTouch(touch);
        touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
      } else {
        console.error("Cannot record touch end without a touch start.\n" + "Touch End: %s\n", "Touch Bank: %s", printTouch(touch), printTouchBank());
      }
    }

    function printTouch(touch) {
      return JSON.stringify({
        identifier: touch.identifier,
        pageX: touch.pageX,
        pageY: touch.pageY,
        timestamp: timestampForTouch(touch)
      });
    }

    function printTouchBank() {
      var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
      if (touchBank.length > MAX_TOUCH_BANK) {
        printed += " (original size: " + touchBank.length + ")";
      }
      return printed;
    }

    var ResponderTouchHistoryStore = {
      recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
        if (isMoveish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchMove);
        } else if (isStartish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchStart);
          touchHistory.numberActiveTouches = nativeEvent.touches.length;
          if (touchHistory.numberActiveTouches === 1) {
            touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
          }
        } else if (isEndish(topLevelType)) {
          nativeEvent.changedTouches.forEach(recordTouchEnd);
          touchHistory.numberActiveTouches = nativeEvent.touches.length;
          if (touchHistory.numberActiveTouches === 1) {
            for (var i = 0; i < touchBank.length; i++) {
              var touchTrackToCheck = touchBank[i];
              if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
                touchHistory.indexOfSingleActiveTouch = i;
                break;
              }
            }
            {
              var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
              !(activeRecord != null && activeRecord.touchActive) ? warningWithoutStack$1(false, "Cannot find single active touch.") : void 0;
            }
          }
        }
      },

      touchHistory: touchHistory
    };

    function accumulate(current, next) {
      invariant(next != null, "accumulate(...): Accumulated items must be not be null or undefined.");

      if (current == null) {
        return next;
      }

      if (Array.isArray(current)) {
        return current.concat(next);
      }

      if (Array.isArray(next)) {
        return [current].concat(next);
      }

      return [current, next];
    }

    var responderInst = null;

    var trackedTouchCount = 0;

    var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
      var oldResponderInst = responderInst;
      responderInst = nextResponderInst;
      if (ResponderEventPlugin.GlobalResponderHandler !== null) {
        ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
      }
    };

    var eventTypes$1 = {
      startShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onStartShouldSetResponder",
          captured: "onStartShouldSetResponderCapture"
        },
        dependencies: startDependencies
      },

      scrollShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onScrollShouldSetResponder",
          captured: "onScrollShouldSetResponderCapture"
        },
        dependencies: [TOP_SCROLL]
      },

      selectionChangeShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onSelectionChangeShouldSetResponder",
          captured: "onSelectionChangeShouldSetResponderCapture"
        },
        dependencies: [TOP_SELECTION_CHANGE]
      },

      moveShouldSetResponder: {
        phasedRegistrationNames: {
          bubbled: "onMoveShouldSetResponder",
          captured: "onMoveShouldSetResponderCapture"
        },
        dependencies: moveDependencies
      },

      responderStart: {
        registrationName: "onResponderStart",
        dependencies: startDependencies
      },
      responderMove: {
        registrationName: "onResponderMove",
        dependencies: moveDependencies
      },
      responderEnd: {
        registrationName: "onResponderEnd",
        dependencies: endDependencies
      },
      responderRelease: {
        registrationName: "onResponderRelease",
        dependencies: endDependencies
      },
      responderTerminationRequest: {
        registrationName: "onResponderTerminationRequest",
        dependencies: []
      },
      responderGrant: {
        registrationName: "onResponderGrant",
        dependencies: []
      },
      responderReject: {
        registrationName: "onResponderReject",
        dependencies: []
      },
      responderTerminate: {
        registrationName: "onResponderTerminate",
        dependencies: []
      }
    };

    function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
      var shouldSetEventType = isStartish(topLevelType) ? eventTypes$1.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes$1.moveShouldSetResponder : topLevelType === TOP_SELECTION_CHANGE ? eventTypes$1.selectionChangeShouldSetResponder : eventTypes$1.scrollShouldSetResponder;

      var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);

      var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
      var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
      shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
      if (skipOverBubbleShouldSetFrom) {
        accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
      } else {
        accumulateTwoPhaseDispatches(shouldSetEvent);
      }
      var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
      if (!shouldSetEvent.isPersistent()) {
        shouldSetEvent.constructor.release(shouldSetEvent);
      }

      if (!wantsResponderInst || wantsResponderInst === responderInst) {
        return null;
      }
      var extracted = void 0;
      var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
      grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

      accumulateDirectDispatches(grantEvent);
      var blockHostResponder = executeDirectDispatch(grantEvent) === true;
      if (responderInst) {
        var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
        terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
        accumulateDirectDispatches(terminationRequestEvent);
        var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);
        if (!terminationRequestEvent.isPersistent()) {
          terminationRequestEvent.constructor.release(terminationRequestEvent);
        }

        if (shouldSwitch) {
          var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
          terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(terminateEvent);
          extracted = accumulate(extracted, [grantEvent, terminateEvent]);
          changeResponder(wantsResponderInst, blockHostResponder);
        } else {
          var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes$1.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
          rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(rejectEvent);
          extracted = accumulate(extracted, rejectEvent);
        }
      } else {
        extracted = accumulate(extracted, grantEvent);
        changeResponder(wantsResponderInst, blockHostResponder);
      }
      return extracted;
    }

    function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
      return topLevelInst && (topLevelType === TOP_SCROLL && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === TOP_SELECTION_CHANGE || isStartish(topLevelType) || isMoveish(topLevelType));
    }

    function noResponderTouches(nativeEvent) {
      var touches = nativeEvent.touches;
      if (!touches || touches.length === 0) {
        return true;
      }
      for (var i = 0; i < touches.length; i++) {
        var activeTouch = touches[i];
        var target = activeTouch.target;
        if (target !== null && target !== undefined && target !== 0) {
          var targetInst = getInstanceFromNode(target);
          if (isAncestor(responderInst, targetInst)) {
            return false;
          }
        }
      }
      return true;
    }

    var ResponderEventPlugin = {
      _getResponder: function _getResponder() {
        return responderInst;
      },

      eventTypes: eventTypes$1,

      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        if (isStartish(topLevelType)) {
          trackedTouchCount += 1;
        } else if (isEndish(topLevelType)) {
          if (trackedTouchCount >= 0) {
            trackedTouchCount -= 1;
          } else {
            console.error("Ended a touch event which was not counted in `trackedTouchCount`.");
            return null;
          }
        }

        ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

        var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;

        var isResponderTouchStart = responderInst && isStartish(topLevelType);
        var isResponderTouchMove = responderInst && isMoveish(topLevelType);
        var isResponderTouchEnd = responderInst && isEndish(topLevelType);
        var incrementalTouch = isResponderTouchStart ? eventTypes$1.responderStart : isResponderTouchMove ? eventTypes$1.responderMove : isResponderTouchEnd ? eventTypes$1.responderEnd : null;

        if (incrementalTouch) {
          var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
          gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(gesture);
          extracted = accumulate(extracted, gesture);
        }

        var isResponderTerminate = responderInst && topLevelType === TOP_TOUCH_CANCEL;
        var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
        var finalTouch = isResponderTerminate ? eventTypes$1.responderTerminate : isResponderRelease ? eventTypes$1.responderRelease : null;
        if (finalTouch) {
          var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
          finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
          accumulateDirectDispatches(finalEvent);
          extracted = accumulate(extracted, finalEvent);
          changeResponder(null);
        }

        return extracted;
      },

      GlobalResponderHandler: null,

      injection: {
        injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
          ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
        }
      }
    };

    var customBubblingEventTypes$1 = ReactNativeViewConfigRegistry.customBubblingEventTypes;
    var customDirectEventTypes$1 = ReactNativeViewConfigRegistry.customDirectEventTypes;
    var eventTypes$2 = ReactNativeViewConfigRegistry.eventTypes;

    var ReactNativeBridgeEventPlugin = {
      eventTypes: eventTypes$2,

      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
        if (targetInst == null) {
          return null;
        }
        var bubbleDispatchConfig = customBubblingEventTypes$1[topLevelType];
        var directDispatchConfig = customDirectEventTypes$1[topLevelType];
        invariant(bubbleDispatchConfig || directDispatchConfig, 'Unsupported top level event type "%s" dispatched', topLevelType);
        var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
        if (bubbleDispatchConfig) {
          accumulateTwoPhaseDispatches(event);
        } else if (directDispatchConfig) {
          accumulateDirectDispatches(event);
        } else {
          return null;
        }
        return event;
      }
    };

    var ReactNativeEventPluginOrder = ["ResponderEventPlugin", "ReactNativeBridgeEventPlugin"];

    injection.injectEventPluginOrder(ReactNativeEventPluginOrder);

    injection.injectEventPluginsByName({
      ResponderEventPlugin: ResponderEventPlugin,
      ReactNativeBridgeEventPlugin: ReactNativeBridgeEventPlugin
    });

    var instanceCache = {};
    var instanceProps = {};

    function precacheFiberNode(hostInst, tag) {
      instanceCache[tag] = hostInst;
    }

    function uncacheFiberNode(tag) {
      delete instanceCache[tag];
      delete instanceProps[tag];
    }

    function getInstanceFromTag(tag) {
      return instanceCache[tag] || null;
    }

    function getTagFromInstance(inst) {
      var tag = inst.stateNode._nativeTag;
      if (tag === undefined) {
        tag = inst.stateNode.canonical._nativeTag;
      }
      invariant(tag, "All native instances should have a tag.");
      return tag;
    }

    function getFiberCurrentPropsFromNode$1(stateNode) {
      return instanceProps[stateNode._nativeTag] || null;
    }

    function updateFiberProps(tag, props) {
      instanceProps[tag] = props;
    }

    var restoreImpl = null;
    var restoreTarget = null;
    var restoreQueue = null;

    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (!internalInstance) {
        return;
      }
      invariant(typeof restoreImpl === "function", "setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
      var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
      restoreImpl(internalInstance.stateNode, internalInstance.type, props);
    }

    function needsStateRestore() {
      return restoreTarget !== null || restoreQueue !== null;
    }

    function restoreStateIfNeeded() {
      if (!restoreTarget) {
        return;
      }
      var target = restoreTarget;
      var queuedTargets = restoreQueue;
      restoreTarget = null;
      restoreQueue = null;

      restoreStateOfTarget(target);
      if (queuedTargets) {
        for (var i = 0; i < queuedTargets.length; i++) {
          restoreStateOfTarget(queuedTargets[i]);
        }
      }
    }

    var _batchedUpdatesImpl = function _batchedUpdatesImpl(fn, bookkeeping) {
      return fn(bookkeeping);
    };
    var _flushInteractiveUpdatesImpl = function _flushInteractiveUpdatesImpl() {};

    var isBatching = false;
    function batchedUpdates(fn, bookkeeping) {
      if (isBatching) {
        return fn(bookkeeping);
      }
      isBatching = true;
      try {
        return _batchedUpdatesImpl(fn, bookkeeping);
      } finally {
        isBatching = false;
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
          _flushInteractiveUpdatesImpl();
          restoreStateIfNeeded();
        }
      }
    }

    function setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {
      _batchedUpdatesImpl = batchedUpdatesImpl;
      _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;
    }

    var EMPTY_NATIVE_EVENT = {};

    var touchSubsequence = function touchSubsequence(touches, indices) {
      var ret = [];
      for (var i = 0; i < indices.length; i++) {
        ret.push(touches[indices[i]]);
      }
      return ret;
    };

    var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
      var rippedOut = [];

      var temp = touches;
      for (var i = 0; i < indices.length; i++) {
        var index = indices[i];
        rippedOut.push(touches[index]);
        temp[index] = null;
      }
      var fillAt = 0;
      for (var j = 0; j < temp.length; j++) {
        var cur = temp[j];
        if (cur !== null) {
          temp[fillAt++] = cur;
        }
      }
      temp.length = fillAt;
      return rippedOut;
    };

    function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
      var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
      var inst = getInstanceFromTag(rootNodeID);
      batchedUpdates(function () {
        runExtractedEventsInBatch(topLevelType, inst, nativeEvent, nativeEvent.target);
      });
    }

    function receiveEvent(rootNodeID, topLevelType, nativeEventParam) {
      _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
    }

    function receiveTouches(eventTopLevelType, touches, changedIndices) {
      var changedTouches = eventTopLevelType === "topTouchEnd" || eventTopLevelType === "topTouchCancel" ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);

      for (var jj = 0; jj < changedTouches.length; jj++) {
        var touch = changedTouches[jj];

        touch.changedTouches = changedTouches;
        touch.touches = touches;
        var nativeEvent = touch;
        var rootNodeID = null;
        var target = nativeEvent.target;
        if (target !== null && target !== undefined) {
          if (target < 1) {
            {
              warningWithoutStack$1(false, "A view is reporting that a touch occurred on tag zero.");
            }
          } else {
            rootNodeID = target;
          }
        }

        _receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
      }
    }

    var ReactNativeEventEmitter = Object.freeze({
      getListener: getListener,
      registrationNames: registrationNameModules,
      _receiveRootNodeIDEvent: _receiveRootNodeIDEvent,
      receiveEvent: receiveEvent,
      receiveTouches: receiveTouches
    });

    var ReactNativeGlobalResponderHandler = {
      onChange: function onChange(from, to, blockNativeResponder) {
        if (to !== null) {
          var tag = to.stateNode._nativeTag;
          UIManager.setJSResponder(tag, blockNativeResponder);
        } else {
          UIManager.clearJSResponder();
        }
      }
    };

    RCTEventEmitter.register(ReactNativeEventEmitter);

    setComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromTag, getTagFromInstance);

    ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);

    function get$1(key) {
      return key._reactInternalFiber;
    }

    function set(key, value) {
      key._reactInternalFiber = value;
    }

    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

    var hasSymbol = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.for : "@@for");

    var REACT_ELEMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.element") : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.portal") : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.fragment") : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.strict_mode") : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.profiler") : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.provider") : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.context") : 0xeace;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.concurrent_mode") : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.forward_ref") : 0xead0;
    var REACT_PLACEHOLDER_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.placeholder") : 0xead1;
    var REACT_PURE_TYPE = hasSymbol ? (typeof Symbol === "function" ? Symbol.for : "@@for")("react.pure") : 0xead3;

    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && (typeof Symbol === "function" ? Symbol.iterator : "@@iterator");
    var FAUX_ITERATOR_SYMBOL = "@@iterator";

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object") {
        return null;
      }
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      if (typeof maybeIterator === "function") {
        return maybeIterator;
      }
      return null;
    }

    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;

    function getResultFromResolvedThenable(thenable) {
      return thenable._reactResult;
    }

    function refineResolvedThenable(thenable) {
      return thenable._reactStatus === Resolved ? thenable._reactResult : null;
    }

    function getComponentName(type) {
      if (type == null) {
        return null;
      }
      {
        if (typeof type.tag === "number") {
          warningWithoutStack$1(false, "Received an unexpected object in getComponentName(). " + "This is likely a bug in React. Please file an issue.");
        }
      }
      if (typeof type === "function") {
        return type.displayName || type.name || null;
      }
      if (typeof type === "string") {
        return type;
      }
      switch (type) {
        case REACT_CONCURRENT_MODE_TYPE:
          return "ConcurrentMode";
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_PLACEHOLDER_TYPE:
          return "Placeholder";
      }
      if (typeof type === "object") {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return "Context.Consumer";
          case REACT_PROVIDER_TYPE:
            return "Context.Provider";
          case REACT_FORWARD_REF_TYPE:
            var renderFn = type.render;
            var functionName = renderFn.displayName || renderFn.name || "";
            return type.displayName || (functionName !== "" ? "ForwardRef(" + functionName + ")" : "ForwardRef");
        }
        if (typeof type.then === "function") {
          var thenable = type;
          var resolvedThenable = refineResolvedThenable(thenable);
          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }
        }
      }
      return null;
    }

    var NoEffect = 0;
    var PerformedWork = 1;

    var Placement = 2;
    var Update = 4;
    var PlacementAndUpdate = 6;
    var Deletion = 8;
    var ContentReset = 16;
    var Callback = 32;
    var DidCapture = 64;
    var Ref = 128;
    var Snapshot = 256;

    var LifecycleEffectMask = 420;

    var HostEffectMask = 511;

    var Incomplete = 512;
    var ShouldCapture = 1024;

    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;

    var MOUNTING = 1;
    var MOUNTED = 2;
    var UNMOUNTED = 3;

    function isFiberMountedImpl(fiber) {
      var node = fiber;
      if (!fiber.alternate) {
        if ((node.effectTag & Placement) !== NoEffect) {
          return MOUNTING;
        }
        while (node.return) {
          node = node.return;
          if ((node.effectTag & Placement) !== NoEffect) {
            return MOUNTING;
          }
        }
      } else {
        while (node.return) {
          node = node.return;
        }
      }
      if (node.tag === HostRoot) {
        return MOUNTED;
      }

      return UNMOUNTED;
    }

    function isFiberMounted(fiber) {
      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function isMounted(component) {
      {
        var owner = ReactCurrentOwner$1.current;
        if (owner !== null && (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)) {
          var ownerFiber = owner;
          var instance = ownerFiber.stateNode;
          !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(ownerFiber.type) || "A component") : void 0;
          instance._warnedAboutRefsInRender = true;
        }
      }

      var fiber = get$1(component);
      if (!fiber) {
        return false;
      }
      return isFiberMountedImpl(fiber) === MOUNTED;
    }

    function assertIsMounted(fiber) {
      invariant(isFiberMountedImpl(fiber) === MOUNTED, "Unable to find node on an unmounted component.");
    }

    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        var state = isFiberMountedImpl(fiber);
        invariant(state !== UNMOUNTED, "Unable to find node on an unmounted component.");
        if (state === MOUNTING) {
          return null;
        }
        return fiber;
      }

      var a = fiber;
      var b = alternate;
      while (true) {
        var parentA = a.return;
        var parentB = parentA ? parentA.alternate : null;
        if (!parentA || !parentB) {
          break;
        }

        if (parentA.child === parentB.child) {
          var child = parentA.child;
          while (child) {
            if (child === a) {
              assertIsMounted(parentA);
              return fiber;
            }
            if (child === b) {
              assertIsMounted(parentA);
              return alternate;
            }
            child = child.sibling;
          }

          invariant(false, "Unable to find node on an unmounted component.");
        }

        if (a.return !== b.return) {
          a = parentA;
          b = parentB;
        } else {
          var didFindChild = false;
          var _child = parentA.child;
          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            _child = parentB.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            invariant(didFindChild, "Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
          }
        }

        invariant(a.alternate === b, "Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      invariant(a.tag === HostRoot, "Unable to find node on an unmounted component.");
      if (a.stateNode.current === a) {
        return fiber;
      }

      return alternate;
    }

    function findCurrentHostFiber(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);
      if (!currentParent) {
        return null;
      }

      var node = currentParent;
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        } else if (node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === currentParent) {
          return null;
        }
        while (!node.sibling) {
          if (!node.return || node.return === currentParent) {
            return null;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }

      return null;
    }

    var emptyObject = {};

    var removedKeys = null;
    var removedKeyCount = 0;

    function defaultDiffer(prevProp, nextProp) {
      if (typeof nextProp !== "object" || nextProp === null) {
        return true;
      } else {
        return deepDiffer(prevProp, nextProp);
      }
    }

    function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
      if (Array.isArray(node)) {
        var i = node.length;
        while (i-- && removedKeyCount > 0) {
          restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
        }
      } else if (node && removedKeyCount > 0) {
        var obj = node;
        for (var propKey in removedKeys) {
          if (!removedKeys[propKey]) {
            continue;
          }
          var nextProp = obj[propKey];
          if (nextProp === undefined) {
            continue;
          }

          var attributeConfig = validAttributes[propKey];
          if (!attributeConfig) {
            continue;
          }

          if (typeof nextProp === "function") {
            nextProp = true;
          }
          if (typeof nextProp === "undefined") {
            nextProp = null;
          }

          if (typeof attributeConfig !== "object") {
            updatePayload[propKey] = nextProp;
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
            updatePayload[propKey] = nextValue;
          }
          removedKeys[propKey] = false;
          removedKeyCount--;
        }
      }
    }

    function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
      var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
      var i = void 0;
      for (i = 0; i < minLength; i++) {
        updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
      }
      for (; i < prevArray.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
      }
      for (; i < nextArray.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
      }
      return updatePayload;
    }

    function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {
      if (!updatePayload && prevProp === nextProp) {
        return updatePayload;
      }

      if (!prevProp || !nextProp) {
        if (nextProp) {
          return addNestedProperty(updatePayload, nextProp, validAttributes);
        }
        if (prevProp) {
          return clearNestedProperty(updatePayload, prevProp, validAttributes);
        }
        return updatePayload;
      }

      if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {
        return diffProperties(updatePayload, prevProp, nextProp, validAttributes);
      }

      if (Array.isArray(prevProp) && Array.isArray(nextProp)) {
        return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
      }

      if (Array.isArray(prevProp)) {
        return diffProperties(updatePayload, flattenStyle(prevProp), nextProp, validAttributes);
      }

      return diffProperties(updatePayload, prevProp, flattenStyle(nextProp), validAttributes);
    }

    function addNestedProperty(updatePayload, nextProp, validAttributes) {
      if (!nextProp) {
        return updatePayload;
      }

      if (!Array.isArray(nextProp)) {
        return addProperties(updatePayload, nextProp, validAttributes);
      }

      for (var i = 0; i < nextProp.length; i++) {
        updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
      }

      return updatePayload;
    }

    function clearNestedProperty(updatePayload, prevProp, validAttributes) {
      if (!prevProp) {
        return updatePayload;
      }

      if (!Array.isArray(prevProp)) {
        return clearProperties(updatePayload, prevProp, validAttributes);
      }

      for (var i = 0; i < prevProp.length; i++) {
        updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
      }
      return updatePayload;
    }

    function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
      var attributeConfig = void 0;
      var nextProp = void 0;
      var prevProp = void 0;

      for (var propKey in nextProps) {
        attributeConfig = validAttributes[propKey];
        if (!attributeConfig) {
          continue;
        }

        prevProp = prevProps[propKey];
        nextProp = nextProps[propKey];

        if (typeof nextProp === "function") {
          nextProp = true;

          if (typeof prevProp === "function") {
            prevProp = true;
          }
        }

        if (typeof nextProp === "undefined") {
          nextProp = null;
          if (typeof prevProp === "undefined") {
            prevProp = null;
          }
        }

        if (removedKeys) {
          removedKeys[propKey] = false;
        }

        if (updatePayload && updatePayload[propKey] !== undefined) {
          if (typeof attributeConfig !== "object") {
            updatePayload[propKey] = nextProp;
          } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
            var nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
            updatePayload[propKey] = nextValue;
          }
          continue;
        }

        if (prevProp === nextProp) {
          continue;
        }

        if (typeof attributeConfig !== "object") {
          if (defaultDiffer(prevProp, nextProp)) {
            (updatePayload || (updatePayload = {}))[propKey] = nextProp;
          }
        } else if (typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
          var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === "function" ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));
          if (shouldUpdate) {
            var _nextValue = typeof attributeConfig.process === "function" ? attributeConfig.process(nextProp) : nextProp;
            (updatePayload || (updatePayload = {}))[propKey] = _nextValue;
          }
        } else {
          removedKeys = null;
          removedKeyCount = 0;

          updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);
          if (removedKeyCount > 0 && updatePayload) {
            restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
            removedKeys = null;
          }
        }
      }

      for (var _propKey in prevProps) {
        if (nextProps[_propKey] !== undefined) {
          continue;
        }
        attributeConfig = validAttributes[_propKey];
        if (!attributeConfig) {
          continue;
        }

        if (updatePayload && updatePayload[_propKey] !== undefined) {
          continue;
        }

        prevProp = prevProps[_propKey];
        if (prevProp === undefined) {
          continue;
        }

        if (typeof attributeConfig !== "object" || typeof attributeConfig.diff === "function" || typeof attributeConfig.process === "function") {
          (updatePayload || (updatePayload = {}))[_propKey] = null;
          if (!removedKeys) {
            removedKeys = {};
          }
          if (!removedKeys[_propKey]) {
            removedKeys[_propKey] = true;
            removedKeyCount++;
          }
        } else {
          updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
        }
      }
      return updatePayload;
    }

    function addProperties(updatePayload, props, validAttributes) {
      return diffProperties(updatePayload, emptyObject, props, validAttributes);
    }

    function clearProperties(updatePayload, prevProps, validAttributes) {
      return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
    }

    function create(props, validAttributes) {
      return addProperties(null, props, validAttributes);
    }

    function diff(prevProps, nextProps, validAttributes) {
      return diffProperties(null, prevProps, nextProps, validAttributes);
    }

    function mountSafeCallback_NOT_REALLY_SAFE(context, callback) {
      return function () {
        if (!callback) {
          return undefined;
        }

        if (typeof context.__isMounted === "boolean") {
          if (!context.__isMounted) {
            return undefined;
          }
        }

        return callback.apply(context, arguments);
      };
    }

    function throwOnStylesProp(component, props) {
      if (props.styles !== undefined) {
        var owner = component._owner || null;
        var name = component.constructor.displayName;
        var msg = "`styles` is not a supported property of `" + name + "`, did " + "you mean `style` (singular)?";
        if (owner && owner.constructor && owner.constructor.displayName) {
          msg += "\n\nCheck the `" + owner.constructor.displayName + "` parent " + " component.";
        }
        throw new Error(msg);
      }
    }

    function warnForStyleProps(props, validAttributes) {
      for (var key in validAttributes.style) {
        if (!(validAttributes[key] || props[key] === undefined)) {
          console.error("You are setting the style `{ " + key + ": ... }` as a prop. You " + "should nest it in a style object. " + "E.g. `{ style: { " + key + ": ... } }`");
        }
      }
    }

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    var ReactNativeFiberHostComponent = function () {
      function ReactNativeFiberHostComponent(tag, viewConfig) {
        _classCallCheck(this, ReactNativeFiberHostComponent);

        this._nativeTag = tag;
        this._children = [];
        this.viewConfig = viewConfig;
      }

      ReactNativeFiberHostComponent.prototype.blur = function blur() {
        TextInputState.blurTextInput(this._nativeTag);
      };

      ReactNativeFiberHostComponent.prototype.focus = function focus() {
        TextInputState.focusTextInput(this._nativeTag);
      };

      ReactNativeFiberHostComponent.prototype.measure = function measure(callback) {
        UIManager.measure(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
      };

      ReactNativeFiberHostComponent.prototype.measureInWindow = function measureInWindow(callback) {
        UIManager.measureInWindow(this._nativeTag, mountSafeCallback_NOT_REALLY_SAFE(this, callback));
      };

      ReactNativeFiberHostComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
        UIManager.measureLayout(this._nativeTag, relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
      };

      ReactNativeFiberHostComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
        {
          warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
        }

        var updatePayload = create(nativeProps, this.viewConfig.validAttributes);

        if (updatePayload != null) {
          UIManager.updateView(this._nativeTag, this.viewConfig.uiViewClassName, updatePayload);
        }
      };

      return ReactNativeFiberHostComponent;
    }();

    var hasNativePerformanceNow = typeof performance === "object" && typeof performance.now === "function";

    var now$1 = hasNativePerformanceNow ? function () {
      return performance.now();
    } : function () {
      return Date.now();
    };

    var scheduledCallback = null;
    var frameDeadline = 0;

    var frameDeadlineObject = {
      timeRemaining: function timeRemaining() {
        return frameDeadline - now$1();
      },
      didTimeout: false
    };

    function setTimeoutCallback() {
      frameDeadline = now$1() + 5;

      var callback = scheduledCallback;
      scheduledCallback = null;
      if (callback !== null) {
        callback(frameDeadlineObject);
      }
    }

    function scheduleDeferredCallback$1(callback, options) {
      scheduledCallback = callback;
      var timeoutId = setTimeout(setTimeoutCallback, 1);
      return timeoutId;
    }

    function cancelDeferredCallback$1(callbackID) {
      scheduledCallback = null;
      clearTimeout(callbackID);
    }

    function shim() {
      invariant(false, "The current renderer does not support persistence. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
    }

    var supportsPersistence = false;
    var cloneInstance = shim;
    var createContainerChildSet = shim;
    var appendChildToContainerChildSet = shim;
    var finalizeContainerChildren = shim;
    var replaceContainerChildren = shim;

    function shim$1() {
      invariant(false, "The current renderer does not support hyration. " + "This error is likely caused by a bug in React. " + "Please file an issue.");
    }

    var supportsHydration = false;
    var canHydrateInstance = shim$1;
    var canHydrateTextInstance = shim$1;
    var getNextHydratableSibling = shim$1;
    var getFirstHydratableChild = shim$1;
    var hydrateInstance = shim$1;
    var hydrateTextInstance = shim$1;
    var didNotMatchHydratedContainerTextInstance = shim$1;
    var didNotMatchHydratedTextInstance = shim$1;
    var didNotHydrateContainerInstance = shim$1;
    var didNotHydrateInstance = shim$1;
    var didNotFindHydratableContainerInstance = shim$1;
    var didNotFindHydratableContainerTextInstance = shim$1;
    var didNotFindHydratableInstance = shim$1;
    var didNotFindHydratableTextInstance = shim$1;

    var UPDATE_SIGNAL = {};
    {
      Object.freeze(UPDATE_SIGNAL);
    }

    var nextReactTag = 3;
    function allocateTag() {
      var tag = nextReactTag;
      if (tag % 10 === 1) {
        tag += 2;
      }
      nextReactTag = tag + 2;
      return tag;
    }

    function recursivelyUncacheFiberNode(node) {
      if (typeof node === "number") {
        uncacheFiberNode(node);
      } else {
        uncacheFiberNode(node._nativeTag);

        node._children.forEach(recursivelyUncacheFiberNode);
      }
    }

    function appendInitialChild(parentInstance, child) {
      parentInstance._children.push(child);
    }

    function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      var tag = allocateTag();
      var viewConfig = ReactNativeViewConfigRegistry.get(type);

      {
        for (var key in viewConfig.validAttributes) {
          if (props.hasOwnProperty(key)) {
            deepFreezeAndThrowOnMutationInDev(props[key]);
          }
        }
      }

      invariant(type !== "RCTView" || !hostContext.isInAParentText, "Nesting of <View> within <Text> is not currently supported.");

      var updatePayload = create(props, viewConfig.validAttributes);

      UIManager.createView(tag, viewConfig.uiViewClassName, rootContainerInstance, updatePayload);

      var component = new ReactNativeFiberHostComponent(tag, viewConfig);

      precacheFiberNode(internalInstanceHandle, tag);
      updateFiberProps(tag, props);

      return component;
    }

    function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
      invariant(hostContext.isInAParentText, "Text strings must be rendered within a <Text> component.");

      var tag = allocateTag();

      UIManager.createView(tag, "RCTRawText", rootContainerInstance, { text: text });

      precacheFiberNode(internalInstanceHandle, tag);

      return tag;
    }

    function finalizeInitialChildren(parentInstance, type, props, rootContainerInstance, hostContext) {
      if (parentInstance._children.length === 0) {
        return false;
      }

      var nativeTags = parentInstance._children.map(function (child) {
        return typeof child === "number" ? child : child._nativeTag;
      });

      UIManager.setChildren(parentInstance._nativeTag, nativeTags);

      return false;
    }

    function getRootHostContext(rootContainerInstance) {
      return { isInAParentText: false };
    }

    function getChildHostContext(parentHostContext, type, rootContainerInstance) {
      var prevIsInAParentText = parentHostContext.isInAParentText;
      var isInAParentText = type === "AndroidTextInput" || type === "RCTMultilineTextInputView" || type === "RCTSinglelineTextInputView" || type === "RCTText" || type === "RCTVirtualText";

      if (prevIsInAParentText !== isInAParentText) {
        return { isInAParentText: isInAParentText };
      } else {
        return parentHostContext;
      }
    }

    function getPublicInstance(instance) {
      return instance;
    }

    function prepareForCommit(containerInfo) {}

    function prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, hostContext) {
      return UPDATE_SIGNAL;
    }

    function resetAfterCommit(containerInfo) {}

    var now = now$1;
    var isPrimaryRenderer = true;
    var scheduleDeferredCallback = scheduleDeferredCallback$1;
    var cancelDeferredCallback = cancelDeferredCallback$1;

    var scheduleTimeout = setTimeout;
    var cancelTimeout = clearTimeout;
    var noTimeout = -1;

    function shouldDeprioritizeSubtree(type, props) {
      return false;
    }

    function shouldSetTextContent(type, props) {
      return false;
    }

    var supportsMutation = true;

    function appendChild(parentInstance, child) {
      var childTag = typeof child === "number" ? child : child._nativeTag;
      var children = parentInstance._children;
      var index = children.indexOf(child);

      if (index >= 0) {
        children.splice(index, 1);
        children.push(child);

        UIManager.manageChildren(parentInstance._nativeTag, [index], [children.length - 1], [], [], []);
      } else {
        children.push(child);

        UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [children.length - 1], []);
      }
    }

    function appendChildToContainer(parentInstance, child) {
      var childTag = typeof child === "number" ? child : child._nativeTag;
      UIManager.setChildren(parentInstance, [childTag]);
    }

    function commitTextUpdate(textInstance, oldText, newText) {
      UIManager.updateView(textInstance, "RCTRawText", { text: newText });
    }

    function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps, internalInstanceHandle) {
      var viewConfig = instance.viewConfig;

      updateFiberProps(instance._nativeTag, newProps);

      var updatePayload = diff(oldProps, newProps, viewConfig.validAttributes);

      if (updatePayload != null) {
        UIManager.updateView(instance._nativeTag, viewConfig.uiViewClassName, updatePayload);
      }
    }

    function insertBefore(parentInstance, child, beforeChild) {
      var children = parentInstance._children;
      var index = children.indexOf(child);

      if (index >= 0) {
        children.splice(index, 1);
        var beforeChildIndex = children.indexOf(beforeChild);
        children.splice(beforeChildIndex, 0, child);

        UIManager.manageChildren(parentInstance._nativeTag, [index], [beforeChildIndex], [], [], []);
      } else {
        var _beforeChildIndex = children.indexOf(beforeChild);
        children.splice(_beforeChildIndex, 0, child);

        var childTag = typeof child === "number" ? child : child._nativeTag;

        UIManager.manageChildren(parentInstance._nativeTag, [], [], [childTag], [_beforeChildIndex], []);
      }
    }

    function insertInContainerBefore(parentInstance, child, beforeChild) {
      invariant(typeof parentInstance !== "number", "Container does not support insertBefore operation");
    }

    function removeChild(parentInstance, child) {
      recursivelyUncacheFiberNode(child);
      var children = parentInstance._children;
      var index = children.indexOf(child);

      children.splice(index, 1);

      UIManager.manageChildren(parentInstance._nativeTag, [], [], [], [], [index]);
    }

    function removeChildFromContainer(parentInstance, child) {
      recursivelyUncacheFiberNode(child);
      UIManager.manageChildren(parentInstance, [], [], [], [], [0]);
    }

    function resetTextContent(instance) {}

    var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      var sourceInfo = "";
      if (source) {
        var path = source.fileName;
        var fileName = path.replace(BEFORE_SLASH_RE, "");
        {
          if (/^index\./.test(fileName)) {
            var match = path.match(BEFORE_SLASH_RE);
            if (match) {
              var pathBeforeSlash = match[1];
              if (pathBeforeSlash) {
                var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                fileName = folderName + "/" + fileName;
              }
            }
          }
        }
        sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
      } else if (ownerName) {
        sourceInfo = " (created by " + ownerName + ")";
      }
      return "\n    in " + (name || "Unknown") + sourceInfo;
    };

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

    function describeFiber(fiber) {
      switch (fiber.tag) {
        case IndeterminateComponent:
        case FunctionComponent:
        case FunctionComponentLazy:
        case ClassComponent:
        case ClassComponentLazy:
        case HostComponent:
        case Mode:
          var owner = fiber._debugOwner;
          var source = fiber._debugSource;
          var name = getComponentName(fiber.type);
          var ownerName = null;
          if (owner) {
            ownerName = getComponentName(owner.type);
          }
          return describeComponentFrame(name, source, ownerName);
        default:
          return "";
      }
    }

    function getStackByFiberInDevAndProd(workInProgress) {
      var info = "";
      var node = workInProgress;
      do {
        info += describeFiber(node);
        node = node.return;
      } while (node);
      return info;
    }

    var current = null;
    var phase = null;

    function getCurrentFiberOwnerNameInDevOrNull() {
      {
        if (current === null) {
          return null;
        }
        var owner = current._debugOwner;
        if (owner !== null && typeof owner !== "undefined") {
          return getComponentName(owner.type);
        }
      }
      return null;
    }

    function getCurrentFiberStackInDev() {
      {
        if (current === null) {
          return "";
        }

        return getStackByFiberInDevAndProd(current);
      }
      return "";
    }

    function resetCurrentFiber() {
      {
        ReactDebugCurrentFrame.getCurrentStack = null;
        current = null;
        phase = null;
      }
    }

    function setCurrentFiber(fiber) {
      {
        ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
        current = fiber;
        phase = null;
      }
    }

    function setCurrentPhase(lifeCyclePhase) {
      {
        phase = lifeCyclePhase;
      }
    }

    var debugRenderPhaseSideEffects = false;
    var debugRenderPhaseSideEffectsForStrictMode = false;
    var enableSuspense = false;
    var enableUserTimingAPI = true;
    var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
    var warnAboutDeprecatedLifecycles = false;
    var enableProfilerTimer = true;
    var enableSchedulerTracing = true;

    var reactEmoji = "\u269B";
    var warningEmoji = "\u26D4";
    var supportsUserTiming = typeof performance !== "undefined" && typeof performance.mark === "function" && typeof performance.clearMarks === "function" && typeof performance.measure === "function" && typeof performance.clearMeasures === "function";

    var currentFiber = null;

    var currentPhase = null;
    var currentPhaseFiber = null;

    var isCommitting = false;
    var hasScheduledUpdateInCurrentCommit = false;
    var hasScheduledUpdateInCurrentPhase = false;
    var commitCountInCurrentWorkLoop = 0;
    var effectCountInCurrentCommit = 0;
    var isWaitingForCallback = false;

    var labelsInCurrentCommit = new Set();

    var formatMarkName = function formatMarkName(markName) {
      return reactEmoji + " " + markName;
    };

    var formatLabel = function formatLabel(label, warning) {
      var prefix = warning ? warningEmoji + " " : reactEmoji + " ";
      var suffix = warning ? " Warning: " + warning : "";
      return "" + prefix + label + suffix;
    };

    var beginMark = function beginMark(markName) {
      performance.mark(formatMarkName(markName));
    };

    var clearMark = function clearMark(markName) {
      performance.clearMarks(formatMarkName(markName));
    };

    var endMark = function endMark(label, markName, warning) {
      var formattedMarkName = formatMarkName(markName);
      var formattedLabel = formatLabel(label, warning);
      try {
        performance.measure(formattedLabel, formattedMarkName);
      } catch (err) {}

      performance.clearMarks(formattedMarkName);
      performance.clearMeasures(formattedLabel);
    };

    var getFiberMarkName = function getFiberMarkName(label, debugID) {
      return label + " (#" + debugID + ")";
    };

    var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {
      if (phase === null) {
        return componentName + " [" + (isMounted ? "update" : "mount") + "]";
      } else {
        return componentName + "." + phase;
      }
    };

    var beginFiberMark = function beginFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);

      if (isCommitting && labelsInCurrentCommit.has(label)) {
        return false;
      }
      labelsInCurrentCommit.add(label);

      var markName = getFiberMarkName(label, debugID);
      beginMark(markName);
      return true;
    };

    var clearFiberMark = function clearFiberMark(fiber, phase) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      clearMark(markName);
    };

    var endFiberMark = function endFiberMark(fiber, phase, warning) {
      var componentName = getComponentName(fiber.type) || "Unknown";
      var debugID = fiber._debugID;
      var isMounted = fiber.alternate !== null;
      var label = getFiberLabel(componentName, isMounted, phase);
      var markName = getFiberMarkName(label, debugID);
      endMark(label, markName, warning);
    };

    var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {
      switch (fiber.tag) {
        case HostRoot:
        case HostComponent:
        case HostText:
        case HostPortal:
        case Fragment:
        case ContextProvider:
        case ContextConsumer:
        case Mode:
          return true;
        default:
          return false;
      }
    };

    var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {
      if (currentPhase !== null && currentPhaseFiber !== null) {
        clearFiberMark(currentPhaseFiber, currentPhase);
      }
      currentPhaseFiber = null;
      currentPhase = null;
      hasScheduledUpdateInCurrentPhase = false;
    };

    var pauseTimers = function pauseTimers() {
      var fiber = currentFiber;
      while (fiber) {
        if (fiber._debugIsCurrentlyTiming) {
          endFiberMark(fiber, null, null);
        }
        fiber = fiber.return;
      }
    };

    var resumeTimersRecursively = function resumeTimersRecursively(fiber) {
      if (fiber.return !== null) {
        resumeTimersRecursively(fiber.return);
      }
      if (fiber._debugIsCurrentlyTiming) {
        beginFiberMark(fiber, null);
      }
    };

    var resumeTimers = function resumeTimers() {
      if (currentFiber !== null) {
        resumeTimersRecursively(currentFiber);
      }
    };

    function recordEffect() {
      if (enableUserTimingAPI) {
        effectCountInCurrentCommit++;
      }
    }

    function recordScheduleUpdate() {
      if (enableUserTimingAPI) {
        if (isCommitting) {
          hasScheduledUpdateInCurrentCommit = true;
        }
        if (currentPhase !== null && currentPhase !== "componentWillMount" && currentPhase !== "componentWillReceiveProps") {
          hasScheduledUpdateInCurrentPhase = true;
        }
      }
    }

    function startRequestCallbackTimer() {
      if (enableUserTimingAPI) {
        if (supportsUserTiming && !isWaitingForCallback) {
          isWaitingForCallback = true;
          beginMark("(Waiting for async callback...)");
        }
      }
    }

    function stopRequestCallbackTimer(didExpire, expirationTime) {
      if (enableUserTimingAPI) {
        if (supportsUserTiming) {
          isWaitingForCallback = false;
          var warning = didExpire ? "React was blocked by main thread" : null;
          endMark("(Waiting for async callback... will force flush in " + expirationTime + " ms)", "(Waiting for async callback...)", warning);
        }
      }
    }

    function startWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber;
        if (!beginFiberMark(fiber, null)) {
          return;
        }
        fiber._debugIsCurrentlyTiming = true;
      }
    }

    function cancelWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        fiber._debugIsCurrentlyTiming = false;
        clearFiberMark(fiber, null);
      }
    }

    function stopWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber.return;
        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }
        fiber._debugIsCurrentlyTiming = false;
        endFiberMark(fiber, null, null);
      }
    }

    function stopFailedWorkTimer(fiber) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
          return;
        }

        currentFiber = fiber.return;
        if (!fiber._debugIsCurrentlyTiming) {
          return;
        }
        fiber._debugIsCurrentlyTiming = false;
        var warning = "An error was thrown inside this error boundary";
        endFiberMark(fiber, null, warning);
      }
    }

    function startPhaseTimer(fiber, phase) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        clearPendingPhaseMeasurement();
        if (!beginFiberMark(fiber, phase)) {
          return;
        }
        currentPhaseFiber = fiber;
        currentPhase = phase;
      }
    }

    function stopPhaseTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        if (currentPhase !== null && currentPhaseFiber !== null) {
          var warning = hasScheduledUpdateInCurrentPhase ? "Scheduled a cascading update" : null;
          endFiberMark(currentPhaseFiber, currentPhase, warning);
        }
        currentPhase = null;
        currentPhaseFiber = null;
      }
    }

    function startWorkLoopTimer(nextUnitOfWork) {
      if (enableUserTimingAPI) {
        currentFiber = nextUnitOfWork;
        if (!supportsUserTiming) {
          return;
        }
        commitCountInCurrentWorkLoop = 0;

        beginMark("(React Tree Reconciliation)");

        resumeTimers();
      }
    }

    function stopWorkLoopTimer(interruptedBy, didCompleteRoot) {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var warning = null;
        if (interruptedBy !== null) {
          if (interruptedBy.tag === HostRoot) {
            warning = "A top-level update interrupted the previous render";
          } else {
            var componentName = getComponentName(interruptedBy.type) || "Unknown";
            warning = "An update to " + componentName + " interrupted the previous render";
          }
        } else if (commitCountInCurrentWorkLoop > 1) {
          warning = "There were cascading updates";
        }
        commitCountInCurrentWorkLoop = 0;
        var label = didCompleteRoot ? "(React Tree Reconciliation: Completed Root)" : "(React Tree Reconciliation: Yielded)";

        pauseTimers();
        endMark(label, "(React Tree Reconciliation)", warning);
      }
    }

    function startCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        isCommitting = true;
        hasScheduledUpdateInCurrentCommit = false;
        labelsInCurrentCommit.clear();
        beginMark("(Committing Changes)");
      }
    }

    function stopCommitTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }

        var warning = null;
        if (hasScheduledUpdateInCurrentCommit) {
          warning = "Lifecycle hook scheduled a cascading update";
        } else if (commitCountInCurrentWorkLoop > 0) {
          warning = "Caused by a cascading update in earlier commit";
        }
        hasScheduledUpdateInCurrentCommit = false;
        commitCountInCurrentWorkLoop++;
        isCommitting = false;
        labelsInCurrentCommit.clear();

        endMark("(Committing Changes)", "(Committing Changes)", warning);
      }
    }

    function startCommitSnapshotEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Committing Snapshot Effects)");
      }
    }

    function stopCommitSnapshotEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark("(Committing Snapshot Effects: " + count + " Total)", "(Committing Snapshot Effects)", null);
      }
    }

    function startCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Committing Host Effects)");
      }
    }

    function stopCommitHostEffectsTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark("(Committing Host Effects: " + count + " Total)", "(Committing Host Effects)", null);
      }
    }

    function startCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        effectCountInCurrentCommit = 0;
        beginMark("(Calling Lifecycle Methods)");
      }
    }

    function stopCommitLifeCyclesTimer() {
      if (enableUserTimingAPI) {
        if (!supportsUserTiming) {
          return;
        }
        var count = effectCountInCurrentCommit;
        effectCountInCurrentCommit = 0;
        endMark("(Calling Lifecycle Methods: " + count + " Total)", "(Calling Lifecycle Methods)", null);
      }
    }

    var valueStack = [];

    var fiberStack = void 0;

    {
      fiberStack = [];
    }

    var index = -1;

    function createCursor(defaultValue) {
      return {
        current: defaultValue
      };
    }

    function pop(cursor, fiber) {
      if (index < 0) {
        {
          warningWithoutStack$1(false, "Unexpected pop.");
        }
        return;
      }

      {
        if (fiber !== fiberStack[index]) {
          warningWithoutStack$1(false, "Unexpected Fiber popped.");
        }
      }

      cursor.current = valueStack[index];

      valueStack[index] = null;

      {
        fiberStack[index] = null;
      }

      index--;
    }

    function push(cursor, value, fiber) {
      index++;

      valueStack[index] = cursor.current;

      {
        fiberStack[index] = fiber;
      }

      cursor.current = value;
    }

    function checkThatStackIsEmpty() {
      {
        if (index !== -1) {
          warningWithoutStack$1(false, "Expected an empty stack. Something was not reset properly.");
        }
      }
    }

    function resetStackAfterFatalErrorInDev() {
      {
        index = -1;
        valueStack.length = 0;
        fiberStack.length = 0;
      }
    }

    var warnedAboutMissingGetChildContext = void 0;

    {
      warnedAboutMissingGetChildContext = {};
    }

    var emptyContextObject = {};
    {
      Object.freeze(emptyContextObject);
    }

    var contextStackCursor = createCursor(emptyContextObject);

    var didPerformWorkStackCursor = createCursor(false);

    var previousContext = emptyContextObject;

    function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
      if (didPushOwnContextIfProvider && isContextProvider(Component)) {
        return previousContext;
      }
      return contextStackCursor.current;
    }

    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
      var instance = workInProgress.stateNode;
      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
    }

    function getMaskedContext(workInProgress, unmaskedContext) {
      var type = workInProgress.type;
      var contextTypes = type.contextTypes;
      if (!contextTypes) {
        return emptyContextObject;
      }

      var instance = workInProgress.stateNode;
      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
        return instance.__reactInternalMemoizedMaskedChildContext;
      }

      var context = {};
      for (var key in contextTypes) {
        context[key] = unmaskedContext[key];
      }

      {
        var name = getComponentName(type) || "Unknown";
        checkPropTypes(contextTypes, context, "context", name, getCurrentFiberStackInDev);
      }

      if (instance) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return context;
    }

    function hasContextChanged() {
      return didPerformWorkStackCursor.current;
    }

    function isContextProvider(type) {
      var childContextTypes = type.childContextTypes;
      return childContextTypes !== null && childContextTypes !== undefined;
    }

    function popContext(fiber) {
      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function popTopLevelContextObject(fiber) {
      pop(didPerformWorkStackCursor, fiber);
      pop(contextStackCursor, fiber);
    }

    function pushTopLevelContextObject(fiber, context, didChange) {
      invariant(contextStackCursor.current === emptyContextObject, "Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");

      push(contextStackCursor, context, fiber);
      push(didPerformWorkStackCursor, didChange, fiber);
    }

    function processChildContext(fiber, type, parentContext) {
      var instance = fiber.stateNode;
      var childContextTypes = type.childContextTypes;

      if (typeof instance.getChildContext !== "function") {
        {
          var componentName = getComponentName(type) || "Unknown";

          if (!warnedAboutMissingGetChildContext[componentName]) {
            warnedAboutMissingGetChildContext[componentName] = true;
            warningWithoutStack$1(false, "%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
          }
        }
        return parentContext;
      }

      var childContext = void 0;
      {
        setCurrentPhase("getChildContext");
      }
      startPhaseTimer(fiber, "getChildContext");
      childContext = instance.getChildContext();
      stopPhaseTimer();
      {
        setCurrentPhase(null);
      }
      for (var contextKey in childContext) {
        invariant(contextKey in childContextTypes, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(type) || "Unknown", contextKey);
      }
      {
        var name = getComponentName(type) || "Unknown";
        checkPropTypes(childContextTypes, childContext, "child context", name, getCurrentFiberStackInDev);
      }

      return _extends({}, parentContext, childContext);
    }

    function pushContextProvider(workInProgress) {
      var instance = workInProgress.stateNode;

      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;

      previousContext = contextStackCursor.current;
      push(contextStackCursor, memoizedMergedChildContext, workInProgress);
      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

      return true;
    }

    function invalidateContextProvider(workInProgress, type, didChange) {
      var instance = workInProgress.stateNode;
      invariant(instance, "Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");

      if (didChange) {
        var mergedContext = processChildContext(workInProgress, type, previousContext);
        instance.__reactInternalMemoizedMergedChildContext = mergedContext;

        pop(didPerformWorkStackCursor, workInProgress);
        pop(contextStackCursor, workInProgress);

        push(contextStackCursor, mergedContext, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      } else {
        pop(didPerformWorkStackCursor, workInProgress);
        push(didPerformWorkStackCursor, didChange, workInProgress);
      }
    }

    function findCurrentUnmaskedContext(fiber) {
      invariant(isFiberMounted(fiber) && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy), "Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");

      var node = fiber;
      do {
        switch (node.tag) {
          case HostRoot:
            return node.stateNode.context;
          case ClassComponent:
            {
              var Component = node.type;
              if (isContextProvider(Component)) {
                return node.stateNode.__reactInternalMemoizedMergedChildContext;
              }
              break;
            }
          case ClassComponentLazy:
            {
              var _Component = getResultFromResolvedThenable(node.type);
              if (isContextProvider(_Component)) {
                return node.stateNode.__reactInternalMemoizedMergedChildContext;
              }
              break;
            }
        }
        node = node.return;
      } while (node !== null);
      invariant(false, "Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
    }

    var onCommitFiberRoot = null;
    var onCommitFiberUnmount = null;
    var hasLoggedError = false;

    function catchErrors(fn) {
      return function (arg) {
        try {
          return fn(arg);
        } catch (err) {
          if (true && !hasLoggedError) {
            hasLoggedError = true;
            warningWithoutStack$1(false, "React DevTools encountered an error: %s", err);
          }
        }
      };
    }

    var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";

    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
        return false;
      }
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled) {
        return true;
      }
      if (!hook.supportsFiber) {
        {
          warningWithoutStack$1(false, "The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://fb.me/react-devtools");
        }

        return true;
      }
      try {
        var rendererID = hook.inject(internals);

        onCommitFiberRoot = catchErrors(function (root) {
          return hook.onCommitFiberRoot(rendererID, root);
        });
        onCommitFiberUnmount = catchErrors(function (fiber) {
          return hook.onCommitFiberUnmount(rendererID, fiber);
        });
      } catch (err) {
        {
          warningWithoutStack$1(false, "React DevTools encountered an error: %s.", err);
        }
      }

      return true;
    }

    function onCommitRoot(root) {
      if (typeof onCommitFiberRoot === "function") {
        onCommitFiberRoot(root);
      }
    }

    function onCommitUnmount(fiber) {
      if (typeof onCommitFiberUnmount === "function") {
        onCommitFiberUnmount(fiber);
      }
    }

    var maxSigned31BitInt = 1073741823;

    var NoWork = 0;
    var Sync = 1;
    var Never = maxSigned31BitInt;

    var UNIT_SIZE = 10;
    var MAGIC_NUMBER_OFFSET = 2;

    function msToExpirationTime(ms) {
      return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
    }

    function expirationTimeToMs(expirationTime) {
      return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
    }

    function ceiling(num, precision) {
      return ((num / precision | 0) + 1) * precision;
    }

    function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
      return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
    }

    var LOW_PRIORITY_EXPIRATION = 5000;
    var LOW_PRIORITY_BATCH_SIZE = 250;

    function computeAsyncExpiration(currentTime) {
      return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);
    }

    var HIGH_PRIORITY_EXPIRATION = 500;
    var HIGH_PRIORITY_BATCH_SIZE = 100;

    function computeInteractiveExpiration(currentTime) {
      return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);
    }

    var NoContext = 0;
    var ConcurrentMode = 1;
    var StrictMode = 2;
    var ProfileMode = 4;

    var hasBadMapPolyfill = void 0;

    {
      hasBadMapPolyfill = false;
      try {
        var nonExtensibleObject = Object.preventExtensions({});
        var testMap = new Map([[nonExtensibleObject, null]]);
        var testSet = new Set([nonExtensibleObject]);

        testMap.set(0, 0);
        testSet.add(0);
      } catch (e) {
        hasBadMapPolyfill = true;
      }
    }

    var debugCounter = void 0;

    {
      debugCounter = 1;
    }

    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.type = null;
      this.stateNode = null;

      this.return = null;
      this.child = null;
      this.sibling = null;
      this.index = 0;

      this.ref = null;

      this.pendingProps = pendingProps;
      this.memoizedProps = null;
      this.updateQueue = null;
      this.memoizedState = null;
      this.firstContextDependency = null;

      this.mode = mode;

      this.effectTag = NoEffect;
      this.nextEffect = null;

      this.firstEffect = null;
      this.lastEffect = null;

      this.expirationTime = NoWork;
      this.childExpirationTime = NoWork;

      this.alternate = null;

      if (enableProfilerTimer) {
        this.actualDuration = 0;
        this.actualStartTime = -1;
        this.selfBaseDuration = 0;
        this.treeBaseDuration = 0;
      }

      {
        this._debugID = debugCounter++;
        this._debugSource = null;
        this._debugOwner = null;
        this._debugIsCurrentlyTiming = false;
        if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
          Object.preventExtensions(this);
        }
      }
    }

    var createFiber = function createFiber(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    };

    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }

    function resolveLazyComponentTag(fiber, Component) {
      if (typeof Component === "function") {
        return shouldConstruct(Component) ? ClassComponentLazy : FunctionComponentLazy;
      } else if (Component !== undefined && Component !== null) {
        var $$typeof = Component.$$typeof;
        if ($$typeof === REACT_FORWARD_REF_TYPE) {
          return ForwardRefLazy;
        }
        if ($$typeof === REACT_PURE_TYPE) {
          return PureComponentLazy;
        }
      }
      return IndeterminateComponent;
    }

    function createWorkInProgress(current, pendingProps, expirationTime) {
      var workInProgress = current.alternate;
      if (workInProgress === null) {
        workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
        workInProgress.type = current.type;
        workInProgress.stateNode = current.stateNode;

        {
          workInProgress._debugID = current._debugID;
          workInProgress._debugSource = current._debugSource;
          workInProgress._debugOwner = current._debugOwner;
        }

        workInProgress.alternate = current;
        current.alternate = workInProgress;
      } else {
        workInProgress.pendingProps = pendingProps;

        workInProgress.effectTag = NoEffect;

        workInProgress.nextEffect = null;
        workInProgress.firstEffect = null;
        workInProgress.lastEffect = null;

        if (enableProfilerTimer) {
          workInProgress.actualDuration = 0;
          workInProgress.actualStartTime = -1;
        }
      }

      workInProgress.childExpirationTime = current.childExpirationTime;
      workInProgress.expirationTime = current.expirationTime;

      workInProgress.child = current.child;
      workInProgress.memoizedProps = current.memoizedProps;
      workInProgress.memoizedState = current.memoizedState;
      workInProgress.updateQueue = current.updateQueue;
      workInProgress.firstContextDependency = current.firstContextDependency;

      workInProgress.sibling = current.sibling;
      workInProgress.index = current.index;
      workInProgress.ref = current.ref;

      if (enableProfilerTimer) {
        workInProgress.selfBaseDuration = current.selfBaseDuration;
        workInProgress.treeBaseDuration = current.treeBaseDuration;
      }

      return workInProgress;
    }

    function createHostRootFiber(isConcurrent) {
      var mode = isConcurrent ? ConcurrentMode | StrictMode : NoContext;

      if (enableProfilerTimer && isDevToolsPresent) {
        mode |= ProfileMode;
      }

      return createFiber(HostRoot, null, null, mode);
    }

    function createFiberFromElement(element, mode, expirationTime) {
      var owner = null;
      {
        owner = element._owner;
      }

      var fiber = void 0;
      var type = element.type;
      var key = element.key;
      var pendingProps = element.props;

      var fiberTag = void 0;
      if (typeof type === "function") {
        fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;
      } else if (typeof type === "string") {
        fiberTag = HostComponent;
      } else {
        getTag: switch (type) {
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);
          case REACT_CONCURRENT_MODE_TYPE:
            fiberTag = Mode;
            mode |= ConcurrentMode | StrictMode;
            break;
          case REACT_STRICT_MODE_TYPE:
            fiberTag = Mode;
            mode |= StrictMode;
            break;
          case REACT_PROFILER_TYPE:
            return createFiberFromProfiler(pendingProps, mode, expirationTime, key);
          case REACT_PLACEHOLDER_TYPE:
            fiberTag = PlaceholderComponent;
            break;
          default:
            {
              if (typeof type === "object" && type !== null) {
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                    fiberTag = ContextProvider;
                    break getTag;
                  case REACT_CONTEXT_TYPE:
                    fiberTag = ContextConsumer;
                    break getTag;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = ForwardRef;
                    break getTag;
                  case REACT_PURE_TYPE:
                    fiberTag = PureComponent;
                    break getTag;
                  default:
                    {
                      if (typeof type.then === "function") {
                        fiberTag = IndeterminateComponent;
                        break getTag;
                      }
                    }
                }
              }
              var info = "";
              {
                if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                }
                var ownerName = owner ? getComponentName(owner.type) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              invariant(false, "Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + "but got: %s.%s", type == null ? type : typeof type, info);
            }
        }
      }

      fiber = createFiber(fiberTag, pendingProps, key, mode);
      fiber.type = type;
      fiber.expirationTime = expirationTime;

      {
        fiber._debugSource = element._source;
        fiber._debugOwner = element._owner;
      }

      return fiber;
    }

    function createFiberFromFragment(elements, mode, expirationTime, key) {
      var fiber = createFiber(Fragment, elements, key, mode);
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromProfiler(pendingProps, mode, expirationTime, key) {
      {
        if (typeof pendingProps.id !== "string" || typeof pendingProps.onRender !== "function") {
          warningWithoutStack$1(false, 'Profiler must specify an "id" string and "onRender" function as props');
        }
      }

      var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
      fiber.type = REACT_PROFILER_TYPE;
      fiber.expirationTime = expirationTime;

      return fiber;
    }

    function createFiberFromText(content, mode, expirationTime) {
      var fiber = createFiber(HostText, content, null, mode);
      fiber.expirationTime = expirationTime;
      return fiber;
    }

    function createFiberFromHostInstanceForDeletion() {
      var fiber = createFiber(HostComponent, null, null, NoContext);
      fiber.type = "DELETED";
      return fiber;
    }

    function createFiberFromPortal(portal, mode, expirationTime) {
      var pendingProps = portal.children !== null ? portal.children : [];
      var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
      fiber.expirationTime = expirationTime;
      fiber.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return fiber;
    }

    function assignFiberPropertiesInDEV(target, source) {
      if (target === null) {
        target = createFiber(IndeterminateComponent, null, null, NoContext);
      }

      target.tag = source.tag;
      target.key = source.key;
      target.type = source.type;
      target.stateNode = source.stateNode;
      target.return = source.return;
      target.child = source.child;
      target.sibling = source.sibling;
      target.index = source.index;
      target.ref = source.ref;
      target.pendingProps = source.pendingProps;
      target.memoizedProps = source.memoizedProps;
      target.updateQueue = source.updateQueue;
      target.memoizedState = source.memoizedState;
      target.firstContextDependency = source.firstContextDependency;
      target.mode = source.mode;
      target.effectTag = source.effectTag;
      target.nextEffect = source.nextEffect;
      target.firstEffect = source.firstEffect;
      target.lastEffect = source.lastEffect;
      target.expirationTime = source.expirationTime;
      target.childExpirationTime = source.childExpirationTime;
      target.alternate = source.alternate;
      if (enableProfilerTimer) {
        target.actualDuration = source.actualDuration;
        target.actualStartTime = source.actualStartTime;
        target.selfBaseDuration = source.selfBaseDuration;
        target.treeBaseDuration = source.treeBaseDuration;
      }
      target._debugID = source._debugID;
      target._debugSource = source._debugSource;
      target._debugOwner = source._debugOwner;
      target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;
      return target;
    }

    function createFiberRoot(containerInfo, isConcurrent, hydrate) {
      var uninitializedFiber = createHostRootFiber(isConcurrent);

      var root = void 0;
      if (enableSchedulerTracing) {
        root = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,

          earliestPendingTime: NoWork,
          latestPendingTime: NoWork,
          earliestSuspendedTime: NoWork,
          latestSuspendedTime: NoWork,
          latestPingedTime: NoWork,

          didError: false,

          pendingCommitExpirationTime: NoWork,
          finishedWork: null,
          timeoutHandle: noTimeout,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          nextExpirationTimeToWorkOn: NoWork,
          expirationTime: NoWork,
          firstBatch: null,
          nextScheduledRoot: null,

          interactionThreadID: tracing.unstable_getThreadID(),
          memoizedInteractions: new Set(),
          pendingInteractionMap: new Map()
        };
      } else {
        root = {
          current: uninitializedFiber,
          containerInfo: containerInfo,
          pendingChildren: null,

          earliestPendingTime: NoWork,
          latestPendingTime: NoWork,
          earliestSuspendedTime: NoWork,
          latestSuspendedTime: NoWork,
          latestPingedTime: NoWork,

          didError: false,

          pendingCommitExpirationTime: NoWork,
          finishedWork: null,
          timeoutHandle: noTimeout,
          context: null,
          pendingContext: null,
          hydrate: hydrate,
          nextExpirationTimeToWorkOn: NoWork,
          expirationTime: NoWork,
          firstBatch: null,
          nextScheduledRoot: null
        };
      }

      uninitializedFiber.stateNode = root;

      return root;
    }

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.warn(message);
        }
        try {
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error("`lowPriorityWarning(condition, format, ...args)` requires a warning " + "message argument");
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var ReactStrictModeWarnings = {
      discardPendingWarnings: function discardPendingWarnings() {},
      flushPendingDeprecationWarnings: function flushPendingDeprecationWarnings() {},
      flushPendingUnsafeLifecycleWarnings: function flushPendingUnsafeLifecycleWarnings() {},
      recordDeprecationWarnings: function recordDeprecationWarnings(fiber, instance) {},
      recordUnsafeLifecycleWarnings: function recordUnsafeLifecycleWarnings(fiber, instance) {},
      recordLegacyContextWarning: function recordLegacyContextWarning(fiber, instance) {},
      flushLegacyContextWarning: function flushLegacyContextWarning() {}
    };

    {
      var LIFECYCLE_SUGGESTIONS = {
        UNSAFE_componentWillMount: "componentDidMount",
        UNSAFE_componentWillReceiveProps: "static getDerivedStateFromProps",
        UNSAFE_componentWillUpdate: "componentDidUpdate"
      };

      var pendingComponentWillMountWarnings = [];
      var pendingComponentWillReceivePropsWarnings = [];
      var pendingComponentWillUpdateWarnings = [];
      var pendingUnsafeLifecycleWarnings = new Map();
      var pendingLegacyContextWarning = new Map();

      var didWarnAboutDeprecatedLifecycles = new Set();
      var didWarnAboutUnsafeLifecycles = new Set();
      var didWarnAboutLegacyContext = new Set();

      var setToSortedString = function setToSortedString(set) {
        var array = [];
        set.forEach(function (value) {
          array.push(value);
        });
        return array.sort().join(", ");
      };

      ReactStrictModeWarnings.discardPendingWarnings = function () {
        pendingComponentWillMountWarnings = [];
        pendingComponentWillReceivePropsWarnings = [];
        pendingComponentWillUpdateWarnings = [];
        pendingUnsafeLifecycleWarnings = new Map();
        pendingLegacyContextWarning = new Map();
      };

      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
        pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {
          var lifecyclesWarningMesages = [];

          Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {
            var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
            if (lifecycleWarnings.length > 0) {
              var componentNames = new Set();
              lifecycleWarnings.forEach(function (fiber) {
                componentNames.add(getComponentName(fiber.type) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });

              var formatted = lifecycle.replace("UNSAFE_", "");
              var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
              var sortedComponentNames = setToSortedString(componentNames);

              lifecyclesWarningMesages.push(formatted + ": Please update the following components to use " + (suggestion + " instead: " + sortedComponentNames));
            }
          });

          if (lifecyclesWarningMesages.length > 0) {
            var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

            warningWithoutStack$1(false, "Unsafe lifecycle methods were found within a strict-mode tree:%s" + "\n\n%s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, lifecyclesWarningMesages.join("\n\n"));
          }
        });

        pendingUnsafeLifecycleWarnings = new Map();
      };

      var findStrictRoot = function findStrictRoot(fiber) {
        var maybeStrictRoot = null;

        var node = fiber;
        while (node !== null) {
          if (node.mode & StrictMode) {
            maybeStrictRoot = node;
          }
          node = node.return;
        }

        return maybeStrictRoot;
      };

      ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {
        if (pendingComponentWillMountWarnings.length > 0) {
          var uniqueNames = new Set();
          pendingComponentWillMountWarnings.forEach(function (fiber) {
            uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var sortedNames = setToSortedString(uniqueNames);

          lowPriorityWarning$1(false, "componentWillMount is deprecated and will be removed in the next major version. " + "Use componentDidMount instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillMount." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", sortedNames);

          pendingComponentWillMountWarnings = [];
        }

        if (pendingComponentWillReceivePropsWarnings.length > 0) {
          var _uniqueNames = new Set();
          pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
            _uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var _sortedNames = setToSortedString(_uniqueNames);

          lowPriorityWarning$1(false, "componentWillReceiveProps is deprecated and will be removed in the next major version. " + "Use static getDerivedStateFromProps instead." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames);

          pendingComponentWillReceivePropsWarnings = [];
        }

        if (pendingComponentWillUpdateWarnings.length > 0) {
          var _uniqueNames2 = new Set();
          pendingComponentWillUpdateWarnings.forEach(function (fiber) {
            _uniqueNames2.add(getComponentName(fiber.type) || "Component");
            didWarnAboutDeprecatedLifecycles.add(fiber.type);
          });

          var _sortedNames2 = setToSortedString(_uniqueNames2);

          lowPriorityWarning$1(false, "componentWillUpdate is deprecated and will be removed in the next major version. " + "Use componentDidUpdate instead. As a temporary workaround, " + "you can rename to UNSAFE_componentWillUpdate." + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-async-component-lifecycle-hooks", _sortedNames2);

          pendingComponentWillUpdateWarnings = [];
        }
      };

      ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {
        if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {
          return;
        }

        if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
          pendingComponentWillMountWarnings.push(fiber);
        }
        if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
          pendingComponentWillReceivePropsWarnings.push(fiber);
        }
        if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
          pendingComponentWillUpdateWarnings.push(fiber);
        }
      };

      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
          warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
          return;
        }

        if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
          return;
        }

        var warningsForRoot = void 0;
        if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {
          warningsForRoot = {
            UNSAFE_componentWillMount: [],
            UNSAFE_componentWillReceiveProps: [],
            UNSAFE_componentWillUpdate: []
          };

          pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);
        } else {
          warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);
        }

        var unsafeLifecycles = [];
        if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === "function") {
          unsafeLifecycles.push("UNSAFE_componentWillMount");
        }
        if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          unsafeLifecycles.push("UNSAFE_componentWillReceiveProps");
        }
        if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === "function") {
          unsafeLifecycles.push("UNSAFE_componentWillUpdate");
        }

        if (unsafeLifecycles.length > 0) {
          unsafeLifecycles.forEach(function (lifecycle) {
            warningsForRoot[lifecycle].push(fiber);
          });
        }
      };

      ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
          warningWithoutStack$1(false, "Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
          return;
        }

        if (didWarnAboutLegacyContext.has(fiber.type)) {
          return;
        }

        var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

        if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
          if (warningsForRoot === undefined) {
            warningsForRoot = [];
            pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
          }
          warningsForRoot.push(fiber);
        }
      };

      ReactStrictModeWarnings.flushLegacyContextWarning = function () {
        pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
          var uniqueNames = new Set();
          fiberArray.forEach(function (fiber) {
            uniqueNames.add(getComponentName(fiber.type) || "Component");
            didWarnAboutLegacyContext.add(fiber.type);
          });

          var sortedNames = setToSortedString(uniqueNames);
          var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);

          warningWithoutStack$1(false, "Legacy context API has been detected within a strict-mode tree: %s" + "\n\nPlease update the following components: %s" + "\n\nLearn more about this warning here:" + "\nhttps://fb.me/react-strict-mode-warnings", strictRootComponentStack, sortedNames);
        });
      };
    }

    var ReactFiberInstrumentation = {
      debugTool: null
    };

    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

    function markPendingPriorityLevel(root, expirationTime) {
      root.didError = false;

      var earliestPendingTime = root.earliestPendingTime;
      if (earliestPendingTime === NoWork) {
        root.earliestPendingTime = root.latestPendingTime = expirationTime;
      } else {
        if (earliestPendingTime > expirationTime) {
          root.earliestPendingTime = expirationTime;
        } else {
          var latestPendingTime = root.latestPendingTime;
          if (latestPendingTime < expirationTime) {
            root.latestPendingTime = expirationTime;
          }
        }
      }
      findNextExpirationTimeToWorkOn(expirationTime, root);
    }

    function markCommittedPriorityLevels(root, earliestRemainingTime) {
      root.didError = false;

      if (earliestRemainingTime === NoWork) {
        root.earliestPendingTime = NoWork;
        root.latestPendingTime = NoWork;
        root.earliestSuspendedTime = NoWork;
        root.latestSuspendedTime = NoWork;
        root.latestPingedTime = NoWork;
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      var latestPendingTime = root.latestPendingTime;
      if (latestPendingTime !== NoWork) {
        if (latestPendingTime < earliestRemainingTime) {
          root.earliestPendingTime = root.latestPendingTime = NoWork;
        } else {
          var earliestPendingTime = root.earliestPendingTime;
          if (earliestPendingTime < earliestRemainingTime) {
            root.earliestPendingTime = root.latestPendingTime;
          }
        }
      }

      var earliestSuspendedTime = root.earliestSuspendedTime;
      if (earliestSuspendedTime === NoWork) {
        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      var latestSuspendedTime = root.latestSuspendedTime;
      if (earliestRemainingTime > latestSuspendedTime) {
        root.earliestSuspendedTime = NoWork;
        root.latestSuspendedTime = NoWork;
        root.latestPingedTime = NoWork;

        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      if (earliestRemainingTime < earliestSuspendedTime) {
        markPendingPriorityLevel(root, earliestRemainingTime);
        findNextExpirationTimeToWorkOn(NoWork, root);
        return;
      }

      findNextExpirationTimeToWorkOn(NoWork, root);
    }

    function hasLowerPriorityWork(root, erroredExpirationTime) {
      var latestPendingTime = root.latestPendingTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      var latestPingedTime = root.latestPingedTime;
      return latestPendingTime !== NoWork && latestPendingTime > erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime > erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime;
    }

    function isPriorityLevelSuspended(root, expirationTime) {
      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      return earliestSuspendedTime !== NoWork && expirationTime >= earliestSuspendedTime && expirationTime <= latestSuspendedTime;
    }

    function markSuspendedPriorityLevel(root, suspendedTime) {
      root.didError = false;
      clearPing(root, suspendedTime);

      var earliestPendingTime = root.earliestPendingTime;
      var latestPendingTime = root.latestPendingTime;
      if (earliestPendingTime === suspendedTime) {
        if (latestPendingTime === suspendedTime) {
          root.earliestPendingTime = root.latestPendingTime = NoWork;
        } else {
          root.earliestPendingTime = latestPendingTime;
        }
      } else if (latestPendingTime === suspendedTime) {
        root.latestPendingTime = earliestPendingTime;
      }

      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      if (earliestSuspendedTime === NoWork) {
        root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;
      } else {
        if (earliestSuspendedTime > suspendedTime) {
          root.earliestSuspendedTime = suspendedTime;
        } else if (latestSuspendedTime < suspendedTime) {
          root.latestSuspendedTime = suspendedTime;
        }
      }

      findNextExpirationTimeToWorkOn(suspendedTime, root);
    }

    function markPingedPriorityLevel(root, pingedTime) {
      root.didError = false;

      var latestPingedTime = root.latestPingedTime;
      if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {
        root.latestPingedTime = pingedTime;
      }
      findNextExpirationTimeToWorkOn(pingedTime, root);
    }

    function clearPing(root, completedTime) {
      var latestPingedTime = root.latestPingedTime;
      if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {
        root.latestPingedTime = NoWork;
      }
    }

    function findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {
      var earliestExpirationTime = renderExpirationTime;

      var earliestPendingTime = root.earliestPendingTime;
      var earliestSuspendedTime = root.earliestSuspendedTime;
      if (earliestExpirationTime === NoWork || earliestPendingTime !== NoWork && earliestPendingTime < earliestExpirationTime) {
        earliestExpirationTime = earliestPendingTime;
      }
      if (earliestExpirationTime === NoWork || earliestSuspendedTime !== NoWork && earliestSuspendedTime < earliestExpirationTime) {
        earliestExpirationTime = earliestSuspendedTime;
      }
      return earliestExpirationTime;
    }

    function didExpireAtExpirationTime(root, currentTime) {
      var expirationTime = root.expirationTime;
      if (expirationTime !== NoWork && currentTime >= expirationTime) {
        root.nextExpirationTimeToWorkOn = currentTime;
      }
    }

    function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
      var earliestSuspendedTime = root.earliestSuspendedTime;
      var latestSuspendedTime = root.latestSuspendedTime;
      var earliestPendingTime = root.earliestPendingTime;
      var latestPingedTime = root.latestPingedTime;

      var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;

      if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime > completedExpirationTime)) {
        nextExpirationTimeToWorkOn = latestSuspendedTime;
      }

      var expirationTime = nextExpirationTimeToWorkOn;
      if (expirationTime !== NoWork && earliestSuspendedTime !== NoWork && earliestSuspendedTime < expirationTime) {
        expirationTime = earliestSuspendedTime;
      }

      root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;
      root.expirationTime = expirationTime;
    }

    var UpdateState = 0;
    var ReplaceState = 1;
    var ForceUpdate = 2;
    var CaptureUpdate = 3;

    var hasForceUpdate = false;

    var didWarnUpdateInsideUpdate = void 0;
    var currentlyProcessingQueue = void 0;
    var resetCurrentlyProcessingQueue = void 0;
    {
      didWarnUpdateInsideUpdate = false;
      currentlyProcessingQueue = null;
      resetCurrentlyProcessingQueue = function resetCurrentlyProcessingQueue() {
        currentlyProcessingQueue = null;
      };
    }

    function createUpdateQueue(baseState) {
      var queue = {
        baseState: baseState,
        firstUpdate: null,
        lastUpdate: null,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
      return queue;
    }

    function cloneUpdateQueue(currentQueue) {
      var queue = {
        baseState: currentQueue.baseState,
        firstUpdate: currentQueue.firstUpdate,
        lastUpdate: currentQueue.lastUpdate,

        firstCapturedUpdate: null,
        lastCapturedUpdate: null,

        firstEffect: null,
        lastEffect: null,

        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
      return queue;
    }

    function createUpdate(expirationTime) {
      return {
        expirationTime: expirationTime,

        tag: UpdateState,
        payload: null,
        callback: null,

        next: null,
        nextEffect: null
      };
    }

    function appendUpdateToQueue(queue, update) {
      if (queue.lastUpdate === null) {
        queue.firstUpdate = queue.lastUpdate = update;
      } else {
        queue.lastUpdate.next = update;
        queue.lastUpdate = update;
      }
    }

    function enqueueUpdate(fiber, update) {
      var alternate = fiber.alternate;
      var queue1 = void 0;
      var queue2 = void 0;
      if (alternate === null) {
        queue1 = fiber.updateQueue;
        queue2 = null;
        if (queue1 === null) {
          queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
        }
      } else {
        queue1 = fiber.updateQueue;
        queue2 = alternate.updateQueue;
        if (queue1 === null) {
          if (queue2 === null) {
            queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
            queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);
          } else {
            queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
          }
        } else {
          if (queue2 === null) {
            queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
          } else {}
        }
      }
      if (queue2 === null || queue1 === queue2) {
        appendUpdateToQueue(queue1, update);
      } else {
        if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
          appendUpdateToQueue(queue1, update);
          appendUpdateToQueue(queue2, update);
        } else {
          appendUpdateToQueue(queue1, update);

          queue2.lastUpdate = update;
        }
      }

      {
        if ((fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {
          warningWithoutStack$1(false, "An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
          didWarnUpdateInsideUpdate = true;
        }
      }
    }

    function enqueueCapturedUpdate(workInProgress, update) {
      var workInProgressQueue = workInProgress.updateQueue;
      if (workInProgressQueue === null) {
        workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);
      } else {
        workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);
      }

      if (workInProgressQueue.lastCapturedUpdate === null) {
        workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;
      } else {
        workInProgressQueue.lastCapturedUpdate.next = update;
        workInProgressQueue.lastCapturedUpdate = update;
      }
    }

    function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
      var current = workInProgress.alternate;
      if (current !== null) {
        if (queue === current.updateQueue) {
          queue = workInProgress.updateQueue = cloneUpdateQueue(queue);
        }
      }
      return queue;
    }

    function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
      switch (update.tag) {
        case ReplaceState:
          {
            var _payload = update.payload;
            if (typeof _payload === "function") {
              {
                if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                  _payload.call(instance, prevState, nextProps);
                }
              }
              return _payload.call(instance, prevState, nextProps);
            }

            return _payload;
          }
        case CaptureUpdate:
          {
            workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;
          }

        case UpdateState:
          {
            var _payload2 = update.payload;
            var partialState = void 0;
            if (typeof _payload2 === "function") {
              {
                if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
                  _payload2.call(instance, prevState, nextProps);
                }
              }
              partialState = _payload2.call(instance, prevState, nextProps);
            } else {
              partialState = _payload2;
            }
            if (partialState === null || partialState === undefined) {
              return prevState;
            }

            return _extends({}, prevState, partialState);
          }
        case ForceUpdate:
          {
            hasForceUpdate = true;
            return prevState;
          }
      }
      return prevState;
    }

    function processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {
      hasForceUpdate = false;

      queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);

      {
        currentlyProcessingQueue = queue;
      }

      var newBaseState = queue.baseState;
      var newFirstUpdate = null;
      var newExpirationTime = NoWork;

      var update = queue.firstUpdate;
      var resultState = newBaseState;
      while (update !== null) {
        var updateExpirationTime = update.expirationTime;
        if (updateExpirationTime > renderExpirationTime) {
          if (newFirstUpdate === null) {
            newFirstUpdate = update;

            newBaseState = resultState;
          }

          if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {
            newExpirationTime = updateExpirationTime;
          }
        } else {
          resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
          var _callback = update.callback;
          if (_callback !== null) {
            workInProgress.effectTag |= Callback;

            update.nextEffect = null;
            if (queue.lastEffect === null) {
              queue.firstEffect = queue.lastEffect = update;
            } else {
              queue.lastEffect.nextEffect = update;
              queue.lastEffect = update;
            }
          }
        }

        update = update.next;
      }

      var newFirstCapturedUpdate = null;
      update = queue.firstCapturedUpdate;
      while (update !== null) {
        var _updateExpirationTime = update.expirationTime;
        if (_updateExpirationTime > renderExpirationTime) {
          if (newFirstCapturedUpdate === null) {
            newFirstCapturedUpdate = update;

            if (newFirstUpdate === null) {
              newBaseState = resultState;
            }
          }

          if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {
            newExpirationTime = _updateExpirationTime;
          }
        } else {
          resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);
          var _callback2 = update.callback;
          if (_callback2 !== null) {
            workInProgress.effectTag |= Callback;

            update.nextEffect = null;
            if (queue.lastCapturedEffect === null) {
              queue.firstCapturedEffect = queue.lastCapturedEffect = update;
            } else {
              queue.lastCapturedEffect.nextEffect = update;
              queue.lastCapturedEffect = update;
            }
          }
        }
        update = update.next;
      }

      if (newFirstUpdate === null) {
        queue.lastUpdate = null;
      }
      if (newFirstCapturedUpdate === null) {
        queue.lastCapturedUpdate = null;
      } else {
        workInProgress.effectTag |= Callback;
      }
      if (newFirstUpdate === null && newFirstCapturedUpdate === null) {
        newBaseState = resultState;
      }

      queue.baseState = newBaseState;
      queue.firstUpdate = newFirstUpdate;
      queue.firstCapturedUpdate = newFirstCapturedUpdate;

      workInProgress.expirationTime = newExpirationTime;
      workInProgress.memoizedState = resultState;

      {
        currentlyProcessingQueue = null;
      }
    }

    function callCallback(callback, context) {
      invariant(typeof callback === "function", "Invalid argument passed as callback. Expected a function. Instead " + "received: %s", callback);
      callback.call(context);
    }

    function resetHasForceUpdateBeforeProcessing() {
      hasForceUpdate = false;
    }

    function checkHasForceUpdateAfterProcessing() {
      return hasForceUpdate;
    }

    function commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {
      if (finishedQueue.firstCapturedUpdate !== null) {
        if (finishedQueue.lastUpdate !== null) {
          finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;
          finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;
        }

        finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;
      }

      commitUpdateEffects(finishedQueue.firstEffect, instance);
      finishedQueue.firstEffect = finishedQueue.lastEffect = null;

      commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
      finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
    }

    function commitUpdateEffects(effect, instance) {
      while (effect !== null) {
        var _callback3 = effect.callback;
        if (_callback3 !== null) {
          effect.callback = null;
          callCallback(_callback3, instance);
        }
        effect = effect.nextEffect;
      }
    }

    function createCapturedValue(value, source) {
      return {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }

    var warning = warningWithoutStack$1;

    {
      warning = function warning(condition, format) {
        if (condition) {
          return;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();


        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        warningWithoutStack$1.apply(undefined, [false, format + "%s"].concat(args, [stack]));
      };
    }

    var warning$1 = warning;

    var valueCursor = createCursor(null);

    var rendererSigil = void 0;
    {
      rendererSigil = {};
    }

    var currentlyRenderingFiber = null;
    var lastContextDependency = null;
    var lastContextWithAllBitsObserved = null;

    function resetContextDependences() {
      currentlyRenderingFiber = null;
      lastContextDependency = null;
      lastContextWithAllBitsObserved = null;
    }

    function pushProvider(providerFiber, nextValue) {
      var context = providerFiber.type._context;

      if (isPrimaryRenderer) {
        push(valueCursor, context._currentValue, providerFiber);

        context._currentValue = nextValue;
        {
          !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
          context._currentRenderer = rendererSigil;
        }
      } else {
        push(valueCursor, context._currentValue2, providerFiber);

        context._currentValue2 = nextValue;
        {
          !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, "Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.") : void 0;
          context._currentRenderer2 = rendererSigil;
        }
      }
    }

    function popProvider(providerFiber) {
      var currentValue = valueCursor.current;

      pop(valueCursor, providerFiber);

      var context = providerFiber.type._context;
      if (isPrimaryRenderer) {
        context._currentValue = currentValue;
      } else {
        context._currentValue2 = currentValue;
      }
    }

    function calculateChangedBits(context, newValue, oldValue) {
      if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue) {
          return 0;
        } else {
        var changedBits = typeof context._calculateChangedBits === "function" ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;

        {
          !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, "calculateChangedBits: Expected the return value to be a " + "31-bit integer. Instead received: %s", changedBits) : void 0;
        }
        return changedBits | 0;
      }
    }

    function propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {
      var fiber = workInProgress.child;
      if (fiber !== null) {
        fiber.return = workInProgress;
      }
      while (fiber !== null) {
        var nextFiber = void 0;

        var dependency = fiber.firstContextDependency;
        if (dependency !== null) {
          do {
            if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {

              if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
                var update = createUpdate(renderExpirationTime);
                update.tag = ForceUpdate;

                enqueueUpdate(fiber, update);
              }

              if (fiber.expirationTime === NoWork || fiber.expirationTime > renderExpirationTime) {
                fiber.expirationTime = renderExpirationTime;
              }
              var alternate = fiber.alternate;
              if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {
                alternate.expirationTime = renderExpirationTime;
              }

              var node = fiber.return;
              while (node !== null) {
                alternate = node.alternate;
                if (node.childExpirationTime === NoWork || node.childExpirationTime > renderExpirationTime) {
                  node.childExpirationTime = renderExpirationTime;
                  if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {
                    alternate.childExpirationTime = renderExpirationTime;
                  }
                } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {
                  alternate.childExpirationTime = renderExpirationTime;
                } else {
                  break;
                }
                node = node.return;
              }
            }
            nextFiber = fiber.child;
            dependency = dependency.next;
          } while (dependency !== null);
        } else if (fiber.tag === ContextProvider) {
          nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
        } else {
          nextFiber = fiber.child;
        }

        if (nextFiber !== null) {
          nextFiber.return = fiber;
        } else {
          nextFiber = fiber;
          while (nextFiber !== null) {
            if (nextFiber === workInProgress) {
              nextFiber = null;
              break;
            }
            var sibling = nextFiber.sibling;
            if (sibling !== null) {
              sibling.return = nextFiber.return;
              nextFiber = sibling;
              break;
            }

            nextFiber = nextFiber.return;
          }
        }
        fiber = nextFiber;
      }
    }

    function prepareToReadContext(workInProgress, renderExpirationTime) {
      currentlyRenderingFiber = workInProgress;
      lastContextDependency = null;
      lastContextWithAllBitsObserved = null;

      workInProgress.firstContextDependency = null;
    }

    function readContext(context, observedBits) {
      if (lastContextWithAllBitsObserved === context) {} else if (observedBits === false || observedBits === 0) {} else {
        var resolvedObservedBits = void 0;
        if (typeof observedBits !== "number" || observedBits === maxSigned31BitInt) {
          lastContextWithAllBitsObserved = context;
          resolvedObservedBits = maxSigned31BitInt;
        } else {
          resolvedObservedBits = observedBits;
        }

        var contextItem = {
          context: context,
          observedBits: resolvedObservedBits,
          next: null
        };

        if (lastContextDependency === null) {
          invariant(currentlyRenderingFiber !== null, "Context.unstable_read(): Context can only be read while React is " + "rendering, e.g. inside the render method or getDerivedStateFromProps.");

          currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
        } else {
          lastContextDependency = lastContextDependency.next = contextItem;
        }
      }
      return isPrimaryRenderer ? context._currentValue : context._currentValue2;
    }

    var NO_CONTEXT = {};

    var contextStackCursor$1 = createCursor(NO_CONTEXT);
    var contextFiberStackCursor = createCursor(NO_CONTEXT);
    var rootInstanceStackCursor = createCursor(NO_CONTEXT);

    function requiredContext(c) {
      invariant(c !== NO_CONTEXT, "Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
      return c;
    }

    function getRootHostContainer() {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      return rootInstance;
    }

    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber);

      push(contextFiberStackCursor, fiber, fiber);

      push(contextStackCursor$1, NO_CONTEXT, fiber);
      var nextRootContext = getRootHostContext(nextRootInstance);

      pop(contextStackCursor$1, fiber);
      push(contextStackCursor$1, nextRootContext, fiber);
    }

    function popHostContainer(fiber) {
      pop(contextStackCursor$1, fiber);
      pop(contextFiberStackCursor, fiber);
      pop(rootInstanceStackCursor, fiber);
    }

    function getHostContext() {
      var context = requiredContext(contextStackCursor$1.current);
      return context;
    }

    function pushHostContext(fiber) {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      var context = requiredContext(contextStackCursor$1.current);
      var nextContext = getChildHostContext(context, fiber.type, rootInstance);

      if (context === nextContext) {
        return;
      }

      push(contextFiberStackCursor, fiber, fiber);
      push(contextStackCursor$1, nextContext, fiber);
    }

    function popHostContext(fiber) {
      if (contextFiberStackCursor.current !== fiber) {
        return;
      }

      pop(contextStackCursor$1, fiber);
      pop(contextFiberStackCursor, fiber);
    }

    var commitTime = 0;
    var profilerStartTime = -1;

    function getCommitTime() {
      return commitTime;
    }

    function recordCommitTime() {
      if (!enableProfilerTimer) {
        return;
      }
      commitTime = now();
    }

    function startProfilerTimer(fiber) {
      if (!enableProfilerTimer) {
        return;
      }

      profilerStartTime = now();

      if (fiber.actualStartTime < 0) {
        fiber.actualStartTime = now();
      }
    }

    function stopProfilerTimerIfRunning(fiber) {
      if (!enableProfilerTimer) {
        return;
      }
      profilerStartTime = -1;
    }

    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
      if (!enableProfilerTimer) {
        return;
      }

      if (profilerStartTime >= 0) {
        var elapsedTime = now() - profilerStartTime;
        fiber.actualDuration += elapsedTime;
        if (overrideBaseTime) {
          fiber.selfBaseDuration = elapsedTime;
        }
        profilerStartTime = -1;
      }
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    function is(x, y) {
      if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }

    function shallowEqual(objA, objB) {
      if (is(objA, objB)) {
        return true;
      }

      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }

      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);

      if (keysA.length !== keysB.length) {
        return false;
      }

      for (var i = 0; i < keysA.length; i++) {
        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }

      return true;
    }

    var fakeInternalInstance = {};
    var isArray$1 = Array.isArray;

    var emptyRefsObject = new React.Component().refs;

    var didWarnAboutStateAssignmentForComponent = void 0;
    var didWarnAboutUninitializedState = void 0;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
    var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
    var didWarnAboutUndefinedDerivedState = void 0;
    var warnOnUndefinedDerivedState = void 0;
    var warnOnInvalidCallback = void 0;
    var didWarnAboutDirectlyAssigningPropsToState = void 0;
    var didWarnAboutContextTypeAndContextTypes = void 0;
    var didWarnAboutInvalidateContextType = void 0;

    {
      didWarnAboutStateAssignmentForComponent = new Set();
      didWarnAboutUninitializedState = new Set();
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
      didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
      didWarnAboutDirectlyAssigningPropsToState = new Set();
      didWarnAboutUndefinedDerivedState = new Set();
      didWarnAboutContextTypeAndContextTypes = new Set();
      didWarnAboutInvalidateContextType = new Set();

      var didWarnOnInvalidCallback = new Set();

      warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {
        if (callback === null || typeof callback === "function") {
          return;
        }
        var key = callerName + "_" + callback;
        if (!didWarnOnInvalidCallback.has(key)) {
          didWarnOnInvalidCallback.add(key);
          warningWithoutStack$1(false, "%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
        }
      };

      warnOnUndefinedDerivedState = function warnOnUndefinedDerivedState(type, partialState) {
        if (partialState === undefined) {
          var componentName = getComponentName(type) || "Component";
          if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
            didWarnAboutUndefinedDerivedState.add(componentName);
            warningWithoutStack$1(false, "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
          }
        }
      };

      Object.defineProperty(fakeInternalInstance, "_processChildContext", {
        enumerable: false,
        value: function value() {
          invariant(false, "_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
        }
      });
      Object.freeze(fakeInternalInstance);
    }

    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress.memoizedState;

      {
        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
          getDerivedStateFromProps(nextProps, prevState);
        }
      }

      var partialState = getDerivedStateFromProps(nextProps, prevState);

      {
        warnOnUndefinedDerivedState(ctor, partialState);
      }

      var memoizedState = partialState === null || partialState === undefined ? prevState : _extends({}, prevState, partialState);
      workInProgress.memoizedState = memoizedState;

      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
        updateQueue.baseState = memoizedState;
      }
    }

    var classComponentUpdater = {
      isMounted: isMounted,
      enqueueSetState: function enqueueSetState(inst, payload, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.payload = payload;
        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "setState");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueReplaceState: function enqueueReplaceState(inst, payload, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.tag = ReplaceState;
        update.payload = payload;

        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "replaceState");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      },
      enqueueForceUpdate: function enqueueForceUpdate(inst, callback) {
        var fiber = get$1(inst);
        var currentTime = requestCurrentTime();
        var expirationTime = computeExpirationForFiber(currentTime, fiber);

        var update = createUpdate(expirationTime);
        update.tag = ForceUpdate;

        if (callback !== undefined && callback !== null) {
          {
            warnOnInvalidCallback(callback, "forceUpdate");
          }
          update.callback = callback;
        }

        enqueueUpdate(fiber, update);
        scheduleWork(fiber, expirationTime);
      }
    };

    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress.stateNode;
      if (typeof instance.shouldComponentUpdate === "function") {
        startPhaseTimer(workInProgress, "shouldComponentUpdate");
        var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
        stopPhaseTimer();

        {
          !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, "%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentName(ctor) || "Component") : void 0;
        }

        return shouldUpdate;
      }

      if (ctor.prototype && ctor.prototype.isPureReactComponent) {
        return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
      }

      return true;
    }

    function checkClassInstance(workInProgress, ctor, newProps) {
      var instance = workInProgress.stateNode;
      {
        var name = getComponentName(ctor) || "Component";
        var renderPresent = instance.render;

        if (!renderPresent) {
          if (ctor.prototype && typeof ctor.prototype.render === "function") {
            warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
          } else {
            warningWithoutStack$1(false, "%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
          }
        }

        var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
        !noGetInitialStateOnES6 ? warningWithoutStack$1(false, "getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name) : void 0;
        var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
        !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, "getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name) : void 0;
        var noInstancePropTypes = !instance.propTypes;
        !noInstancePropTypes ? warningWithoutStack$1(false, "propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name) : void 0;
        var noInstanceContextType = !instance.contextType;
        !noInstanceContextType ? warningWithoutStack$1(false, "contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name) : void 0;
        var noInstanceContextTypes = !instance.contextTypes;
        !noInstanceContextTypes ? warningWithoutStack$1(false, "contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name) : void 0;

        if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
          didWarnAboutContextTypeAndContextTypes.add(ctor);
          warningWithoutStack$1(false, "%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
        }

        var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== "function";
        !noComponentShouldUpdate ? warningWithoutStack$1(false, "%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name) : void 0;
        if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
          warningWithoutStack$1(false, "%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentName(ctor) || "A pure component");
        }
        var noComponentDidUnmount = typeof instance.componentDidUnmount !== "function";
        !noComponentDidUnmount ? warningWithoutStack$1(false, "%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name) : void 0;
        var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== "function";
        !noComponentDidReceiveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name) : void 0;
        var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== "function";
        !noComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name) : void 0;
        var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== "function";
        !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, "%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name) : void 0;
        var hasMutatedProps = instance.props !== newProps;
        !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, "%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name) : void 0;
        var noInstanceDefaultProps = !instance.defaultProps;
        !noInstanceDefaultProps ? warningWithoutStack$1(false, "Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name) : void 0;

        if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
          warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentName(ctor));
        }

        var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== "function";
        !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, "%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
        var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromError !== "function";
        !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, "%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name) : void 0;
        var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== "function";
        !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, "%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name) : void 0;
        var _state = instance.state;
        if (_state && (typeof _state !== "object" || isArray$1(_state))) {
          warningWithoutStack$1(false, "%s.state: must be set to an object or null", name);
        }
        if (typeof instance.getChildContext === "function") {
          !(typeof ctor.childContextTypes === "object") ? warningWithoutStack$1(false, "%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name) : void 0;
        }
      }
    }

    function adoptClassInstance(workInProgress, instance) {
      instance.updater = classComponentUpdater;
      workInProgress.stateNode = instance;

      set(instance, workInProgress);
      {
        instance._reactInternalInstance = fakeInternalInstance;
      }
    }

    function constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {
      var isLegacyContextConsumer = false;
      var unmaskedContext = emptyContextObject;
      var context = null;
      var contextType = ctor.contextType;
      if (typeof contextType === "object" && contextType !== null) {
        {
          if (typeof contextType.unstable_read !== "function" && !didWarnAboutInvalidateContextType.has(ctor)) {
            didWarnAboutInvalidateContextType.add(ctor);
            warningWithoutStack$1(false, "%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext(). " + "Did you accidentally pass the Context.Provider instead?", getComponentName(ctor) || "Component");
          }
        }

        context = contextType.unstable_read();
      } else {
        unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
        var contextTypes = ctor.contextTypes;
        isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
        context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
      }

      {
        if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
          new ctor(props, context);
        }
      }

      var instance = new ctor(props, context);
      var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
      adoptClassInstance(workInProgress, instance);

      {
        if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
          var componentName = getComponentName(ctor) || "Component";
          if (!didWarnAboutUninitializedState.has(componentName)) {
            didWarnAboutUninitializedState.add(componentName);
            warningWithoutStack$1(false, "`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
          }
        }

        if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
          var foundWillMountName = null;
          var foundWillReceivePropsName = null;
          var foundWillUpdateName = null;
          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            foundWillMountName = "componentWillMount";
          } else if (typeof instance.UNSAFE_componentWillMount === "function") {
            foundWillMountName = "UNSAFE_componentWillMount";
          }
          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            foundWillReceivePropsName = "componentWillReceiveProps";
          } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
          }
          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            foundWillUpdateName = "componentWillUpdate";
          } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
            foundWillUpdateName = "UNSAFE_componentWillUpdate";
          }
          if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
            var _componentName = getComponentName(ctor) || "Component";
            var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
              didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
              warningWithoutStack$1(false, "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" + "The above lifecycles should be removed. Learn more about this warning here:\n" + "https://fb.me/react-async-component-lifecycle-hooks", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
            }
          }
        }
      }

      if (isLegacyContextConsumer) {
        cacheContext(workInProgress, unmaskedContext, context);
      }

      return instance;
    }

    function callComponentWillMount(workInProgress, instance) {
      startPhaseTimer(workInProgress, "componentWillMount");
      var oldState = instance.state;

      if (typeof instance.componentWillMount === "function") {
        instance.componentWillMount();
      }
      if (typeof instance.UNSAFE_componentWillMount === "function") {
        instance.UNSAFE_componentWillMount();
      }

      stopPhaseTimer();

      if (oldState !== instance.state) {
        {
          warningWithoutStack$1(false, "%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentName(workInProgress.type) || "Component");
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
    }

    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
      var oldState = instance.state;
      startPhaseTimer(workInProgress, "componentWillReceiveProps");
      if (typeof instance.componentWillReceiveProps === "function") {
        instance.componentWillReceiveProps(newProps, nextContext);
      }
      if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
        instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      }
      stopPhaseTimer();

      if (instance.state !== oldState) {
        {
          var componentName = getComponentName(workInProgress.type) || "Component";
          if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
            didWarnAboutStateAssignmentForComponent.add(componentName);
            warningWithoutStack$1(false, "%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
          }
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
    }

    function mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
      {
        checkClassInstance(workInProgress, ctor, newProps);
      }

      var instance = workInProgress.stateNode;
      instance.props = newProps;
      instance.state = workInProgress.memoizedState;
      instance.refs = emptyRefsObject;

      var contextType = ctor.contextType;
      if (typeof contextType === "object" && contextType !== null) {
        instance.context = contextType.unstable_read();
      } else {
        var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
        instance.context = getMaskedContext(workInProgress, unmaskedContext);
      }

      {
        if (instance.state === newProps) {
          var componentName = getComponentName(ctor) || "Component";
          if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
            didWarnAboutDirectlyAssigningPropsToState.add(componentName);
            warningWithoutStack$1(false, "%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
          }
        }

        if (workInProgress.mode & StrictMode) {
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);

          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
        }

        if (warnAboutDeprecatedLifecycles) {
          ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);
        }
      }

      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
        instance.state = workInProgress.memoizedState;
      }

      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        instance.state = workInProgress.memoizedState;
      }

      if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
        callComponentWillMount(workInProgress, instance);

        updateQueue = workInProgress.updateQueue;
        if (updateQueue !== null) {
          processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
          instance.state = workInProgress.memoizedState;
        }
      }

      if (typeof instance.componentDidMount === "function") {
        workInProgress.effectTag |= Update;
      }
    }

    function resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {
      var instance = workInProgress.stateNode;

      var oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;

      var oldContext = instance.context;
      var contextType = ctor.contextType;
      var nextContext = void 0;
      if (typeof contextType === "object" && contextType !== null) {
        nextContext = contextType.unstable_read();
      } else {
        var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
        nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
      }

      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
        if (oldProps !== newProps || oldContext !== nextContext) {
          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
      }

      resetHasForceUpdateBeforeProcessing();

      var oldState = workInProgress.memoizedState;
      var newState = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
        newState = workInProgress.memoizedState;
      }
      if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
        return false;
      }

      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        newState = workInProgress.memoizedState;
      }

      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

      if (shouldUpdate) {
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          startPhaseTimer(workInProgress, "componentWillMount");
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          stopPhaseTimer();
        }
        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }
      } else {
        if (typeof instance.componentDidMount === "function") {
          workInProgress.effectTag |= Update;
        }

        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      }

      instance.props = newProps;
      instance.state = newState;
      instance.context = nextContext;

      return shouldUpdate;
    }

    function updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {
      var instance = workInProgress.stateNode;

      var oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;

      var oldContext = instance.context;
      var contextType = ctor.contextType;
      var nextContext = void 0;
      if (typeof contextType === "object" && contextType !== null) {
        nextContext = contextType.unstable_read();
      } else {
        var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
        nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
      }

      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";

      if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
        if (oldProps !== newProps || oldContext !== nextContext) {
          callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
        }
      }

      resetHasForceUpdateBeforeProcessing();

      var oldState = workInProgress.memoizedState;
      var newState = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);
        newState = workInProgress.memoizedState;
      }

      if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
        if (typeof instance.componentDidUpdate === "function") {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Snapshot;
          }
        }
        return false;
      }

      if (typeof getDerivedStateFromProps === "function") {
        applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
        newState = workInProgress.memoizedState;
      }

      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

      if (shouldUpdate) {
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
          startPhaseTimer(workInProgress, "componentWillUpdate");
          if (typeof instance.componentWillUpdate === "function") {
            instance.componentWillUpdate(newProps, newState, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillUpdate === "function") {
            instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
          }
          stopPhaseTimer();
        }
        if (typeof instance.componentDidUpdate === "function") {
          workInProgress.effectTag |= Update;
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          workInProgress.effectTag |= Snapshot;
        }
      } else {
        if (typeof instance.componentDidUpdate === "function") {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Update;
          }
        }
        if (typeof instance.getSnapshotBeforeUpdate === "function") {
          if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
            workInProgress.effectTag |= Snapshot;
          }
        }

        workInProgress.memoizedProps = newProps;
        workInProgress.memoizedState = newState;
      }

      instance.props = newProps;
      instance.state = newState;
      instance.context = nextContext;

      return shouldUpdate;
    }

    var didWarnAboutMaps = void 0;
    var didWarnAboutGenerators = void 0;
    var didWarnAboutStringRefInStrictMode = void 0;
    var ownerHasKeyUseWarning = void 0;
    var ownerHasFunctionTypeWarning = void 0;
    var warnForMissingKey = function warnForMissingKey(child) {};

    {
      didWarnAboutMaps = false;
      didWarnAboutGenerators = false;
      didWarnAboutStringRefInStrictMode = {};

      ownerHasKeyUseWarning = {};
      ownerHasFunctionTypeWarning = {};

      warnForMissingKey = function warnForMissingKey(child) {
        if (child === null || typeof child !== "object") {
          return;
        }
        if (!child._store || child._store.validated || child.key != null) {
          return;
        }
        invariant(typeof child._store === "object", "React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = true;

        var currentComponentErrorInfo = "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information." + getCurrentFiberStackInDev();
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

        warning$1(false, "Each child in an array or iterator should have a unique " + '"key" prop. See https://fb.me/react-warning-keys for ' + "more information.");
      };
    }

    var isArray = Array.isArray;

    function coerceRef(returnFiber, current$$1, element) {
      var mixedRef = element.ref;
      if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
        {
          if (returnFiber.mode & StrictMode) {
            var componentName = getComponentName(returnFiber.type) || "Component";
            if (!didWarnAboutStringRefInStrictMode[componentName]) {
              warningWithoutStack$1(false, 'A string ref, "%s", has been found within a strict mode tree. ' + "String refs are a source of potential bugs and should be avoided. " + "We recommend using createRef() instead." + "\n%s" + "\n\nLearn more about using refs safely here:" + "\nhttps://fb.me/react-strict-mode-string-ref", mixedRef, getStackByFiberInDevAndProd(returnFiber));
              didWarnAboutStringRefInStrictMode[componentName] = true;
            }
          }
        }

        if (element._owner) {
          var owner = element._owner;
          var inst = void 0;
          if (owner) {
            var ownerFiber = owner;
            invariant(ownerFiber.tag === ClassComponent || ownerFiber.tag === ClassComponentLazy, "Function components cannot have refs.");
            inst = ownerFiber.stateNode;
          }
          invariant(inst, "Missing owner for string ref %s. This error is likely caused by a " + "bug in React. Please file an issue.", mixedRef);
          var stringRef = "" + mixedRef;

          if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === "function" && current$$1.ref._stringRef === stringRef) {
            return current$$1.ref;
          }
          var ref = function ref(value) {
            var refs = inst.refs;
            if (refs === emptyRefsObject) {
              refs = inst.refs = {};
            }
            if (value === null) {
              delete refs[stringRef];
            } else {
              refs[stringRef] = value;
            }
          };
          ref._stringRef = stringRef;
          return ref;
        } else {
          invariant(typeof mixedRef === "string", "Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          invariant(element._owner, "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" + " the following reasons:\n" + "1. You may be adding a ref to a function component\n" + "2. You may be adding a ref to a component that was not created inside a component's render method\n" + "3. You have multiple copies of React loaded\n" + "See https://fb.me/react-refs-must-have-owner for more information.", mixedRef);
        }
      }
      return mixedRef;
    }

    function throwOnInvalidObjectType(returnFiber, newChild) {
      if (returnFiber.type !== "textarea") {
        var addendum = "";
        {
          addendum = " If you meant to render a collection of children, use an array " + "instead." + getCurrentFiberStackInDev();
        }
        invariant(false, "Objects are not valid as a React child (found: %s).%s", Object.prototype.toString.call(newChild) === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : newChild, addendum);
      }
    }

    function warnOnFunctionType() {
      var currentComponentErrorInfo = "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it." + getCurrentFiberStackInDev();

      if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

      warning$1(false, "Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
    }

    function ChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (!shouldTrackSideEffects) {
          return;
        }

        var last = returnFiber.lastEffect;
        if (last !== null) {
          last.nextEffect = childToDelete;
          returnFiber.lastEffect = childToDelete;
        } else {
          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
        }
        childToDelete.nextEffect = null;
        childToDelete.effectTag = Deletion;
      }

      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) {
          return null;
        }

        var childToDelete = currentFirstChild;
        while (childToDelete !== null) {
          deleteChild(returnFiber, childToDelete);
          childToDelete = childToDelete.sibling;
        }
        return null;
      }

      function mapRemainingChildren(returnFiber, currentFirstChild) {
        var existingChildren = new Map();

        var existingChild = currentFirstChild;
        while (existingChild !== null) {
          if (existingChild.key !== null) {
            existingChildren.set(existingChild.key, existingChild);
          } else {
            existingChildren.set(existingChild.index, existingChild);
          }
          existingChild = existingChild.sibling;
        }
        return existingChildren;
      }

      function useFiber(fiber, pendingProps, expirationTime) {
        var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
        clone.index = 0;
        clone.sibling = null;
        return clone;
      }

      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects) {
          return lastPlacedIndex;
        }
        var current$$1 = newFiber.alternate;
        if (current$$1 !== null) {
          var oldIndex = current$$1.index;
          if (oldIndex < lastPlacedIndex) {
            newFiber.effectTag = Placement;
            return lastPlacedIndex;
          } else {
            return oldIndex;
          }
        } else {
          newFiber.effectTag = Placement;
          return lastPlacedIndex;
        }
      }

      function placeSingleChild(newFiber) {
        if (shouldTrackSideEffects && newFiber.alternate === null) {
          newFiber.effectTag = Placement;
        }
        return newFiber;
      }

      function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {
        if (current$$1 === null || current$$1.tag !== HostText) {
          var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        } else {
          var existing = useFiber(current$$1, textContent, expirationTime);
          existing.return = returnFiber;
          return existing;
        }
      }

      function updateElement(returnFiber, current$$1, element, expirationTime) {
        if (current$$1 !== null && current$$1.type === element.type) {
          var existing = useFiber(current$$1, element.props, expirationTime);
          existing.ref = coerceRef(returnFiber, current$$1, element);
          existing.return = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          var created = createFiberFromElement(element, returnFiber.mode, expirationTime);
          created.ref = coerceRef(returnFiber, current$$1, element);
          created.return = returnFiber;
          return created;
        }
      }

      function updatePortal(returnFiber, current$$1, portal, expirationTime) {
        if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {
          var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        } else {
          var existing = useFiber(current$$1, portal.children || [], expirationTime);
          existing.return = returnFiber;
          return existing;
        }
      }

      function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {
        if (current$$1 === null || current$$1.tag !== Fragment) {
          var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);
          created.return = returnFiber;
          return created;
        } else {
          var existing = useFiber(current$$1, fragment, expirationTime);
          existing.return = returnFiber;
          return existing;
        }
      }

      function createChild(returnFiber, newChild, expirationTime) {
        if (typeof newChild === "string" || typeof newChild === "number") {
          var created = createFiberFromText("" + newChild, returnFiber.mode, expirationTime);
          created.return = returnFiber;
          return created;
        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);
                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
            case REACT_PORTAL_TYPE:
              {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);
                _created2.return = returnFiber;
                return _created2;
              }
          }

          if (isArray(newChild) || getIteratorFn(newChild)) {
            var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);
            _created3.return = returnFiber;
            return _created3;
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }

      function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {

        var key = oldFiber !== null ? oldFiber.key : null;

        if (typeof newChild === "string" || typeof newChild === "number") {
          if (key !== null) {
            return null;
          }
          return updateTextNode(returnFiber, oldFiber, "" + newChild, expirationTime);
        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                if (newChild.key === key) {
                  if (newChild.type === REACT_FRAGMENT_TYPE) {
                    return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
                  }
                  return updateElement(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }
            case REACT_PORTAL_TYPE:
              {
                if (newChild.key === key) {
                  return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
                } else {
                  return null;
                }
              }
          }

          if (isArray(newChild) || getIteratorFn(newChild)) {
            if (key !== null) {
              return null;
            }

            return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }

      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
        if (typeof newChild === "string" || typeof newChild === "number") {
          var matchedFiber = existingChildren.get(newIdx) || null;
          return updateTextNode(returnFiber, matchedFiber, "" + newChild, expirationTime);
        }

        if (typeof newChild === "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                if (newChild.type === REACT_FRAGMENT_TYPE) {
                  return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
                }
                return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
              }
            case REACT_PORTAL_TYPE:
              {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);
              }
          }

          if (isArray(newChild) || getIteratorFn(newChild)) {
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);
          }

          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }

        return null;
      }

      function warnOnInvalidKey(child, knownKeys) {
        {
          if (typeof child !== "object" || child === null) {
            return knownKeys;
          }
          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(child);
              var key = child.key;
              if (typeof key !== "string") {
                break;
              }
              if (knownKeys === null) {
                knownKeys = new Set();
                knownKeys.add(key);
                break;
              }
              if (!knownKeys.has(key)) {
                knownKeys.add(key);
                break;
              }
              warning$1(false, "Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted — the behavior is unsupported and " + "could change in a future version.", key);
              break;
            default:
              break;
          }
        }
        return knownKeys;
      }

      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {

        {
          var knownKeys = null;
          for (var i = 0; i < newChildren.length; i++) {
            var child = newChildren[i];
            knownKeys = warnOnInvalidKey(child, knownKeys);
          }
        }

        var resultingFirstChild = null;
        var previousNewFiber = null;

        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;
        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
          if (newFiber === null) {
            if (oldFiber === null) {
              oldFiber = nextOldFiber;
            }
            break;
          }
          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {
              deleteChild(returnFiber, oldFiber);
            }
          }
          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            resultingFirstChild = newFiber;
          } else {
            previousNewFiber.sibling = newFiber;
          }
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (newIdx === newChildren.length) {
          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
            if (!_newFiber) {
              continue;
            }
            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber;
            } else {
              previousNewFiber.sibling = _newFiber;
            }
            previousNewFiber = _newFiber;
          }
          return resultingFirstChild;
        }

        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

        for (; newIdx < newChildren.length; newIdx++) {
          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
          if (_newFiber2) {
            if (shouldTrackSideEffects) {
              if (_newFiber2.alternate !== null) {
                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
              }
            }
            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber2;
            } else {
              previousNewFiber.sibling = _newFiber2;
            }
            previousNewFiber = _newFiber2;
          }
        }

        if (shouldTrackSideEffects) {
          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {

        var iteratorFn = getIteratorFn(newChildrenIterable);
        invariant(typeof iteratorFn === "function", "An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");

        {
          if (typeof Symbol === "function" && newChildrenIterable[typeof Symbol === "function" ? Symbol.toStringTag : "@@toStringTag"] === "Generator") {
            !didWarnAboutGenerators ? warning$1(false, "Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.") : void 0;
            didWarnAboutGenerators = true;
          }

          if (newChildrenIterable.entries === iteratorFn) {
            !didWarnAboutMaps ? warning$1(false, "Using Maps as children is unsupported and will likely yield " + "unexpected results. Convert it to a sequence/iterable of keyed " + "ReactElements instead.") : void 0;
            didWarnAboutMaps = true;
          }

          var _newChildren = iteratorFn.call(newChildrenIterable);
          if (_newChildren) {
            var knownKeys = null;
            var _step = _newChildren.next();
            for (; !_step.done; _step = _newChildren.next()) {
              var child = _step.value;
              knownKeys = warnOnInvalidKey(child, knownKeys);
            }
          }
        }

        var newChildren = iteratorFn.call(newChildrenIterable);
        invariant(newChildren != null, "An iterable object provided no iterator.");

        var resultingFirstChild = null;
        var previousNewFiber = null;

        var oldFiber = currentFirstChild;
        var lastPlacedIndex = 0;
        var newIdx = 0;
        var nextOldFiber = null;

        var step = newChildren.next();
        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          if (oldFiber.index > newIdx) {
            nextOldFiber = oldFiber;
            oldFiber = null;
          } else {
            nextOldFiber = oldFiber.sibling;
          }
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
          if (newFiber === null) {
            if (!oldFiber) {
              oldFiber = nextOldFiber;
            }
            break;
          }
          if (shouldTrackSideEffects) {
            if (oldFiber && newFiber.alternate === null) {
              deleteChild(returnFiber, oldFiber);
            }
          }
          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
          if (previousNewFiber === null) {
            resultingFirstChild = newFiber;
          } else {
            previousNewFiber.sibling = newFiber;
          }
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }

        if (step.done) {
          deleteRemainingChildren(returnFiber, oldFiber);
          return resultingFirstChild;
        }

        if (oldFiber === null) {
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
            if (_newFiber3 === null) {
              continue;
            }
            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber3;
            } else {
              previousNewFiber.sibling = _newFiber3;
            }
            previousNewFiber = _newFiber3;
          }
          return resultingFirstChild;
        }

        var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

        for (; !step.done; newIdx++, step = newChildren.next()) {
          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
          if (_newFiber4 !== null) {
            if (shouldTrackSideEffects) {
              if (_newFiber4.alternate !== null) {
                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
              }
            }
            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = _newFiber4;
            } else {
              previousNewFiber.sibling = _newFiber4;
            }
            previousNewFiber = _newFiber4;
          }
        }

        if (shouldTrackSideEffects) {
          existingChildren.forEach(function (child) {
            return deleteChild(returnFiber, child);
          });
        }

        return resultingFirstChild;
      }

      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
          var existing = useFiber(currentFirstChild, textContent, expirationTime);
          existing.return = returnFiber;
          return existing;
        }

        deleteRemainingChildren(returnFiber, currentFirstChild);
        var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);
        created.return = returnFiber;
        return created;
      }

      function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
        var key = element.key;
        var child = currentFirstChild;
        while (child !== null) {
          if (child.key === key) {
            if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
              existing.ref = coerceRef(returnFiber, child, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }
          child = child.sibling;
        }

        if (element.type === REACT_FRAGMENT_TYPE) {
          var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);
          created.return = returnFiber;
          return created;
        } else {
          var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);
          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
          _created4.return = returnFiber;
          return _created4;
        }
      }

      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
        var key = portal.key;
        var child = currentFirstChild;
        while (child !== null) {
          if (child.key === key) {
            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, portal.children || [], expirationTime);
              existing.return = returnFiber;
              return existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          } else {
            deleteChild(returnFiber, child);
          }
          child = child.sibling;
        }

        var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);
        created.return = returnFiber;
        return created;
      }

      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
        var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
        if (isUnkeyedTopLevelFragment) {
          newChild = newChild.props.children;
        }

        var isObject = typeof newChild === "object" && newChild !== null;

        if (isObject) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));
            case REACT_PORTAL_TYPE:
              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
          }
        }

        if (typeof newChild === "string" || typeof newChild === "number") {
          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, expirationTime));
        }

        if (isArray(newChild)) {
          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        if (getIteratorFn(newChild)) {
          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
        }

        if (isObject) {
          throwOnInvalidObjectType(returnFiber, newChild);
        }

        {
          if (typeof newChild === "function") {
            warnOnFunctionType();
          }
        }
        if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
          switch (returnFiber.tag) {
            case ClassComponent:
            case ClassComponentLazy:
              {
                {
                  var instance = returnFiber.stateNode;
                  if (instance.render._isMockFunction) {
                    break;
                  }
                }
              }

            case FunctionComponent:
              {
                var Component = returnFiber.type;
                invariant(false, "%s(...): Nothing was returned from render. This usually means a " + "return statement is missing. Or, to render nothing, " + "return null.", Component.displayName || Component.name || "Component");
              }
          }
        }

        return deleteRemainingChildren(returnFiber, currentFirstChild);
      }

      return reconcileChildFibers;
    }

    var reconcileChildFibers = ChildReconciler(true);
    var mountChildFibers = ChildReconciler(false);

    function cloneChildFibers(current$$1, workInProgress) {
      invariant(current$$1 === null || workInProgress.child === current$$1.child, "Resuming work not yet implemented.");

      if (workInProgress.child === null) {
        return;
      }

      var currentChild = workInProgress.child;
      var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
      workInProgress.child = newChild;

      newChild.return = workInProgress;
      while (currentChild.sibling !== null) {
        currentChild = currentChild.sibling;
        newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
        newChild.return = workInProgress;
      }
      newChild.sibling = null;
    }

    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;

    function enterHydrationState(fiber) {
      if (!supportsHydration) {
        return false;
      }

      var parentInstance = fiber.stateNode.containerInfo;
      nextHydratableInstance = getFirstHydratableChild(parentInstance);
      hydrationParentFiber = fiber;
      isHydrating = true;
      return true;
    }

    function deleteHydratableInstance(returnFiber, instance) {
      {
        switch (returnFiber.tag) {
          case HostRoot:
            didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
            break;
          case HostComponent:
            didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
            break;
        }
      }

      var childToDelete = createFiberFromHostInstanceForDeletion();
      childToDelete.stateNode = instance;
      childToDelete.return = returnFiber;
      childToDelete.effectTag = Deletion;

      if (returnFiber.lastEffect !== null) {
        returnFiber.lastEffect.nextEffect = childToDelete;
        returnFiber.lastEffect = childToDelete;
      } else {
        returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
      }
    }

    function insertNonHydratedInstance(returnFiber, fiber) {
      fiber.effectTag |= Placement;
      {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  var props = fiber.pendingProps;
                  didNotFindHydratableContainerInstance(parentContainer, type, props);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableContainerTextInstance(parentContainer, text);
                  break;
              }
              break;
            }
          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent:
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                  break;
                case HostText:
                  var _text = fiber.pendingProps;
                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                  break;
              }
              break;
            }
          default:
            return;
        }
      }
    }

    function tryHydrate(fiber, nextInstance) {
      switch (fiber.tag) {
        case HostComponent:
          {
            var type = fiber.type;
            var props = fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type, props);
            if (instance !== null) {
              fiber.stateNode = instance;
              return true;
            }
            return false;
          }
        case HostText:
          {
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              return true;
            }
            return false;
          }
        default:
          return false;
      }
    }

    function tryToClaimNextHydratableInstance(fiber) {
      if (!isHydrating) {
        return;
      }
      var nextInstance = nextHydratableInstance;
      if (!nextInstance) {
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      var firstAttemptedInstance = nextInstance;
      if (!tryHydrate(fiber, nextInstance)) {
        nextInstance = getNextHydratableSibling(firstAttemptedInstance);
        if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }

        deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
      }
      hydrationParentFiber = fiber;
      nextHydratableInstance = getFirstHydratableChild(nextInstance);
    }

    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
      if (!supportsHydration) {
        invariant(false, "Expected prepareToHydrateHostInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var instance = fiber.stateNode;
      var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);

      fiber.updateQueue = updatePayload;

      if (updatePayload !== null) {
        return true;
      }
      return false;
    }

    function prepareToHydrateHostTextInstance(fiber) {
      if (!supportsHydration) {
        invariant(false, "Expected prepareToHydrateHostTextInstance() to never be called. " + "This error is likely caused by a bug in React. Please file an issue.");
      }

      var textInstance = fiber.stateNode;
      var textContent = fiber.memoizedProps;
      var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
      {
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot:
                {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                  break;
                }
              case HostComponent:
                {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                  break;
                }
            }
          }
        }
      }
      return shouldUpdate;
    }

    function popToNextHostParent(fiber) {
      var parent = fiber.return;
      while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
        parent = parent.return;
      }
      hydrationParentFiber = parent;
    }

    function popHydrationState(fiber) {
      if (!supportsHydration) {
        return false;
      }
      if (fiber !== hydrationParentFiber) {
        return false;
      }
      if (!isHydrating) {
        popToNextHostParent(fiber);
        isHydrating = true;
        return false;
      }

      var type = fiber.type;

      if (fiber.tag !== HostComponent || type !== "head" && type !== "body" && !shouldSetTextContent(type, fiber.memoizedProps)) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          deleteHydratableInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }

      popToNextHostParent(fiber);
      nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
      return true;
    }

    function resetHydrationState() {
      if (!supportsHydration) {
        return;
      }

      hydrationParentFiber = null;
      nextHydratableInstance = null;
      isHydrating = false;
    }

    function readLazyComponentType(thenable) {
      var status = thenable._reactStatus;
      switch (status) {
        case Resolved:
          var Component = thenable._reactResult;
          return Component;
        case Rejected:
          throw thenable._reactResult;
        case Pending:
          throw thenable;
        default:
          {
            thenable._reactStatus = Pending;
            thenable.then(function (resolvedValue) {
              if (thenable._reactStatus === Pending) {
                thenable._reactStatus = Resolved;
                if (typeof resolvedValue === "object" && resolvedValue !== null) {
                  var defaultExport = resolvedValue.default;
                  resolvedValue = defaultExport !== undefined && defaultExport !== null ? defaultExport : resolvedValue;
                } else {
                  resolvedValue = resolvedValue;
                }
                thenable._reactResult = resolvedValue;
              }
            }, function (error) {
              if (thenable._reactStatus === Pending) {
                thenable._reactStatus = Rejected;
                thenable._reactResult = error;
              }
            });
            throw thenable;
          }
      }
    }

    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;

    var didWarnAboutBadClass = void 0;
    var didWarnAboutContextTypeOnFunctionComponent = void 0;
    var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
    var didWarnAboutFunctionRefs = void 0;

    {
      didWarnAboutBadClass = {};
      didWarnAboutContextTypeOnFunctionComponent = {};
      didWarnAboutGetDerivedStateOnFunctionComponent = {};
      didWarnAboutFunctionRefs = {};
    }

    function reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {
      if (current$$1 === null) {
        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      } else {
        workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);
      }
    }

    function forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime) {
      workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, null, renderExpirationTime);

      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    }

    function updateForwardRef(current$$1, workInProgress, type, nextProps, renderExpirationTime) {
      var render = type.render;
      var ref = workInProgress.ref;
      if (hasContextChanged()) {} else if (workInProgress.memoizedProps === nextProps) {
        var currentRef = current$$1 !== null ? current$$1.ref : null;
        if (ref === currentRef) {
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }
      }

      var nextChildren = void 0;
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        nextChildren = render(nextProps, ref);
        setCurrentPhase(null);
      }

      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updatePureComponent(current$$1, workInProgress, Component, nextProps, updateExpirationTime, renderExpirationTime) {
      var render = Component.render;

      if (current$$1 !== null && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {
        var prevProps = current$$1.memoizedProps;

        var compare = Component.compare;
        compare = compare !== null ? compare : shallowEqual;
        if (compare(prevProps, nextProps)) {
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }
      }

      var nextChildren = void 0;
      prepareToReadContext(workInProgress, renderExpirationTime);
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        nextChildren = render(nextProps);
        setCurrentPhase(null);
      }

      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateFragment(current$$1, workInProgress, renderExpirationTime) {
      var nextChildren = workInProgress.pendingProps;
      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
      return workInProgress.child;
    }

    function updateMode(current$$1, workInProgress, renderExpirationTime) {
      var nextChildren = workInProgress.pendingProps.children;
      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
      return workInProgress.child;
    }

    function updateProfiler(current$$1, workInProgress, renderExpirationTime) {
      if (enableProfilerTimer) {
        workInProgress.effectTag |= Update;
      }
      var nextProps = workInProgress.pendingProps;
      var nextChildren = nextProps.children;
      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function markRef(current$$1, workInProgress) {
      var ref = workInProgress.ref;
      if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {
        workInProgress.effectTag |= Ref;
      }
    }

    function updateFunctionComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
      var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      var nextChildren = void 0;
      prepareToReadContext(workInProgress, renderExpirationTime);
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        nextChildren = Component(nextProps, context);
        setCurrentPhase(null);
      }

      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {
      var hasContext = void 0;
      if (isContextProvider(Component)) {
        hasContext = true;
        pushContextProvider(workInProgress);
      } else {
        hasContext = false;
      }
      prepareToReadContext(workInProgress, renderExpirationTime);

      var shouldUpdate = void 0;
      if (current$$1 === null) {
        if (workInProgress.stateNode === null) {
          constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
          shouldUpdate = true;
        } else {
          shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);
        }
      } else {
        shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);
      }
      return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);
    }

    function finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {
      markRef(current$$1, workInProgress);

      var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;

      if (!shouldUpdate && !didCaptureError) {
        if (hasContext) {
          invalidateContextProvider(workInProgress, Component, false);
        }

        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
      }

      var instance = workInProgress.stateNode;

      ReactCurrentOwner$3.current = workInProgress;
      var nextChildren = void 0;
      if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
        nextChildren = null;

        if (enableProfilerTimer) {
          stopProfilerTimerIfRunning(workInProgress);
        }
      } else {
        {
          setCurrentPhase("render");
          nextChildren = instance.render();
          if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {
            instance.render();
          }
          setCurrentPhase(null);
        }
      }

      workInProgress.effectTag |= PerformedWork;
      if (current$$1 !== null && didCaptureError) {
        forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
      } else {
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      }

      memoizeState(workInProgress, instance.state);
      memoizeProps(workInProgress, instance.props);

      if (hasContext) {
        invalidateContextProvider(workInProgress, Component, true);
      }

      return workInProgress.child;
    }

    function pushHostRootContext(workInProgress) {
      var root = workInProgress.stateNode;
      if (root.pendingContext) {
        pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
      } else if (root.context) {
        pushTopLevelContextObject(workInProgress, root.context, false);
      }
      pushHostContainer(workInProgress, root.containerInfo);
    }

    function updateHostRoot(current$$1, workInProgress, renderExpirationTime) {
      pushHostRootContext(workInProgress);
      var updateQueue = workInProgress.updateQueue;
      invariant(updateQueue !== null, "If the root does not have an updateQueue, we should have already " + "bailed out. This error is likely caused by a bug in React. Please " + "file an issue.");
      var nextProps = workInProgress.pendingProps;
      var prevState = workInProgress.memoizedState;
      var prevChildren = prevState !== null ? prevState.element : null;
      processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);
      var nextState = workInProgress.memoizedState;

      var nextChildren = nextState.element;
      if (nextChildren === prevChildren) {
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
      }
      var root = workInProgress.stateNode;
      if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        workInProgress.effectTag |= Placement;

        workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      } else {
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        resetHydrationState();
      }
      return workInProgress.child;
    }

    function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
      pushHostContext(workInProgress);

      if (current$$1 === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }

      var type = workInProgress.type;
      var nextProps = workInProgress.pendingProps;
      var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;

      var nextChildren = nextProps.children;
      var isDirectTextChild = shouldSetTextContent(type, nextProps);

      if (isDirectTextChild) {
        nextChildren = null;
      } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
        workInProgress.effectTag |= ContentReset;
      }

      markRef(current$$1, workInProgress);

      if (renderExpirationTime !== Never && workInProgress.mode & ConcurrentMode && shouldDeprioritizeSubtree(type, nextProps)) {
        workInProgress.expirationTime = Never;
        workInProgress.memoizedProps = nextProps;
        return null;
      }

      reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextProps);
      return workInProgress.child;
    }

    function updateHostText(current$$1, workInProgress) {
      if (current$$1 === null) {
        tryToClaimNextHydratableInstance(workInProgress);
      }
      var nextProps = workInProgress.pendingProps;
      memoizeProps(workInProgress, nextProps);

      return null;
    }

    function resolveDefaultProps(Component, baseProps) {
      if (Component && Component.defaultProps) {
        var props = _extends({}, baseProps);
        var defaultProps = Component.defaultProps;
        for (var propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
        return props;
      }
      return baseProps;
    }

    function mountIndeterminateComponent(current$$1, workInProgress, Component, updateExpirationTime, renderExpirationTime) {
      invariant(current$$1 === null, "An indeterminate component should never have mounted. This error is " + "likely caused by a bug in React. Please file an issue.");

      var props = workInProgress.pendingProps;
      if (typeof Component === "object" && Component !== null && typeof Component.then === "function") {
        Component = readLazyComponentType(Component);
        var resolvedTag = workInProgress.tag = resolveLazyComponentTag(workInProgress, Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child = void 0;
        switch (resolvedTag) {
          case FunctionComponentLazy:
            {
              child = updateFunctionComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }
          case ClassComponentLazy:
            {
              child = updateClassComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }
          case ForwardRefLazy:
            {
              child = updateForwardRef(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);
              break;
            }
          case PureComponentLazy:
            {
              child = updatePureComponent(current$$1, workInProgress, Component, resolvedProps, updateExpirationTime, renderExpirationTime);
              break;
            }
          default:
            {
              invariant(false, "Element type is invalid. Received a promise that resolves to: %s. " + "Promise elements must resolve to a class or function.", Component);
            }
        }
        workInProgress.memoizedProps = props;
        return child;
      }

      var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
      var context = getMaskedContext(workInProgress, unmaskedContext);

      prepareToReadContext(workInProgress, renderExpirationTime);

      var value = void 0;

      {
        if (Component.prototype && typeof Component.prototype.render === "function") {
          var componentName = getComponentName(Component) || "Unknown";

          if (!didWarnAboutBadClass[componentName]) {
            warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
            didWarnAboutBadClass[componentName] = true;
          }
        }

        if (workInProgress.mode & StrictMode) {
          ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
        }

        ReactCurrentOwner$3.current = workInProgress;
        value = Component(props, context);
      }

      workInProgress.effectTag |= PerformedWork;

      if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
        workInProgress.tag = ClassComponent;

        var hasContext = false;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress);
        } else {
          hasContext = false;
        }

        workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;

        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
        }

        adoptClassInstance(workInProgress, value);
        mountClassInstance(workInProgress, Component, props, renderExpirationTime);
        return finishClassComponent(current$$1, workInProgress, Component, true, hasContext, renderExpirationTime);
      } else {
        workInProgress.tag = FunctionComponent;
        {
          if (Component) {
            !!Component.childContextTypes ? warningWithoutStack$1(false, "%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component") : void 0;
          }
          if (workInProgress.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += "\n\nCheck the render method of `" + ownerName + "`.";
            }

            var warningKey = ownerName || workInProgress._debugID || "";
            var debugSource = workInProgress._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutFunctionRefs[warningKey]) {
              didWarnAboutFunctionRefs[warningKey] = true;
              warning$1(false, "Function components cannot be given refs. " + "Attempts to access this ref will fail.%s", info);
            }
          }

          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName = getComponentName(Component) || "Unknown";

            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName]) {
              warningWithoutStack$1(false, "%s: Function components do not support getDerivedStateFromProps.", _componentName);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName] = true;
            }
          }

          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName2 = getComponentName(Component) || "Unknown";

            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName2]) {
              warningWithoutStack$1(false, "%s: Function components do not support contextType.", _componentName2);
              didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true;
            }
          }
        }
        reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);
        memoizeProps(workInProgress, props);
        return workInProgress.child;
      }
    }

    function updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime) {
      if (enableSuspense) {
        var nextProps = workInProgress.pendingProps;

        var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;

        var nextDidTimeout = void 0;
        if (current$$1 !== null && workInProgress.updateQueue !== null) {
          workInProgress.updateQueue = null;
          nextDidTimeout = true;
        } else {
          nextDidTimeout = !alreadyCaptured;
        }

        if ((workInProgress.mode & StrictMode) !== NoEffect) {
          if (nextDidTimeout) {
            workInProgress.effectTag |= Update;
          } else {
            workInProgress.stateNode = null;
          }
        }

        var children = nextProps.children;
        var nextChildren = void 0;
        if (typeof children === "function") {
          nextChildren = children(nextDidTimeout);
        } else {
          nextChildren = nextDidTimeout ? nextProps.fallback : children;
        }

        if (current$$1 !== null && nextDidTimeout !== workInProgress.memoizedState) {
          forceUnmountCurrentAndReconcile(current$$1, workInProgress, nextChildren, renderExpirationTime);
        } else {
          reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        }
        workInProgress.memoizedProps = nextProps;
        workInProgress.memoizedState = nextDidTimeout;
        return workInProgress.child;
      } else {
        return null;
      }
    }

    function updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      var nextChildren = workInProgress.pendingProps;
      if (current$$1 === null) {
        workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
        memoizeProps(workInProgress, nextChildren);
      } else {
        reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);
        memoizeProps(workInProgress, nextChildren);
      }
      return workInProgress.child;
    }

    function updateContextProvider(current$$1, workInProgress, renderExpirationTime) {
      var providerType = workInProgress.type;
      var context = providerType._context;

      var newProps = workInProgress.pendingProps;
      var oldProps = workInProgress.memoizedProps;

      var newValue = newProps.value;
      workInProgress.memoizedProps = newProps;

      {
        var providerPropTypes = workInProgress.type.propTypes;

        if (providerPropTypes) {
          checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider", getCurrentFiberStackInDev);
        }
      }

      pushProvider(workInProgress, newValue);

      if (oldProps !== null) {
        var oldValue = oldProps.value;
        var changedBits = calculateChangedBits(context, newValue, oldValue);
        if (changedBits === 0) {
          if (oldProps.children === newProps.children && !hasContextChanged()) {
            return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
          }
        } else {
          propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);
        }
      }

      var newChildren = newProps.children;
      reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
      return workInProgress.child;
    }

    function updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {
      var context = workInProgress.type;
      var newProps = workInProgress.pendingProps;
      var render = newProps.children;

      {
        !(typeof render === "function") ? warningWithoutStack$1(false, "A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.") : void 0;
      }

      prepareToReadContext(workInProgress, renderExpirationTime);
      var newValue = readContext(context, newProps.unstable_observedBits);
      var newChildren = void 0;
      {
        ReactCurrentOwner$3.current = workInProgress;
        setCurrentPhase("render");
        newChildren = render(newValue);
        setCurrentPhase(null);
      }

      workInProgress.effectTag |= PerformedWork;
      reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);
      workInProgress.memoizedProps = newProps;
      return workInProgress.child;
    }

    function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {
      cancelWorkTimer(workInProgress);

      if (current$$1 !== null) {
        workInProgress.firstContextDependency = current$$1.firstContextDependency;
      }

      if (enableProfilerTimer) {
        stopProfilerTimerIfRunning(workInProgress);
      }

      var childExpirationTime = workInProgress.childExpirationTime;
      if (childExpirationTime === NoWork || childExpirationTime > renderExpirationTime) {
        return null;
      } else {
        cloneChildFibers(current$$1, workInProgress);
        return workInProgress.child;
      }
    }

    function memoizeProps(workInProgress, nextProps) {
      workInProgress.memoizedProps = nextProps;
    }

    function memoizeState(workInProgress, nextState) {
      workInProgress.memoizedState = nextState;
    }

    function beginWork(current$$1, workInProgress, renderExpirationTime) {
      var updateExpirationTime = workInProgress.expirationTime;

      if (current$$1 !== null) {
        var oldProps = current$$1.memoizedProps;
        var newProps = workInProgress.pendingProps;
        if (oldProps === newProps && !hasContextChanged() && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {
          switch (workInProgress.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress);
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress);
              break;
            case ClassComponent:
              {
                var Component = workInProgress.type;
                if (isContextProvider(Component)) {
                  pushContextProvider(workInProgress);
                }
                break;
              }
            case ClassComponentLazy:
              {
                var thenable = workInProgress.type;
                var _Component = getResultFromResolvedThenable(thenable);
                if (isContextProvider(_Component)) {
                  pushContextProvider(workInProgress);
                }
                break;
              }
            case HostPortal:
              pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
              break;
            case ContextProvider:
              {
                var newValue = workInProgress.memoizedProps.value;
                pushProvider(workInProgress, newValue);
                break;
              }
            case Profiler:
              if (enableProfilerTimer) {
                workInProgress.effectTag |= Update;
              }
              break;
          }
          return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);
        }
      }

      workInProgress.expirationTime = NoWork;

      switch (workInProgress.tag) {
        case IndeterminateComponent:
          {
            var _Component2 = workInProgress.type;
            return mountIndeterminateComponent(current$$1, workInProgress, _Component2, updateExpirationTime, renderExpirationTime);
          }
        case FunctionComponent:
          {
            var _Component3 = workInProgress.type;
            var unresolvedProps = workInProgress.pendingProps;
            return updateFunctionComponent(current$$1, workInProgress, _Component3, unresolvedProps, renderExpirationTime);
          }
        case FunctionComponentLazy:
          {
            var _thenable = workInProgress.type;
            var _Component4 = getResultFromResolvedThenable(_thenable);
            var _unresolvedProps = workInProgress.pendingProps;
            var child = updateFunctionComponent(current$$1, workInProgress, _Component4, resolveDefaultProps(_Component4, _unresolvedProps), renderExpirationTime);
            workInProgress.memoizedProps = _unresolvedProps;
            return child;
          }
        case ClassComponent:
          {
            var _Component5 = workInProgress.type;
            var _unresolvedProps2 = workInProgress.pendingProps;
            return updateClassComponent(current$$1, workInProgress, _Component5, _unresolvedProps2, renderExpirationTime);
          }
        case ClassComponentLazy:
          {
            var _thenable2 = workInProgress.type;
            var _Component6 = getResultFromResolvedThenable(_thenable2);
            var _unresolvedProps3 = workInProgress.pendingProps;
            var _child = updateClassComponent(current$$1, workInProgress, _Component6, resolveDefaultProps(_Component6, _unresolvedProps3), renderExpirationTime);
            workInProgress.memoizedProps = _unresolvedProps3;
            return _child;
          }
        case HostRoot:
          return updateHostRoot(current$$1, workInProgress, renderExpirationTime);
        case HostComponent:
          return updateHostComponent(current$$1, workInProgress, renderExpirationTime);
        case HostText:
          return updateHostText(current$$1, workInProgress);
        case PlaceholderComponent:
          return updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime);
        case HostPortal:
          return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);
        case ForwardRef:
          {
            var type = workInProgress.type;
            return updateForwardRef(current$$1, workInProgress, type, workInProgress.pendingProps, renderExpirationTime);
          }
        case ForwardRefLazy:
          {
            var _thenable3 = workInProgress.type;
            var _Component7 = getResultFromResolvedThenable(_thenable3);
            var _unresolvedProps4 = workInProgress.pendingProps;
            var _child2 = updateForwardRef(current$$1, workInProgress, _Component7, resolveDefaultProps(_Component7, _unresolvedProps4), renderExpirationTime);
            workInProgress.memoizedProps = _unresolvedProps4;
            return _child2;
          }
        case Fragment:
          return updateFragment(current$$1, workInProgress, renderExpirationTime);
        case Mode:
          return updateMode(current$$1, workInProgress, renderExpirationTime);
        case Profiler:
          return updateProfiler(current$$1, workInProgress, renderExpirationTime);
        case ContextProvider:
          return updateContextProvider(current$$1, workInProgress, renderExpirationTime);
        case ContextConsumer:
          return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);
        case PureComponent:
          {
            var _type = workInProgress.type;
            return updatePureComponent(current$$1, workInProgress, _type, workInProgress.pendingProps, updateExpirationTime, renderExpirationTime);
          }
        case PureComponentLazy:
          {
            var _thenable4 = workInProgress.type;
            var _Component8 = getResultFromResolvedThenable(_thenable4);
            var _unresolvedProps5 = workInProgress.pendingProps;
            var _child3 = updatePureComponent(current$$1, workInProgress, _Component8, resolveDefaultProps(_Component8, _unresolvedProps5), updateExpirationTime, renderExpirationTime);
            workInProgress.memoizedProps = _unresolvedProps5;
            return _child3;
          }
        default:
          invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
      }
    }

    function markUpdate(workInProgress) {
      workInProgress.effectTag |= Update;
    }

    function markRef$1(workInProgress) {
      workInProgress.effectTag |= Ref;
    }

    function appendAllChildren(parent, workInProgress) {
      var node = workInProgress.child;
      while (node !== null) {
        if (node.tag === HostComponent || node.tag === HostText) {
          appendInitialChild(parent, node.stateNode);
        } else if (node.tag === HostPortal) {} else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === workInProgress) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === workInProgress) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    var updateHostContainer = void 0;
    var updateHostComponent$1 = void 0;
    var updateHostText$1 = void 0;
    if (supportsMutation) {

      updateHostContainer = function updateHostContainer(workInProgress) {};
      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
        var oldProps = current.memoizedProps;
        if (oldProps === newProps) {
          return;
        }

        var instance = workInProgress.stateNode;
        var currentHostContext = getHostContext();

        var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

        workInProgress.updateQueue = updatePayload;

        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else if (supportsPersistence) {
      var appendAllChildrenToContainer = function appendAllChildrenToContainer(containerChildSet, workInProgress) {
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {} else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === workInProgress) {
              return;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      };
      updateHostContainer = function updateHostContainer(workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {} else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);

          appendAllChildrenToContainer(newChildSet, workInProgress);
          portalOrRoot.pendingChildren = newChildSet;

          markUpdate(workInProgress);
          finalizeContainerChildren(container, newChildSet);
        }
      };
      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {
        var currentInstance = current.stateNode;
        var oldProps = current.memoizedProps;

        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged && oldProps === newProps) {
          workInProgress.stateNode = currentInstance;
          return;
        }
        var recyclableInstance = workInProgress.stateNode;
        var currentHostContext = getHostContext();
        var updatePayload = null;
        if (oldProps !== newProps) {
          updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
        }
        if (childrenUnchanged && updatePayload === null) {
          workInProgress.stateNode = currentInstance;
          return;
        }
        var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
        if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {
          markUpdate(workInProgress);
        }
        workInProgress.stateNode = newInstance;
        if (childrenUnchanged) {
          markUpdate(workInProgress);
        } else {
          appendAllChildren(newInstance, workInProgress);
        }
      };
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);

          markUpdate(workInProgress);
        }
      };
    } else {
      updateHostContainer = function updateHostContainer(workInProgress) {};
      updateHostComponent$1 = function updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance) {};
      updateHostText$1 = function updateHostText$1(current, workInProgress, oldText, newText) {};
    }

    function completeWork(current, workInProgress, renderExpirationTime) {
      var newProps = workInProgress.pendingProps;

      switch (workInProgress.tag) {
        case FunctionComponent:
        case FunctionComponentLazy:
          break;
        case ClassComponent:
          {
            var Component = workInProgress.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress);
            }
            break;
          }
        case ClassComponentLazy:
          {
            var _Component = getResultFromResolvedThenable(workInProgress.type);
            if (isContextProvider(_Component)) {
              popContext(workInProgress);
            }
            break;
          }
        case HostRoot:
          {
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            var fiberRoot = workInProgress.stateNode;
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current === null || current.child === null) {
              popHydrationState(workInProgress);

              workInProgress.effectTag &= ~Placement;
            }
            updateHostContainer(workInProgress);
            break;
          }
        case HostComponent:
          {
            popHostContext(workInProgress);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress.type;
            if (current !== null && workInProgress.stateNode != null) {
              updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

              if (current.ref !== workInProgress.ref) {
                markRef$1(workInProgress);
              }
            } else {
              if (!newProps) {
                invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");

                break;
              }

              var currentHostContext = getHostContext();

              var wasHydrated = popHydrationState(workInProgress);
              if (wasHydrated) {
                if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress);
                }
              } else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);

                appendAllChildren(instance, workInProgress);

                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress);
                }
                workInProgress.stateNode = instance;
              }

              if (workInProgress.ref !== null) {
                markRef$1(workInProgress);
              }
            }
            break;
          }
        case HostText:
          {
            var newText = newProps;
            if (current && workInProgress.stateNode != null) {
              var oldText = current.memoizedProps;

              updateHostText$1(current, workInProgress, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                invariant(workInProgress.stateNode !== null, "We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress);
              if (_wasHydrated) {
                if (prepareToHydrateHostTextInstance(workInProgress)) {
                  markUpdate(workInProgress);
                }
              } else {
                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
              }
            }
            break;
          }
        case ForwardRef:
        case ForwardRefLazy:
          break;
        case PlaceholderComponent:
          break;
        case Fragment:
          break;
        case Mode:
          break;
        case Profiler:
          break;
        case HostPortal:
          popHostContainer(workInProgress);
          updateHostContainer(workInProgress);
          break;
        case ContextProvider:
          popProvider(workInProgress);
          break;
        case ContextConsumer:
          break;
        case PureComponent:
        case PureComponentLazy:
          break;

        case IndeterminateComponent:
          invariant(false, "An indeterminate component should have become determinate before " + "completing. This error is likely caused by a bug in React. Please " + "file an issue.");

        default:
          invariant(false, "Unknown unit of work tag. This error is likely caused by a bug in " + "React. Please file an issue.");
      }

      return null;
    }

    function showErrorDialog(capturedError) {
      var componentStack = capturedError.componentStack,
          error = capturedError.error;

      var errorToHandle = void 0;

      if (error instanceof Error) {
        var message = error.message,
            name = error.name;

        var summary = message ? name + ": " + message : name;

        errorToHandle = error;

        try {
          errorToHandle.message = summary + "\n\nThis error is located at:" + componentStack;
        } catch (e) {}
      } else if (typeof error === "string") {
        errorToHandle = new Error(error + "\n\nThis error is located at:" + componentStack);
      } else {
        errorToHandle = new Error("Unspecified error at:" + componentStack);
      }

      ExceptionsManager.handleException(errorToHandle, false);

      return false;
    }

    function logCapturedError(capturedError) {
      var logError = showErrorDialog(capturedError);

      if (logError === false) {
        return;
      }

      var error = capturedError.error;
      {
        var componentName = capturedError.componentName,
            componentStack = capturedError.componentStack,
            errorBoundaryName = capturedError.errorBoundaryName,
            errorBoundaryFound = capturedError.errorBoundaryFound,
            willRetry = capturedError.willRetry;

        if (error != null && error._suppressLogging) {
          if (errorBoundaryFound && willRetry) {
            return;
          }

          console.error(error);
        }

        var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";

        var errorBoundaryMessage = void 0;

        if (errorBoundaryFound && errorBoundaryName) {
          if (willRetry) {
            errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
          } else {
            errorBoundaryMessage = "This error was initially handled by the error boundary " + errorBoundaryName + ".\n" + "Recreating the tree from scratch failed so React will unmount the tree.";
          }
        } else {
          errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n" + "Visit https://fb.me/react-error-boundaries to learn more about error boundaries.";
        }
        var combinedMessage = "" + componentNameMessage + componentStack + "\n\n" + ("" + errorBoundaryMessage);

        console.error(combinedMessage);
      }
    }

    var emptyObject$1 = {};

    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    {
      didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
    }

    function logError(boundary, errorInfo) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      if (stack === null && source !== null) {
        stack = getStackByFiberInDevAndProd(source);
      }

      var capturedError = {
        componentName: source !== null ? getComponentName(source.type) : null,
        componentStack: stack !== null ? stack : "",
        error: errorInfo.value,
        errorBoundary: null,
        errorBoundaryName: null,
        errorBoundaryFound: false,
        willRetry: false
      };

      if (boundary !== null && boundary.tag === ClassComponent) {
        capturedError.errorBoundary = boundary.stateNode;
        capturedError.errorBoundaryName = getComponentName(boundary.type);
        capturedError.errorBoundaryFound = true;
        capturedError.willRetry = true;
      }

      try {
        logCapturedError(capturedError);
      } catch (e) {
        setTimeout(function () {
          throw e;
        });
      }
    }

    var callComponentWillUnmountWithTimer = function callComponentWillUnmountWithTimer(current$$1, instance) {
      startPhaseTimer(current$$1, "componentWillUnmount");
      instance.props = current$$1.memoizedProps;
      instance.state = current$$1.memoizedState;
      instance.componentWillUnmount();
      stopPhaseTimer();
    };

    function safelyCallComponentWillUnmount(current$$1, instance) {
      {
        invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);
        if (hasCaughtError()) {
          var unmountError = clearCaughtError();
          captureCommitPhaseError(current$$1, unmountError);
        }
      }
    }

    function safelyDetachRef(current$$1) {
      var ref = current$$1.ref;
      if (ref !== null) {
        if (typeof ref === "function") {
          {
            invokeGuardedCallback(null, ref, null, null);
            if (hasCaughtError()) {
              var refError = clearCaughtError();
              captureCommitPhaseError(current$$1, refError);
            }
          }
        } else {
          ref.current = null;
        }
      }
    }

    function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            if (finishedWork.effectTag & Snapshot) {
              if (current$$1 !== null) {
                var prevProps = current$$1.memoizedProps;
                var prevState = current$$1.memoizedState;
                startPhaseTimer(finishedWork, "getSnapshotBeforeUpdate");
                var instance = finishedWork.stateNode;
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    warningWithoutStack$1(false, "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentName(finishedWork.type));
                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                stopPhaseTimer();
              }
            }
            return;
          }
        case HostRoot:
        case HostComponent:
        case HostText:
        case HostPortal:
          return;
        default:
          {
            invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
          }
      }
    }

    function commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {
      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            var instance = finishedWork.stateNode;
            if (finishedWork.effectTag & Update) {
              if (current$$1 === null) {
                startPhaseTimer(finishedWork, "componentDidMount");
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidMount();
                stopPhaseTimer();
              } else {
                var prevProps = current$$1.memoizedProps;
                var prevState = current$$1.memoizedState;
                startPhaseTimer(finishedWork, "componentDidUpdate");
                instance.props = finishedWork.memoizedProps;
                instance.state = finishedWork.memoizedState;
                instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                stopPhaseTimer();
              }
            }
            var updateQueue = finishedWork.updateQueue;
            if (updateQueue !== null) {
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);
            }
            return;
          }
        case HostRoot:
          {
            var _updateQueue = finishedWork.updateQueue;
            if (_updateQueue !== null) {
              var _instance = null;
              if (finishedWork.child !== null) {
                switch (finishedWork.child.tag) {
                  case HostComponent:
                    _instance = getPublicInstance(finishedWork.child.stateNode);
                    break;
                  case ClassComponent:
                  case ClassComponentLazy:
                    _instance = finishedWork.child.stateNode;
                    break;
                }
              }
              commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);
            }
            return;
          }
        case HostComponent:
          {
            var _instance2 = finishedWork.stateNode;

            if (current$$1 === null && finishedWork.effectTag & Update) {
              var type = finishedWork.type;
              var props = finishedWork.memoizedProps;
            }

            return;
          }
        case HostText:
          {
            return;
          }
        case HostPortal:
          {
            return;
          }
        case Profiler:
          {
            if (enableProfilerTimer) {
              var onRender = finishedWork.memoizedProps.onRender;

              if (enableSchedulerTracing) {
                onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);
              } else {
                onRender(finishedWork.memoizedProps.id, current$$1 === null ? "mount" : "update", finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());
              }
            }
            return;
          }
        case PlaceholderComponent:
          {
            if (enableSuspense) {
              if ((finishedWork.mode & StrictMode) === NoEffect) {
                finishedWork.updateQueue = emptyObject$1;
                scheduleWork(finishedWork, Sync);
              } else {
                var currentTime = requestCurrentTime();
                finishedWork.stateNode = { timedOutAt: currentTime };
              }
            }
            return;
          }
        default:
          {
            invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
          }
      }
    }

    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        var instance = finishedWork.stateNode;
        var instanceToUse = void 0;
        switch (finishedWork.tag) {
          case HostComponent:
            instanceToUse = getPublicInstance(instance);
            break;
          default:
            instanceToUse = instance;
        }
        if (typeof ref === "function") {
          ref(instanceToUse);
        } else {
          {
            if (!ref.hasOwnProperty("current")) {
              warningWithoutStack$1(false, "Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().%s", getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));
            }
          }

          ref.current = instanceToUse;
        }
      }
    }

    function commitDetachRef(current$$1) {
      var currentRef = current$$1.ref;
      if (currentRef !== null) {
        if (typeof currentRef === "function") {
          currentRef(null);
        } else {
          currentRef.current = null;
        }
      }
    }

    function commitUnmount(current$$1) {
      onCommitUnmount(current$$1);

      switch (current$$1.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            safelyDetachRef(current$$1);
            var instance = current$$1.stateNode;
            if (typeof instance.componentWillUnmount === "function") {
              safelyCallComponentWillUnmount(current$$1, instance);
            }
            return;
          }
        case HostComponent:
          {
            safelyDetachRef(current$$1);
            return;
          }
        case HostPortal:
          {
            if (supportsMutation) {
              unmountHostComponents(current$$1);
            } else if (supportsPersistence) {
              emptyPortalContainer(current$$1);
            }
            return;
          }
      }
    }

    function commitNestedUnmounts(root) {
      var node = root;
      while (true) {
        commitUnmount(node);

        if (node.child !== null && (!supportsMutation || node.tag !== HostPortal)) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === root) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === root) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function detachFiber(current$$1) {
      current$$1.return = null;
      current$$1.child = null;
      if (current$$1.alternate) {
        current$$1.alternate.child = null;
        current$$1.alternate.return = null;
      }
    }

    function emptyPortalContainer(current$$1) {
      if (!supportsPersistence) {
        return;
      }

      var portal = current$$1.stateNode;
      var containerInfo = portal.containerInfo;

      var emptyChildSet = createContainerChildSet(containerInfo);
      replaceContainerChildren(containerInfo, emptyChildSet);
    }

    function commitContainer(finishedWork) {
      if (!supportsPersistence) {
        return;
      }

      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            return;
          }
        case HostComponent:
          {
            return;
          }
        case HostText:
          {
            return;
          }
        case HostRoot:
        case HostPortal:
          {
            var portalOrRoot = finishedWork.stateNode;
            var containerInfo = portalOrRoot.containerInfo,
                _pendingChildren = portalOrRoot.pendingChildren;

            replaceContainerChildren(containerInfo, _pendingChildren);
            return;
          }
        default:
          {
            invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
          }
      }
    }

    function getHostParentFiber(fiber) {
      var parent = fiber.return;
      while (parent !== null) {
        if (isHostParent(parent)) {
          return parent;
        }
        parent = parent.return;
      }
      invariant(false, "Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
    }

    function isHostParent(fiber) {
      return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }

    function getHostSibling(fiber) {
      var node = fiber;
      siblings: while (true) {
        while (node.sibling === null) {
          if (node.return === null || isHostParent(node.return)) {
            return null;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
        while (node.tag !== HostComponent && node.tag !== HostText) {
          if (node.effectTag & Placement) {
            continue siblings;
          }

          if (node.child === null || node.tag === HostPortal) {
            continue siblings;
          } else {
            node.child.return = node;
            node = node.child;
          }
        }

        if (!(node.effectTag & Placement)) {
          return node.stateNode;
        }
      }
    }

    function commitPlacement(finishedWork) {
      if (!supportsMutation) {
        return;
      }

      var parentFiber = getHostParentFiber(finishedWork);

      var parent = void 0;
      var isContainer = void 0;

      switch (parentFiber.tag) {
        case HostComponent:
          parent = parentFiber.stateNode;
          isContainer = false;
          break;
        case HostRoot:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        case HostPortal:
          parent = parentFiber.stateNode.containerInfo;
          isContainer = true;
          break;
        default:
          invariant(false, "Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
      }
      if (parentFiber.effectTag & ContentReset) {
        parentFiber.effectTag &= ~ContentReset;
      }

      var before = getHostSibling(finishedWork);

      var node = finishedWork;
      while (true) {
        if (node.tag === HostComponent || node.tag === HostText) {
          if (before) {
            if (isContainer) {
              insertInContainerBefore(parent, node.stateNode, before);
            } else {
              insertBefore(parent, node.stateNode, before);
            }
          } else {
            if (isContainer) {
              appendChildToContainer(parent, node.stateNode);
            } else {
              appendChild(parent, node.stateNode);
            }
          }
        } else if (node.tag === HostPortal) {} else if (node.child !== null) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === finishedWork) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === finishedWork) {
            return;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function unmountHostComponents(current$$1) {
      var node = current$$1;

      var currentParentIsValid = false;

      var currentParent = void 0;
      var currentParentIsContainer = void 0;

      while (true) {
        if (!currentParentIsValid) {
          var parent = node.return;
          findParent: while (true) {
            invariant(parent !== null, "Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");
            switch (parent.tag) {
              case HostComponent:
                currentParent = parent.stateNode;
                currentParentIsContainer = false;
                break findParent;
              case HostRoot:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;
              case HostPortal:
                currentParent = parent.stateNode.containerInfo;
                currentParentIsContainer = true;
                break findParent;
            }
            parent = parent.return;
          }
          currentParentIsValid = true;
        }

        if (node.tag === HostComponent || node.tag === HostText) {
          commitNestedUnmounts(node);

          if (currentParentIsContainer) {
            removeChildFromContainer(currentParent, node.stateNode);
          } else {
            removeChild(currentParent, node.stateNode);
          }
        } else if (node.tag === HostPortal) {
          currentParent = node.stateNode.containerInfo;
          currentParentIsContainer = true;

          if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        } else {
          commitUnmount(node);

          if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        }
        if (node === current$$1) {
          return;
        }
        while (node.sibling === null) {
          if (node.return === null || node.return === current$$1) {
            return;
          }
          node = node.return;
          if (node.tag === HostPortal) {
            currentParentIsValid = false;
          }
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }

    function commitDeletion(current$$1) {
      if (supportsMutation) {
        unmountHostComponents(current$$1);
      } else {
        commitNestedUnmounts(current$$1);
      }
      detachFiber(current$$1);
    }

    function commitWork(current$$1, finishedWork) {
      if (!supportsMutation) {
        commitContainer(finishedWork);
        return;
      }

      switch (finishedWork.tag) {
        case ClassComponent:
        case ClassComponentLazy:
          {
            return;
          }
        case HostComponent:
          {
            var instance = finishedWork.stateNode;
            if (instance != null) {
              var newProps = finishedWork.memoizedProps;

              var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;
              var type = finishedWork.type;

              var updatePayload = finishedWork.updateQueue;
              finishedWork.updateQueue = null;
              if (updatePayload !== null) {
                commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
              }
            }
            return;
          }
        case HostText:
          {
            invariant(finishedWork.stateNode !== null, "This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
            var textInstance = finishedWork.stateNode;
            var newText = finishedWork.memoizedProps;

            var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;
            commitTextUpdate(textInstance, oldText, newText);
            return;
          }
        case HostRoot:
          {
            return;
          }
        case Profiler:
          {
            return;
          }
        case PlaceholderComponent:
          {
            return;
          }
        default:
          {
            invariant(false, "This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
          }
      }
    }

    function commitResetTextContent(current$$1) {
      if (!supportsMutation) {
        return;
      }
      resetTextContent(current$$1.stateNode);
    }

    function NoopComponent() {
      return null;
    }

    function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
      var update = createUpdate(expirationTime);

      update.tag = CaptureUpdate;

      update.payload = { element: null };
      var error = errorInfo.value;
      update.callback = function () {
        onUncaughtError(error);
        logError(fiber, errorInfo);
      };
      return update;
    }

    function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
      var update = createUpdate(expirationTime);
      update.tag = CaptureUpdate;
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError === "function") {
        var error = errorInfo.value;
        update.payload = function () {
          return getDerivedStateFromError(error);
        };
      }

      var inst = fiber.stateNode;
      if (inst !== null && typeof inst.componentDidCatch === "function") {
        update.callback = function callback() {
          if (typeof getDerivedStateFromError !== "function") {
            markLegacyErrorBoundaryAsFailed(this);
          }
          var error = errorInfo.value;
          var stack = errorInfo.stack;
          logError(fiber, errorInfo);
          this.componentDidCatch(error, {
            componentStack: stack !== null ? stack : ""
          });
          {
            if (typeof getDerivedStateFromError !== "function") {
              !(fiber.expirationTime === Sync) ? warningWithoutStack$1(false, "%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentName(fiber.type) || "Unknown") : void 0;
            }
          }
        };
      }
      return update;
    }

    function throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {
      sourceFiber.effectTag |= Incomplete;

      sourceFiber.firstEffect = sourceFiber.lastEffect = null;

      if (enableSuspense && value !== null && typeof value === "object" && typeof value.then === "function") {
        var thenable = value;

        var _workInProgress = returnFiber;
        var earliestTimeoutMs = -1;
        var startTimeMs = -1;
        do {
          if (_workInProgress.tag === PlaceholderComponent) {
            var current = _workInProgress.alternate;
            if (current !== null && current.memoizedState === true && current.stateNode !== null) {
              var timedOutAt = current.stateNode.timedOutAt;
              startTimeMs = expirationTimeToMs(timedOutAt);

              break;
            }
            var timeoutPropMs = _workInProgress.pendingProps.delayMs;
            if (typeof timeoutPropMs === "number") {
              if (timeoutPropMs <= 0) {
                earliestTimeoutMs = 0;
              } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {
                earliestTimeoutMs = timeoutPropMs;
              }
            }
          }
          _workInProgress = _workInProgress.return;
        } while (_workInProgress !== null);

        _workInProgress = returnFiber;
        do {
          if (_workInProgress.tag === PlaceholderComponent) {
            var didTimeout = _workInProgress.memoizedState;
            if (!didTimeout) {
              var pingTime = (_workInProgress.mode & ConcurrentMode) === NoEffect ? Sync : renderExpirationTime;

              var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, pingTime);
              if (enableSchedulerTracing) {
                onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
              }
              thenable.then(onResolveOrReject, onResolveOrReject);

              if ((_workInProgress.mode & StrictMode) === NoEffect) {
                _workInProgress.effectTag |= Update;

                var nextChildren = null;
                reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);
                sourceFiber.effectTag &= ~Incomplete;
                if (sourceFiber.tag === IndeterminateComponent) {
                  sourceFiber.tag = FunctionComponent;
                }

                if (sourceFiber.tag === ClassComponent || sourceFiber.tag === ClassComponentLazy) {
                  sourceFiber.effectTag &= ~LifecycleEffectMask;
                  if (sourceFiber.alternate === null) {
                    sourceFiber.tag = FunctionComponent;
                    sourceFiber.type = NoopComponent;
                  }
                }

                return;
              }

              var absoluteTimeoutMs = void 0;
              if (earliestTimeoutMs === -1) {
                absoluteTimeoutMs = maxSigned31BitInt;
              } else {
                if (startTimeMs === -1) {
                  var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);
                  var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
                  startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
                }
                absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
              }

              renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);

              _workInProgress.effectTag |= ShouldCapture;
              _workInProgress.expirationTime = renderExpirationTime;
              return;
            }
          }
          _workInProgress = _workInProgress.return;
        } while (_workInProgress !== null);

        value = new Error("An update was suspended, but no placeholder UI was provided.");
      }

      renderDidError();
      value = createCapturedValue(value, sourceFiber);
      var workInProgress = returnFiber;
      do {
        switch (workInProgress.tag) {
          case HostRoot:
            {
              var _errorInfo = value;
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime;
              var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);
              enqueueCapturedUpdate(workInProgress, update);
              return;
            }
          case ClassComponent:
          case ClassComponentLazy:
            var errorInfo = value;
            var ctor = workInProgress.type;
            var instance = workInProgress.stateNode;
            if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
              workInProgress.effectTag |= ShouldCapture;
              workInProgress.expirationTime = renderExpirationTime;

              var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);
              enqueueCapturedUpdate(workInProgress, _update);
              return;
            }
            break;
          default:
            break;
        }
        workInProgress = workInProgress.return;
      } while (workInProgress !== null);
    }

    function unwindWork(workInProgress, renderExpirationTime) {
      switch (workInProgress.tag) {
        case ClassComponent:
          {
            var Component = workInProgress.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress);
            }
            var effectTag = workInProgress.effectTag;
            if (effectTag & ShouldCapture) {
              workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case ClassComponentLazy:
          {
            var _Component = workInProgress.type._reactResult;
            if (isContextProvider(_Component)) {
              popContext(workInProgress);
            }
            var _effectTag = workInProgress.effectTag;
            if (_effectTag & ShouldCapture) {
              workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case HostRoot:
          {
            popHostContainer(workInProgress);
            popTopLevelContextObject(workInProgress);
            var _effectTag2 = workInProgress.effectTag;
            invariant((_effectTag2 & DidCapture) === NoEffect, "The root failed to unmount after an error. This is likely a bug in " + "React. Please file an issue.");
            workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;
            return workInProgress;
          }
        case HostComponent:
          {
            popHostContext(workInProgress);
            return null;
          }
        case PlaceholderComponent:
          {
            var _effectTag3 = workInProgress.effectTag;
            if (_effectTag3 & ShouldCapture) {
              workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;
              return workInProgress;
            }
            return null;
          }
        case HostPortal:
          popHostContainer(workInProgress);
          return null;
        case ContextProvider:
          popProvider(workInProgress);
          return null;
        default:
          return null;
      }
    }

    function unwindInterruptedWork(interruptedWork) {
      switch (interruptedWork.tag) {
        case ClassComponent:
          {
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== undefined) {
              popContext(interruptedWork);
            }
            break;
          }
        case ClassComponentLazy:
          {
            var _childContextTypes = interruptedWork.type._reactResult.childContextTypes;
            if (_childContextTypes !== null && _childContextTypes !== undefined) {
              popContext(interruptedWork);
            }
            break;
          }
        case HostRoot:
          {
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            break;
          }
        case HostComponent:
          {
            popHostContext(interruptedWork);
            break;
          }
        case HostPortal:
          popHostContainer(interruptedWork);
          break;
        case ContextProvider:
          popProvider(interruptedWork);
          break;
        default:
          break;
      }
    }

    var Dispatcher = {
      readContext: readContext
    };

    var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;

    var didWarnAboutStateTransition = void 0;
    var didWarnSetStateChildContext = void 0;
    var warnAboutUpdateOnUnmounted = void 0;
    var warnAboutInvalidUpdates = void 0;

    if (enableSchedulerTracing) {
      invariant(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null, "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) " + "without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. " + "Your bundler might have a setting for aliasing both modules. " + "Learn more at http://fb.me/react-profiling");
    }

    {
      didWarnAboutStateTransition = false;
      didWarnSetStateChildContext = false;
      var didWarnStateUpdateForUnmountedComponent = {};

      warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(fiber) {
        var componentName = getComponentName(fiber.type) || "ReactClass";
        if (didWarnStateUpdateForUnmountedComponent[componentName]) {
          return;
        }
        warningWithoutStack$1(false, "Can't call setState (or forceUpdate) on an unmounted component. This " + "is a no-op, but it indicates a memory leak in your application. To " + "fix, cancel all subscriptions and asynchronous tasks in the " + "componentWillUnmount method.%s", getStackByFiberInDevAndProd(fiber));
        didWarnStateUpdateForUnmountedComponent[componentName] = true;
      };

      warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {
        switch (phase) {
          case "getChildContext":
            if (didWarnSetStateChildContext) {
              return;
            }
            warningWithoutStack$1(false, "setState(...): Cannot call setState() inside getChildContext()");
            didWarnSetStateChildContext = true;
            break;
          case "render":
            if (didWarnAboutStateTransition) {
              return;
            }
            warningWithoutStack$1(false, "Cannot update during an existing state transition (such as within " + "`render`). Render methods should be a pure function of props and state.");
            didWarnAboutStateTransition = true;
            break;
        }
      };
    }

    var expirationContext = NoWork;

    var isWorking = false;

    var nextUnitOfWork = null;
    var nextRoot = null;

    var nextRenderExpirationTime = NoWork;
    var nextLatestAbsoluteTimeoutMs = -1;
    var nextRenderDidError = false;

    var nextEffect = null;

    var isCommitting$1 = false;

    var legacyErrorBoundariesThatAlreadyFailed = null;

    var interruptedBy = null;

    var stashedWorkInProgressProperties = void 0;
    var replayUnitOfWork = void 0;
    var isReplayingFailedUnitOfWork = void 0;
    var originalReplayError = void 0;
    var rethrowOriginalError = void 0;
    if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
      stashedWorkInProgressProperties = null;
      isReplayingFailedUnitOfWork = false;
      originalReplayError = null;
      replayUnitOfWork = function replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy) {
        if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
          return;
        }

        if (stashedWorkInProgressProperties === null) {
          warningWithoutStack$1(false, "Could not replay rendering after an error. This is likely a bug in React. " + "Please file an issue.");
          return;
        }
        assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);

        switch (failedUnitOfWork.tag) {
          case HostRoot:
            popHostContainer(failedUnitOfWork);
            popTopLevelContextObject(failedUnitOfWork);
            break;
          case HostComponent:
            popHostContext(failedUnitOfWork);
            break;
          case ClassComponent:
            {
              var Component = failedUnitOfWork.type;
              if (isContextProvider(Component)) {
                popContext(failedUnitOfWork);
              }
              break;
            }
          case ClassComponentLazy:
            {
              var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);
              if (isContextProvider(_Component)) {
                popContext(failedUnitOfWork);
              }
              break;
            }
          case HostPortal:
            popHostContainer(failedUnitOfWork);
            break;
          case ContextProvider:
            popProvider(failedUnitOfWork);
            break;
        }

        isReplayingFailedUnitOfWork = true;
        originalReplayError = thrownValue;
        invokeGuardedCallback(null, workLoop, null, isYieldy);
        isReplayingFailedUnitOfWork = false;
        originalReplayError = null;
        if (hasCaughtError()) {
          var replayError = clearCaughtError();
          if (replayError != null && thrownValue != null) {
            try {
              if (replayError._suppressLogging) {
                thrownValue._suppressLogging = true;
              }
            } catch (inner) {}
          }
        } else {
          nextUnitOfWork = failedUnitOfWork;
        }
      };
      rethrowOriginalError = function rethrowOriginalError() {
        throw originalReplayError;
      };
    }

    function resetStack() {
      if (nextUnitOfWork !== null) {
        var interruptedWork = nextUnitOfWork.return;
        while (interruptedWork !== null) {
          unwindInterruptedWork(interruptedWork);
          interruptedWork = interruptedWork.return;
        }
      }

      {
        ReactStrictModeWarnings.discardPendingWarnings();
        checkThatStackIsEmpty();
      }

      nextRoot = null;
      nextRenderExpirationTime = NoWork;
      nextLatestAbsoluteTimeoutMs = -1;
      nextRenderDidError = false;
      nextUnitOfWork = null;
    }

    function commitAllHostEffects() {
      while (nextEffect !== null) {
        {
          setCurrentFiber(nextEffect);
        }
        recordEffect();

        var effectTag = nextEffect.effectTag;

        if (effectTag & ContentReset) {
          commitResetTextContent(nextEffect);
        }

        if (effectTag & Ref) {
          var current$$1 = nextEffect.alternate;
          if (current$$1 !== null) {
            commitDetachRef(current$$1);
          }
        }

        var primaryEffectTag = effectTag & (Placement | Update | Deletion);
        switch (primaryEffectTag) {
          case Placement:
            {
              commitPlacement(nextEffect);

              nextEffect.effectTag &= ~Placement;
              break;
            }
          case PlacementAndUpdate:
            {
              commitPlacement(nextEffect);

              nextEffect.effectTag &= ~Placement;

              var _current = nextEffect.alternate;
              commitWork(_current, nextEffect);
              break;
            }
          case Update:
            {
              var _current2 = nextEffect.alternate;
              commitWork(_current2, nextEffect);
              break;
            }
          case Deletion:
            {
              commitDeletion(nextEffect);
              break;
            }
        }
        nextEffect = nextEffect.nextEffect;
      }

      {
        resetCurrentFiber();
      }
    }

    function commitBeforeMutationLifecycles() {
      while (nextEffect !== null) {
        {
          setCurrentFiber(nextEffect);
        }

        var effectTag = nextEffect.effectTag;
        if (effectTag & Snapshot) {
          recordEffect();
          var current$$1 = nextEffect.alternate;
          commitBeforeMutationLifeCycles(current$$1, nextEffect);
        }

        nextEffect = nextEffect.nextEffect;
      }

      {
        resetCurrentFiber();
      }
    }

    function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
      {
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
        ReactStrictModeWarnings.flushLegacyContextWarning();

        if (warnAboutDeprecatedLifecycles) {
          ReactStrictModeWarnings.flushPendingDeprecationWarnings();
        }
      }
      while (nextEffect !== null) {
        var effectTag = nextEffect.effectTag;

        if (effectTag & (Update | Callback)) {
          recordEffect();
          var current$$1 = nextEffect.alternate;
          commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);
        }

        if (effectTag & Ref) {
          recordEffect();
          commitAttachRef(nextEffect);
        }

        var next = nextEffect.nextEffect;

        nextEffect.nextEffect = null;

        nextEffect = next;
      }
    }

    function isAlreadyFailedLegacyErrorBoundary(instance) {
      return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
    }

    function markLegacyErrorBoundaryAsFailed(instance) {
      if (legacyErrorBoundariesThatAlreadyFailed === null) {
        legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
      } else {
        legacyErrorBoundariesThatAlreadyFailed.add(instance);
      }
    }

    function commitRoot(root, finishedWork) {
      isWorking = true;
      isCommitting$1 = true;
      startCommitTimer();

      invariant(root.current !== finishedWork, "Cannot commit the same tree as before. This is probably a bug " + "related to the return field. This error is likely caused by a bug " + "in React. Please file an issue.");
      var committedExpirationTime = root.pendingCommitExpirationTime;
      invariant(committedExpirationTime !== NoWork, "Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
      root.pendingCommitExpirationTime = NoWork;

      var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;
      var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
      var earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || childExpirationTimeBeforeCommit !== NoWork && childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;
      markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);

      var prevInteractions = null;
      if (enableSchedulerTracing) {
        prevInteractions = tracing.__interactionsRef.current;
        tracing.__interactionsRef.current = root.memoizedInteractions;
      }

      ReactCurrentOwner$2.current = null;

      var firstEffect = void 0;
      if (finishedWork.effectTag > PerformedWork) {
        if (finishedWork.lastEffect !== null) {
          finishedWork.lastEffect.nextEffect = finishedWork;
          firstEffect = finishedWork.firstEffect;
        } else {
          firstEffect = finishedWork;
        }
      } else {
        firstEffect = finishedWork.firstEffect;
      }

      prepareForCommit(root.containerInfo);

      nextEffect = firstEffect;
      startCommitSnapshotEffectsTimer();
      while (nextEffect !== null) {
        var didError = false;
        var error = void 0;
        {
          invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);
          if (hasCaughtError()) {
            didError = true;
            error = clearCaughtError();
          }
        }
        if (didError) {
          invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
          captureCommitPhaseError(nextEffect, error);

          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }
      stopCommitSnapshotEffectsTimer();

      if (enableProfilerTimer) {
        recordCommitTime();
      }

      nextEffect = firstEffect;
      startCommitHostEffectsTimer();
      while (nextEffect !== null) {
        var _didError = false;
        var _error = void 0;
        {
          invokeGuardedCallback(null, commitAllHostEffects, null);
          if (hasCaughtError()) {
            _didError = true;
            _error = clearCaughtError();
          }
        }
        if (_didError) {
          invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
          captureCommitPhaseError(nextEffect, _error);

          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }
      stopCommitHostEffectsTimer();

      resetAfterCommit(root.containerInfo);

      root.current = finishedWork;

      nextEffect = firstEffect;
      startCommitLifeCyclesTimer();
      while (nextEffect !== null) {
        var _didError2 = false;
        var _error2 = void 0;
        {
          invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);
          if (hasCaughtError()) {
            _didError2 = true;
            _error2 = clearCaughtError();
          }
        }
        if (_didError2) {
          invariant(nextEffect !== null, "Should have next effect. This error is likely caused by a bug " + "in React. Please file an issue.");
          captureCommitPhaseError(nextEffect, _error2);
          if (nextEffect !== null) {
            nextEffect = nextEffect.nextEffect;
          }
        }
      }

      isCommitting$1 = false;
      isWorking = false;
      stopCommitLifeCyclesTimer();
      stopCommitTimer();
      onCommitRoot(finishedWork.stateNode);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
      }

      var updateExpirationTimeAfterCommit = finishedWork.expirationTime;
      var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;
      var earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || childExpirationTimeAfterCommit !== NoWork && childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;
      if (earliestRemainingTimeAfterCommit === NoWork) {
        legacyErrorBoundariesThatAlreadyFailed = null;
      }
      onCommit(root, earliestRemainingTimeAfterCommit);

      if (enableSchedulerTracing) {
        tracing.__interactionsRef.current = prevInteractions;

        var subscriber = void 0;

        try {
          subscriber = tracing.__subscriberRef.current;
          if (subscriber !== null && root.memoizedInteractions.size > 0) {
            var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);
            subscriber.onWorkStopped(root.memoizedInteractions, threadID);
          }
        } catch (error) {
          if (!hasUnhandledError) {
            hasUnhandledError = true;
            unhandledError = error;
          }
        } finally {
          var pendingInteractionMap = root.pendingInteractionMap;
          pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
            if (earliestRemainingTimeAfterCommit === NoWork || scheduledExpirationTime < earliestRemainingTimeAfterCommit) {
              pendingInteractionMap.delete(scheduledExpirationTime);

              scheduledInteractions.forEach(function (interaction) {
                interaction.__count--;

                if (subscriber !== null && interaction.__count === 0) {
                  try {
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  } catch (error) {
                    if (!hasUnhandledError) {
                      hasUnhandledError = true;
                      unhandledError = error;
                    }
                  }
                }
              });
            }
          });
        }
      }
    }

    function resetChildExpirationTime(workInProgress, renderTime) {
      if (renderTime !== Never && workInProgress.childExpirationTime === Never) {
        return;
      }

      var newChildExpirationTime = NoWork;

      if (enableProfilerTimer && workInProgress.mode & ProfileMode) {
        var actualDuration = workInProgress.actualDuration;
        var treeBaseDuration = workInProgress.selfBaseDuration;

        var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;

        var child = workInProgress.child;
        while (child !== null) {
          var childUpdateExpirationTime = child.expirationTime;
          var childChildExpirationTime = child.childExpirationTime;
          if (newChildExpirationTime === NoWork || childUpdateExpirationTime !== NoWork && childUpdateExpirationTime < newChildExpirationTime) {
            newChildExpirationTime = childUpdateExpirationTime;
          }
          if (newChildExpirationTime === NoWork || childChildExpirationTime !== NoWork && childChildExpirationTime < newChildExpirationTime) {
            newChildExpirationTime = childChildExpirationTime;
          }
          if (shouldBubbleActualDurations) {
            actualDuration += child.actualDuration;
          }
          treeBaseDuration += child.treeBaseDuration;
          child = child.sibling;
        }
        workInProgress.actualDuration = actualDuration;
        workInProgress.treeBaseDuration = treeBaseDuration;
      } else {
        var _child = workInProgress.child;
        while (_child !== null) {
          var _childUpdateExpirationTime = _child.expirationTime;
          var _childChildExpirationTime = _child.childExpirationTime;
          if (newChildExpirationTime === NoWork || _childUpdateExpirationTime !== NoWork && _childUpdateExpirationTime < newChildExpirationTime) {
            newChildExpirationTime = _childUpdateExpirationTime;
          }
          if (newChildExpirationTime === NoWork || _childChildExpirationTime !== NoWork && _childChildExpirationTime < newChildExpirationTime) {
            newChildExpirationTime = _childChildExpirationTime;
          }
          _child = _child.sibling;
        }
      }

      workInProgress.childExpirationTime = newChildExpirationTime;
    }

    function completeUnitOfWork(workInProgress) {
      while (true) {
        var current$$1 = workInProgress.alternate;
        {
          setCurrentFiber(workInProgress);
        }

        var returnFiber = workInProgress.return;
        var siblingFiber = workInProgress.sibling;

        if ((workInProgress.effectTag & Incomplete) === NoEffect) {
          if (enableProfilerTimer) {
            if (workInProgress.mode & ProfileMode) {
              startProfilerTimer(workInProgress);
            }

            nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);

            if (workInProgress.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
            }
          } else {
            nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);
          }
          stopWorkTimer(workInProgress);
          resetChildExpirationTime(workInProgress, nextRenderExpirationTime);
          {
            resetCurrentFiber();
          }

          if (returnFiber !== null && (returnFiber.effectTag & Incomplete) === NoEffect) {
            if (returnFiber.firstEffect === null) {
              returnFiber.firstEffect = workInProgress.firstEffect;
            }
            if (workInProgress.lastEffect !== null) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
              }
              returnFiber.lastEffect = workInProgress.lastEffect;
            }

            var effectTag = workInProgress.effectTag;

            if (effectTag > PerformedWork) {
              if (returnFiber.lastEffect !== null) {
                returnFiber.lastEffect.nextEffect = workInProgress;
              } else {
                returnFiber.firstEffect = workInProgress;
              }
              returnFiber.lastEffect = workInProgress;
            }
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }

          if (siblingFiber !== null) {
            return siblingFiber;
          } else if (returnFiber !== null) {
            workInProgress = returnFiber;
            continue;
          } else {
            return null;
          }
        } else {
          if (workInProgress.mode & ProfileMode) {
            stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);
          }

          var next = unwindWork(workInProgress, nextRenderExpirationTime);

          if (workInProgress.effectTag & DidCapture) {
            stopFailedWorkTimer(workInProgress);
          } else {
            stopWorkTimer(workInProgress);
          }

          {
            resetCurrentFiber();
          }

          if (next !== null) {
            stopWorkTimer(workInProgress);
            if (true && ReactFiberInstrumentation_1.debugTool) {
              ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
            }

            if (enableProfilerTimer) {
              if (next.mode & ProfileMode) {
                var actualDuration = next.actualDuration;
                var child = next.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                next.actualDuration = actualDuration;
              }
            }

            next.effectTag &= HostEffectMask;
            return next;
          }

          if (returnFiber !== null) {
            returnFiber.firstEffect = returnFiber.lastEffect = null;
            returnFiber.effectTag |= Incomplete;
          }

          if (true && ReactFiberInstrumentation_1.debugTool) {
            ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
          }

          if (siblingFiber !== null) {
            return siblingFiber;
          } else if (returnFiber !== null) {
            workInProgress = returnFiber;
            continue;
          } else {
            return null;
          }
        }
      }

      return null;
    }

    function performUnitOfWork(workInProgress) {
      var current$$1 = workInProgress.alternate;

      startWorkTimer(workInProgress);
      {
        setCurrentFiber(workInProgress);
      }

      if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
        stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);
      }

      var next = void 0;
      if (enableProfilerTimer) {
        if (workInProgress.mode & ProfileMode) {
          startProfilerTimer(workInProgress);
        }

        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);

        if (workInProgress.mode & ProfileMode) {
          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);
        }
      } else {
        next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);
      }

      {
        resetCurrentFiber();
        if (isReplayingFailedUnitOfWork) {
          rethrowOriginalError();
        }
      }
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
      }

      if (next === null) {
        next = completeUnitOfWork(workInProgress);
      }

      ReactCurrentOwner$2.current = null;

      return next;
    }

    function workLoop(isYieldy) {
      if (!isYieldy) {
        while (nextUnitOfWork !== null) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      } else {
        while (nextUnitOfWork !== null && !shouldYield()) {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }

    function renderRoot(root, isYieldy, isExpired) {
      invariant(!isWorking, "renderRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");
      isWorking = true;
      ReactCurrentOwner$2.currentDispatcher = Dispatcher;

      var expirationTime = root.nextExpirationTimeToWorkOn;

      if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {
        resetStack();
        nextRoot = root;
        nextRenderExpirationTime = expirationTime;
        nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);
        root.pendingCommitExpirationTime = NoWork;

        if (enableSchedulerTracing) {
          var interactions = new Set();
          root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {
            if (scheduledExpirationTime <= expirationTime) {
              scheduledInteractions.forEach(function (interaction) {
                return interactions.add(interaction);
              });
            }
          });

          root.memoizedInteractions = interactions;

          if (interactions.size > 0) {
            var subscriber = tracing.__subscriberRef.current;
            if (subscriber !== null) {
              var threadID = computeThreadID(expirationTime, root.interactionThreadID);
              try {
                subscriber.onWorkStarted(interactions, threadID);
              } catch (error) {
                if (!hasUnhandledError) {
                  hasUnhandledError = true;
                  unhandledError = error;
                }
              }
            }
          }
        }
      }

      var prevInteractions = null;
      if (enableSchedulerTracing) {
        prevInteractions = tracing.__interactionsRef.current;
        tracing.__interactionsRef.current = root.memoizedInteractions;
      }

      var didFatal = false;

      startWorkLoopTimer(nextUnitOfWork);

      do {
        try {
          workLoop(isYieldy);
        } catch (thrownValue) {
          if (nextUnitOfWork === null) {
            didFatal = true;
            onUncaughtError(thrownValue);
          } else {
            {
              resetCurrentlyProcessingQueue();
            }

            var failedUnitOfWork = nextUnitOfWork;
            if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {
              replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
            }

            invariant(nextUnitOfWork !== null, "Failed to replay rendering after an error. This " + "is likely caused by a bug in React. Please file an issue " + "with a reproducing case to help us find it.");

            var sourceFiber = nextUnitOfWork;
            var returnFiber = sourceFiber.return;
            if (returnFiber === null) {
              didFatal = true;
              onUncaughtError(thrownValue);
            } else {
              throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);
              nextUnitOfWork = completeUnitOfWork(sourceFiber);
              continue;
            }
          }
        }
        break;
      } while (true);

      if (enableSchedulerTracing) {
        tracing.__interactionsRef.current = prevInteractions;
      }

      isWorking = false;
      ReactCurrentOwner$2.currentDispatcher = null;
      resetContextDependences();

      if (didFatal) {
        var _didCompleteRoot = false;
        stopWorkLoopTimer(interruptedBy, _didCompleteRoot);
        interruptedBy = null;

        {
          resetStackAfterFatalErrorInDev();
        }

        nextRoot = null;
        onFatal(root);
        return;
      }

      if (nextUnitOfWork !== null) {
        var _didCompleteRoot2 = false;
        stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);
        interruptedBy = null;
        onYield(root);
        return;
      }

      var didCompleteRoot = true;
      stopWorkLoopTimer(interruptedBy, didCompleteRoot);
      var rootWorkInProgress = root.current.alternate;
      invariant(rootWorkInProgress !== null, "Finished root should have a work-in-progress. This error is likely " + "caused by a bug in React. Please file an issue.");

      nextRoot = null;
      interruptedBy = null;

      if (nextRenderDidError) {
        if (hasLowerPriorityWork(root, expirationTime)) {
          markSuspendedPriorityLevel(root, expirationTime);
          var suspendedExpirationTime = expirationTime;
          var rootExpirationTime = root.expirationTime;
          onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1);
          return;
        } else if (!root.didError && !isExpired) {
          root.didError = true;
          var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;
          var _rootExpirationTime = root.expirationTime = Sync;
          onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1);
          return;
        }
      }

      if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {
        var _suspendedExpirationTime2 = expirationTime;
        markSuspendedPriorityLevel(root, _suspendedExpirationTime2);

        var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);
        var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);
        if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {
          nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;
        }

        var currentTimeMs = expirationTimeToMs(requestCurrentTime());
        var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;
        msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;

        var _rootExpirationTime2 = root.expirationTime;
        onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);
        return;
      }

      onComplete(root, rootWorkInProgress, expirationTime);
    }

    function dispatch(sourceFiber, value, expirationTime) {
      invariant(!isWorking || isCommitting$1, "dispatch: Cannot dispatch during the render phase.");

      var fiber = sourceFiber.return;
      while (fiber !== null) {
        switch (fiber.tag) {
          case ClassComponent:
          case ClassComponentLazy:
            var ctor = fiber.type;
            var instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValue(value, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);
              enqueueUpdate(fiber, update);
              scheduleWork(fiber, expirationTime);
              return;
            }
            break;
          case HostRoot:
            {
              var _errorInfo = createCapturedValue(value, sourceFiber);
              var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);
              enqueueUpdate(fiber, _update);
              scheduleWork(fiber, expirationTime);
              return;
            }
        }
        fiber = fiber.return;
      }

      if (sourceFiber.tag === HostRoot) {
        var rootFiber = sourceFiber;
        var _errorInfo2 = createCapturedValue(value, rootFiber);
        var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);
        enqueueUpdate(rootFiber, _update2);
        scheduleWork(rootFiber, expirationTime);
      }
    }

    function captureCommitPhaseError(fiber, error) {
      return dispatch(fiber, error, Sync);
    }

    function computeThreadID(expirationTime, interactionThreadID) {
      return expirationTime * 1000 + interactionThreadID;
    }

    function computeExpirationForFiber(currentTime, fiber) {
      var expirationTime = void 0;
      if (expirationContext !== NoWork) {
        expirationTime = expirationContext;
      } else if (isWorking) {
        if (isCommitting$1) {
          expirationTime = Sync;
        } else {
          expirationTime = nextRenderExpirationTime;
        }
      } else {
        if (fiber.mode & ConcurrentMode) {
          if (isBatchingInteractiveUpdates) {
            expirationTime = computeInteractiveExpiration(currentTime);
          } else {
            expirationTime = computeAsyncExpiration(currentTime);
          }

          if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
            expirationTime += 1;
          }
        } else {
          expirationTime = Sync;
        }
      }
      if (isBatchingInteractiveUpdates) {
        if (expirationTime > lowestPriorityPendingInteractiveExpirationTime) {
          lowestPriorityPendingInteractiveExpirationTime = expirationTime;
        }
      }
      return expirationTime;
    }

    function renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {
      if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {
        nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;
      }
    }

    function renderDidError() {
      nextRenderDidError = true;
    }

    function retrySuspendedRoot(root, fiber, suspendedTime) {
      if (enableSuspense) {
        var retryTime = void 0;

        if (isPriorityLevelSuspended(root, suspendedTime)) {
          retryTime = suspendedTime;

          markPingedPriorityLevel(root, retryTime);
        } else {
          var currentTime = requestCurrentTime();
          retryTime = computeExpirationForFiber(currentTime, fiber);
          markPendingPriorityLevel(root, retryTime);
        }

        if ((fiber.mode & ConcurrentMode) !== NoContext) {
          if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
            nextRoot = null;
          }
        }

        scheduleWorkToRoot(fiber, retryTime);
        var rootExpirationTime = root.expirationTime;
        if (rootExpirationTime !== NoWork) {
          requestWork(root, rootExpirationTime);
        }
      }
    }

    function scheduleWorkToRoot(fiber, expirationTime) {
      recordScheduleUpdate();

      {
        if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {
          var instance = fiber.stateNode;
          warnAboutInvalidUpdates(instance);
        }
      }

      if (fiber.expirationTime === NoWork || fiber.expirationTime > expirationTime) {
        fiber.expirationTime = expirationTime;
      }
      var alternate = fiber.alternate;
      if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > expirationTime)) {
        alternate.expirationTime = expirationTime;
      }

      var node = fiber.return;
      var root = null;
      if (node === null && fiber.tag === HostRoot) {
        root = fiber.stateNode;
      } else {
        while (node !== null) {
          alternate = node.alternate;
          if (node.childExpirationTime === NoWork || node.childExpirationTime > expirationTime) {
            node.childExpirationTime = expirationTime;
            if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {
              alternate.childExpirationTime = expirationTime;
            }
          } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {
            alternate.childExpirationTime = expirationTime;
          }
          if (node.return === null && node.tag === HostRoot) {
            root = node.stateNode;
            break;
          }
          node = node.return;
        }
      }

      if (root === null) {
        if (true && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) {
          warnAboutUpdateOnUnmounted(fiber);
        }
        return null;
      }

      if (enableSchedulerTracing) {
        var interactions = tracing.__interactionsRef.current;
        if (interactions.size > 0) {
          var pendingInteractionMap = root.pendingInteractionMap;
          var pendingInteractions = pendingInteractionMap.get(expirationTime);
          if (pendingInteractions != null) {
            interactions.forEach(function (interaction) {
              if (!pendingInteractions.has(interaction)) {
                interaction.__count++;
              }

              pendingInteractions.add(interaction);
            });
          } else {
            pendingInteractionMap.set(expirationTime, new Set(interactions));

            interactions.forEach(function (interaction) {
              interaction.__count++;
            });
          }

          var subscriber = tracing.__subscriberRef.current;
          if (subscriber !== null) {
            var threadID = computeThreadID(expirationTime, root.interactionThreadID);
            subscriber.onWorkScheduled(interactions, threadID);
          }
        }
      }

      return root;
    }

    function scheduleWork(fiber, expirationTime) {
      var root = scheduleWorkToRoot(fiber, expirationTime);
      if (root === null) {
        return;
      }

      if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {
        interruptedBy = fiber;
        resetStack();
      }
      markPendingPriorityLevel(root, expirationTime);
      if (!isWorking || isCommitting$1 || nextRoot !== root) {
        var rootExpirationTime = root.expirationTime;
        requestWork(root, rootExpirationTime);
      }
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
        nestedUpdateCount = 0;
        invariant(false, "Maximum update depth exceeded. This can happen when a " + "component repeatedly calls setState inside " + "componentWillUpdate or componentDidUpdate. React limits " + "the number of nested updates to prevent infinite loops.");
      }
    }

    var firstScheduledRoot = null;
    var lastScheduledRoot = null;

    var callbackExpirationTime = NoWork;
    var callbackID = void 0;
    var isRendering = false;
    var nextFlushedRoot = null;
    var nextFlushedExpirationTime = NoWork;
    var lowestPriorityPendingInteractiveExpirationTime = NoWork;
    var deadlineDidExpire = false;
    var hasUnhandledError = false;
    var unhandledError = null;
    var deadline = null;

    var isBatchingUpdates = false;
    var isUnbatchingUpdates = false;
    var isBatchingInteractiveUpdates = false;

    var completedBatches = null;

    var originalStartTimeMs = now();
    var currentRendererTime = msToExpirationTime(originalStartTimeMs);
    var currentSchedulerTime = currentRendererTime;

    var NESTED_UPDATE_LIMIT = 50;
    var nestedUpdateCount = 0;
    var lastCommittedRootDuringThisBatch = null;

    var timeHeuristicForUnitOfWork = 1;

    function recomputeCurrentRendererTime() {
      var currentTimeMs = now() - originalStartTimeMs;
      currentRendererTime = msToExpirationTime(currentTimeMs);
    }

    function scheduleCallbackWithExpirationTime(root, expirationTime) {
      if (callbackExpirationTime !== NoWork) {
        if (expirationTime > callbackExpirationTime) {
          return;
        } else {
          if (callbackID !== null) {
            cancelDeferredCallback(callbackID);
          }
        }
      } else {
        startRequestCallbackTimer();
      }

      callbackExpirationTime = expirationTime;
      var currentMs = now() - originalStartTimeMs;
      var expirationTimeMs = expirationTimeToMs(expirationTime);
      var timeout = expirationTimeMs - currentMs;
      callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
    }

    function onFatal(root) {
      root.finishedWork = null;
    }

    function onComplete(root, finishedWork, expirationTime) {
      root.pendingCommitExpirationTime = expirationTime;
      root.finishedWork = finishedWork;
    }

    function onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {
      root.expirationTime = rootExpirationTime;
      if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;
      } else if (msUntilTimeout > 0) {
        root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);
      }
    }

    function onYield(root) {
      root.finishedWork = null;
    }

    function onTimeout(root, finishedWork, suspendedExpirationTime) {
      if (enableSuspense) {
        root.pendingCommitExpirationTime = suspendedExpirationTime;
        root.finishedWork = finishedWork;

        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        flushRoot(root, suspendedExpirationTime);
      }
    }

    function onCommit(root, expirationTime) {
      root.expirationTime = expirationTime;
      root.finishedWork = null;
    }

    function requestCurrentTime() {

      if (isRendering) {
        return currentSchedulerTime;
      }

      findHighestPriorityRoot();
      if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;
        return currentSchedulerTime;
      }

      return currentSchedulerTime;
    }

    function requestWork(root, expirationTime) {
      addRootToSchedule(root, expirationTime);
      if (isRendering) {
        return;
      }

      if (isBatchingUpdates) {
        if (isUnbatchingUpdates) {
          nextFlushedRoot = root;
          nextFlushedExpirationTime = Sync;
          performWorkOnRoot(root, Sync, true);
        }
        return;
      }

      if (expirationTime === Sync) {
        performSyncWork();
      } else {
        scheduleCallbackWithExpirationTime(root, expirationTime);
      }
    }

    function addRootToSchedule(root, expirationTime) {
      if (root.nextScheduledRoot === null) {
        root.expirationTime = expirationTime;
        if (lastScheduledRoot === null) {
          firstScheduledRoot = lastScheduledRoot = root;
          root.nextScheduledRoot = root;
        } else {
          lastScheduledRoot.nextScheduledRoot = root;
          lastScheduledRoot = root;
          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
        }
      } else {
        var remainingExpirationTime = root.expirationTime;
        if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
          root.expirationTime = expirationTime;
        }
      }
    }

    function findHighestPriorityRoot() {
      var highestPriorityWork = NoWork;
      var highestPriorityRoot = null;
      if (lastScheduledRoot !== null) {
        var previousScheduledRoot = lastScheduledRoot;
        var root = firstScheduledRoot;
        while (root !== null) {
          var remainingExpirationTime = root.expirationTime;
          if (remainingExpirationTime === NoWork) {
            invariant(previousScheduledRoot !== null && lastScheduledRoot !== null, "Should have a previous and last root. This error is likely " + "caused by a bug in React. Please file an issue.");
            if (root === root.nextScheduledRoot) {
              root.nextScheduledRoot = null;
              firstScheduledRoot = lastScheduledRoot = null;
              break;
            } else if (root === firstScheduledRoot) {
              var next = root.nextScheduledRoot;
              firstScheduledRoot = next;
              lastScheduledRoot.nextScheduledRoot = next;
              root.nextScheduledRoot = null;
            } else if (root === lastScheduledRoot) {
              lastScheduledRoot = previousScheduledRoot;
              lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
              root.nextScheduledRoot = null;
              break;
            } else {
              previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
              root.nextScheduledRoot = null;
            }
            root = previousScheduledRoot.nextScheduledRoot;
          } else {
            if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
              highestPriorityWork = remainingExpirationTime;
              highestPriorityRoot = root;
            }
            if (root === lastScheduledRoot) {
              break;
            }
            if (highestPriorityWork === Sync) {
              break;
            }
            previousScheduledRoot = root;
            root = root.nextScheduledRoot;
          }
        }
      }

      nextFlushedRoot = highestPriorityRoot;
      nextFlushedExpirationTime = highestPriorityWork;
    }

    function performAsyncWork(dl) {
      if (dl.didTimeout) {
        if (firstScheduledRoot !== null) {
          recomputeCurrentRendererTime();
          var root = firstScheduledRoot;
          do {
            didExpireAtExpirationTime(root, currentRendererTime);

            root = root.nextScheduledRoot;
          } while (root !== firstScheduledRoot);
        }
      }
      performWork(NoWork, dl);
    }

    function performSyncWork() {
      performWork(Sync, null);
    }

    function performWork(minExpirationTime, dl) {
      deadline = dl;

      findHighestPriorityRoot();

      if (deadline !== null) {
        recomputeCurrentRendererTime();
        currentSchedulerTime = currentRendererTime;

        if (enableUserTimingAPI) {
          var didExpire = nextFlushedExpirationTime < currentRendererTime;
          var timeout = expirationTimeToMs(nextFlushedExpirationTime);
          stopRequestCallbackTimer(didExpire, timeout);
        }

        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)) {
          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime >= nextFlushedExpirationTime);
          findHighestPriorityRoot();
          recomputeCurrentRendererTime();
          currentSchedulerTime = currentRendererTime;
        }
      } else {
        while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {
          performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
          findHighestPriorityRoot();
        }
      }

      if (deadline !== null) {
        callbackExpirationTime = NoWork;
        callbackID = null;
      }

      if (nextFlushedExpirationTime !== NoWork) {
        scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);
      }

      deadline = null;
      deadlineDidExpire = false;

      finishRendering();
    }

    function flushRoot(root, expirationTime) {
      invariant(!isRendering, "work.commit(): Cannot commit while already rendering. This likely " + "means you attempted to commit from inside a lifecycle method.");

      nextFlushedRoot = root;
      nextFlushedExpirationTime = expirationTime;
      performWorkOnRoot(root, expirationTime, true);

      performSyncWork();
    }

    function finishRendering() {
      nestedUpdateCount = 0;
      lastCommittedRootDuringThisBatch = null;

      if (completedBatches !== null) {
        var batches = completedBatches;
        completedBatches = null;
        for (var i = 0; i < batches.length; i++) {
          var batch = batches[i];
          try {
            batch._onComplete();
          } catch (error) {
            if (!hasUnhandledError) {
              hasUnhandledError = true;
              unhandledError = error;
            }
          }
        }
      }

      if (hasUnhandledError) {
        var error = unhandledError;
        unhandledError = null;
        hasUnhandledError = false;
        throw error;
      }
    }

    function performWorkOnRoot(root, expirationTime, isExpired) {
      invariant(!isRendering, "performWorkOnRoot was called recursively. This error is likely caused " + "by a bug in React. Please file an issue.");

      isRendering = true;

      if (deadline === null || isExpired) {

        var finishedWork = root.finishedWork;
        if (finishedWork !== null) {
          completeRoot(root, finishedWork, expirationTime);
        } else {
          root.finishedWork = null;

          var timeoutHandle = root.timeoutHandle;
          if (enableSuspense && timeoutHandle !== noTimeout) {
            root.timeoutHandle = noTimeout;

            cancelTimeout(timeoutHandle);
          }
          var isYieldy = false;
          renderRoot(root, isYieldy, isExpired);
          finishedWork = root.finishedWork;
          if (finishedWork !== null) {
            completeRoot(root, finishedWork, expirationTime);
          }
        }
      } else {
        var _finishedWork = root.finishedWork;
        if (_finishedWork !== null) {
          completeRoot(root, _finishedWork, expirationTime);
        } else {
          root.finishedWork = null;

          var _timeoutHandle = root.timeoutHandle;
          if (enableSuspense && _timeoutHandle !== noTimeout) {
            root.timeoutHandle = noTimeout;

            cancelTimeout(_timeoutHandle);
          }
          var _isYieldy = true;
          renderRoot(root, _isYieldy, isExpired);
          _finishedWork = root.finishedWork;
          if (_finishedWork !== null) {
            if (!shouldYield()) {
              completeRoot(root, _finishedWork, expirationTime);
            } else {
              root.finishedWork = _finishedWork;
            }
          }
        }
      }

      isRendering = false;
    }

    function completeRoot(root, finishedWork, expirationTime) {
      var firstBatch = root.firstBatch;
      if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {
        if (completedBatches === null) {
          completedBatches = [firstBatch];
        } else {
          completedBatches.push(firstBatch);
        }
        if (firstBatch._defer) {
          root.finishedWork = finishedWork;
          root.expirationTime = NoWork;
          return;
        }
      }

      root.finishedWork = null;

      if (root === lastCommittedRootDuringThisBatch) {
        nestedUpdateCount++;
      } else {
        lastCommittedRootDuringThisBatch = root;
        nestedUpdateCount = 0;
      }
      commitRoot(root, finishedWork);
    }

    function shouldYield() {
      if (deadlineDidExpire) {
        return true;
      }
      if (deadline === null || deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
        return false;
      }
      deadlineDidExpire = true;
      return true;
    }

    function onUncaughtError(error) {
      invariant(nextFlushedRoot !== null, "Should be working on a root. This error is likely caused by a bug in " + "React. Please file an issue.");

      nextFlushedRoot.expirationTime = NoWork;
      if (!hasUnhandledError) {
        hasUnhandledError = true;
        unhandledError = error;
      }
    }

    function batchedUpdates$1(fn, a) {
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingUpdates = true;
      try {
        return fn(a);
      } finally {
        isBatchingUpdates = previousIsBatchingUpdates;
        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }
    }

    function interactiveUpdates$1(fn, a, b) {
      if (isBatchingInteractiveUpdates) {
        return fn(a, b);
      }

      if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
        performWork(lowestPriorityPendingInteractiveExpirationTime, null);
        lowestPriorityPendingInteractiveExpirationTime = NoWork;
      }
      var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;
      var previousIsBatchingUpdates = isBatchingUpdates;
      isBatchingInteractiveUpdates = true;
      isBatchingUpdates = true;
      try {
        return fn(a, b);
      } finally {
        isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
        isBatchingUpdates = previousIsBatchingUpdates;
        if (!isBatchingUpdates && !isRendering) {
          performSyncWork();
        }
      }
    }

    function flushInteractiveUpdates$1() {
      if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {
        performWork(lowestPriorityPendingInteractiveExpirationTime, null);
        lowestPriorityPendingInteractiveExpirationTime = NoWork;
      }
    }

    var didWarnAboutNestedUpdates = void 0;

    {
      didWarnAboutNestedUpdates = false;
    }

    function getContextForSubtree(parentComponent) {
      if (!parentComponent) {
        return emptyContextObject;
      }

      var fiber = get$1(parentComponent);
      var parentContext = findCurrentUnmaskedContext(fiber);

      if (fiber.tag === ClassComponent) {
        var Component = fiber.type;
        if (isContextProvider(Component)) {
          return processChildContext(fiber, Component, parentContext);
        }
      } else if (fiber.tag === ClassComponentLazy) {
        var _Component = getResultFromResolvedThenable(fiber.type);
        if (isContextProvider(_Component)) {
          return processChildContext(fiber, _Component, parentContext);
        }
      }

      return parentContext;
    }

    function scheduleRootUpdate(current$$1, element, expirationTime, callback) {
      {
        if (phase === "render" && current !== null && !didWarnAboutNestedUpdates) {
          didWarnAboutNestedUpdates = true;
          warningWithoutStack$1(false, "Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + "If necessary, trigger nested updates in componentDidUpdate.\n\n" + "Check the render method of %s.", getComponentName(current.type) || "Unknown");
        }
      }

      var update = createUpdate(expirationTime);

      update.payload = { element: element };

      callback = callback === undefined ? null : callback;
      if (callback !== null) {
        !(typeof callback === "function") ? warningWithoutStack$1(false, "render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback) : void 0;
        update.callback = callback;
      }
      enqueueUpdate(current$$1, update);

      scheduleWork(current$$1, expirationTime);
      return expirationTime;
    }

    function updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {
      var current$$1 = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current$$1.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      return scheduleRootUpdate(current$$1, element, expirationTime, callback);
    }

    function findHostInstance$1(component) {
      var fiber = get$1(component);
      if (fiber === undefined) {
        if (typeof component.render === "function") {
          invariant(false, "Unable to find node on an unmounted component.");
        } else {
          invariant(false, "Argument appears to not be a ReactComponent. Keys: %s", Object.keys(component));
        }
      }
      var hostFiber = findCurrentHostFiber(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    }

    function createContainer(containerInfo, isConcurrent, hydrate) {
      return createFiberRoot(containerInfo, isConcurrent, hydrate);
    }

    function updateContainer(element, container, parentComponent, callback) {
      var current$$1 = container.current;
      var currentTime = requestCurrentTime();
      var expirationTime = computeExpirationForFiber(currentTime, current$$1);
      return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);
    }

    function getPublicRootInstance(container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    }

    function injectIntoDevTools(devToolsConfig) {
      var _findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_extends({}, devToolsConfig, {
        findHostInstanceByFiber: function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        },
        findFiberByHostInstance: function findFiberByHostInstance(instance) {
          if (!_findFiberByHostInstance) {
            return null;
          }
          return _findFiberByHostInstance(instance);
        }
      }));
    }

    function _createPortal(children, containerInfo, implementation) {
      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children: children,
        containerInfo: containerInfo,
        implementation: implementation
      };
    }

    var ReactVersion = "16.5.2";

    var NativeMethodsMixin = function NativeMethodsMixin(findNodeHandle, findHostInstance) {
      var NativeMethodsMixin = {
        measure: function measure(callback) {
          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        },

        measureInWindow: function measureInWindow(callback) {
          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        },

        measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        },

        setNativeProps: function setNativeProps(nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}

          if (maybeInstance == null) {
            return;
          }

          var viewConfig = maybeInstance.viewConfig;

          {
            warnForStyleProps(nativeProps, viewConfig.validAttributes);
          }

          var updatePayload = create(nativeProps, viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          }
        },

        focus: function focus() {
          TextInputState.focusTextInput(findNodeHandle(this));
        },

        blur: function blur() {
          TextInputState.blurTextInput(findNodeHandle(this));
        }
      };

      {
        var NativeMethodsMixin_DEV = NativeMethodsMixin;
        invariant(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps && !NativeMethodsMixin_DEV.UNSAFE_componentWillMount && !NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps, "Do not override existing functions.");

        NativeMethodsMixin_DEV.componentWillMount = function () {
          throwOnStylesProp(this, this.props);
        };
        NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
          throwOnStylesProp(this, newProps);
        };
        NativeMethodsMixin_DEV.UNSAFE_componentWillMount = function () {
          throwOnStylesProp(this, this.props);
        };
        NativeMethodsMixin_DEV.UNSAFE_componentWillReceiveProps = function (newProps) {
          throwOnStylesProp(this, newProps);
        };

        NativeMethodsMixin_DEV.componentWillMount.__suppressDeprecationWarning = true;
        NativeMethodsMixin_DEV.componentWillReceiveProps.__suppressDeprecationWarning = true;
      }

      return NativeMethodsMixin;
    };

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _possibleConstructorReturn(self, call) {
      if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var ReactNativeComponent = function ReactNativeComponent(findNodeHandle, findHostInstance) {
      var ReactNativeComponent = function (_React$Component) {
        _inherits(ReactNativeComponent, _React$Component);

        function ReactNativeComponent() {
          _classCallCheck$1(this, ReactNativeComponent);

          return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
        }

        ReactNativeComponent.prototype.blur = function blur() {
          TextInputState.blurTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.focus = function focus() {
          TextInputState.focusTextInput(findNodeHandle(this));
        };

        ReactNativeComponent.prototype.measure = function measure(callback) {
          UIManager.measure(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureInWindow = function measureInWindow(callback) {
          UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback_NOT_REALLY_SAFE(this, callback));
        };

        ReactNativeComponent.prototype.measureLayout = function measureLayout(relativeToNativeNode, onSuccess, onFail) {
          UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback_NOT_REALLY_SAFE(this, onFail), mountSafeCallback_NOT_REALLY_SAFE(this, onSuccess));
        };

        ReactNativeComponent.prototype.setNativeProps = function setNativeProps(nativeProps) {
          var maybeInstance = void 0;

          try {
            maybeInstance = findHostInstance(this);
          } catch (error) {}

          if (maybeInstance == null) {
            return;
          }

          var viewConfig = maybeInstance.viewConfig || maybeInstance.canonical.viewConfig;

          var updatePayload = create(nativeProps, viewConfig.validAttributes);

          if (updatePayload != null) {
            UIManager.updateView(maybeInstance._nativeTag, viewConfig.uiViewClassName, updatePayload);
          }
        };

        return ReactNativeComponent;
      }(React.Component);

      return ReactNativeComponent;
    };

    var emptyObject$2 = {};
    {
      Object.freeze(emptyObject$2);
    }

    var getInspectorDataForViewTag = void 0;

    {
      var traverseOwnerTreeUp = function traverseOwnerTreeUp(hierarchy, instance) {
        if (instance) {
          hierarchy.unshift(instance);
          traverseOwnerTreeUp(hierarchy, instance._debugOwner);
        }
      };

      var getOwnerHierarchy = function getOwnerHierarchy(instance) {
        var hierarchy = [];
        traverseOwnerTreeUp(hierarchy, instance);
        return hierarchy;
      };

      var lastNonHostInstance = function lastNonHostInstance(hierarchy) {
        for (var i = hierarchy.length - 1; i > 1; i--) {
          var instance = hierarchy[i];

          if (instance.tag !== HostComponent) {
            return instance;
          }
        }
        return hierarchy[0];
      };

      var getHostProps = function getHostProps(fiber) {
        var host = findCurrentHostFiber(fiber);
        if (host) {
          return host.memoizedProps || emptyObject$2;
        }
        return emptyObject$2;
      };

      var getHostNode = function getHostNode(fiber, findNodeHandle) {
        var hostNode = void 0;

        while (fiber) {
          if (fiber.stateNode !== null && fiber.tag === HostComponent) {
            hostNode = findNodeHandle(fiber.stateNode);
          }
          if (hostNode) {
            return hostNode;
          }
          fiber = fiber.child;
        }
        return null;
      };

      var createHierarchy = function createHierarchy(fiberHierarchy) {
        return fiberHierarchy.map(function (fiber) {
          return {
            name: getComponentName(fiber.type),
            getInspectorData: function getInspectorData(findNodeHandle) {
              return {
                measure: function measure(callback) {
                  return UIManager.measure(getHostNode(fiber, findNodeHandle), callback);
                },
                props: getHostProps(fiber),
                source: fiber._debugSource
              };
            }
          };
        });
      };

      getInspectorDataForViewTag = function getInspectorDataForViewTag(viewTag) {
        var closestInstance = getInstanceFromTag(viewTag);

        if (!closestInstance) {
          return {
            hierarchy: [],
            props: emptyObject$2,
            selection: null,
            source: null
          };
        }

        var fiber = findCurrentFiberUsingSlowPath(closestInstance);
        var fiberHierarchy = getOwnerHierarchy(fiber);
        var instance = lastNonHostInstance(fiberHierarchy);
        var hierarchy = createHierarchy(fiberHierarchy);
        var props = getHostProps(instance);
        var source = instance._debugSource;
        var selection = fiberHierarchy.indexOf(instance);

        return {
          hierarchy: hierarchy,
          props: props,
          selection: selection,
          source: source
        };
      };
    }

    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    var findHostInstance = findHostInstance$1;

    function findNodeHandle(componentOrHandle) {
      {
        var owner = ReactCurrentOwner.current;
        if (owner !== null && owner.stateNode !== null) {
          !owner.stateNode._warnedAboutRefsInRender ? warningWithoutStack$1(false, "%s is accessing findNodeHandle inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentName(owner.type) || "A component") : void 0;

          owner.stateNode._warnedAboutRefsInRender = true;
        }
      }
      if (componentOrHandle == null) {
        return null;
      }
      if (typeof componentOrHandle === "number") {
        return componentOrHandle;
      }
      if (componentOrHandle._nativeTag) {
        return componentOrHandle._nativeTag;
      }
      if (componentOrHandle.canonical && componentOrHandle.canonical._nativeTag) {
        return componentOrHandle.canonical._nativeTag;
      }
      var hostInstance = findHostInstance(componentOrHandle);
      if (hostInstance == null) {
        return hostInstance;
      }
      if (hostInstance.canonical) {
        return hostInstance.canonical._nativeTag;
      }
      return hostInstance._nativeTag;
    }

    setBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);

    function computeComponentStackForErrorReporting(reactTag) {
      var fiber = getInstanceFromTag(reactTag);
      if (!fiber) {
        return "";
      }
      return getStackByFiberInDevAndProd(fiber);
    }

    var roots = new Map();

    var ReactNativeRenderer = {
      NativeComponent: ReactNativeComponent(findNodeHandle, findHostInstance),

      findNodeHandle: findNodeHandle,

      render: function render(element, containerTag, callback) {
        var root = roots.get(containerTag);

        if (!root) {
          root = createContainer(containerTag, false, false);
          roots.set(containerTag, root);
        }
        updateContainer(element, root, null, callback);

        return getPublicRootInstance(root);
      },
      unmountComponentAtNode: function unmountComponentAtNode(containerTag) {
        var root = roots.get(containerTag);
        if (root) {
          updateContainer(null, root, null, function () {
            roots.delete(containerTag);
          });
        }
      },
      unmountComponentAtNodeAndRemoveContainer: function unmountComponentAtNodeAndRemoveContainer(containerTag) {
        ReactNativeRenderer.unmountComponentAtNode(containerTag);

        UIManager.removeRootView(containerTag);
      },
      createPortal: function createPortal(children, containerTag) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        return _createPortal(children, containerTag, null, key);
      },

      unstable_batchedUpdates: batchedUpdates,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        NativeMethodsMixin: NativeMethodsMixin(findNodeHandle, findHostInstance),
        computeComponentStackForErrorReporting: computeComponentStackForErrorReporting
      }
    };

    injectIntoDevTools({
      findFiberByHostInstance: getInstanceFromTag,
      getInspectorDataForViewTag: getInspectorDataForViewTag,
      bundleType: 1,
      version: ReactVersion,
      rendererPackageName: "react-native-renderer"
    });

    var ReactNativeRenderer$2 = Object.freeze({
      default: ReactNativeRenderer
    });

    var ReactNativeRenderer$3 = ReactNativeRenderer$2 && ReactNativeRenderer || ReactNativeRenderer$2;

    var reactNativeRenderer = ReactNativeRenderer$3.default || ReactNativeRenderer$3;

    module.exports = reactNativeRenderer;
  })();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlJlYWN0TmF0aXZlUmVuZGVyZXItZGV2LmpzIl0sIm5hbWVzIjpbIl9fREVWX18iLCJyZXF1aXJlIiwiUmVhY3ROYXRpdmVWaWV3Q29uZmlnUmVnaXN0cnkiLCJVSU1hbmFnZXIiLCJSQ1RFdmVudEVtaXR0ZXIiLCJSZWFjdCIsImRlZXBGcmVlemVBbmRUaHJvd09uTXV0YXRpb25JbkRldiIsImRlZXBEaWZmZXIiLCJmbGF0dGVuU3R5bGUiLCJUZXh0SW5wdXRTdGF0ZSIsImNoZWNrUHJvcFR5cGVzIiwidHJhY2luZyIsIkV4Y2VwdGlvbnNNYW5hZ2VyIiwidmFsaWRhdGVGb3JtYXQiLCJmb3JtYXQiLCJ1bmRlZmluZWQiLCJFcnJvciIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImVycm9yIiwiYXJncyIsImFyZ0luZGV4IiwicmVwbGFjZSIsIm5hbWUiLCJmcmFtZXNUb1BvcCIsImludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwiLCJmdW5jIiwiY29udGV4dCIsImZ1bmNBcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJhcHBseSIsIm9uRXJyb3IiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFdmVudCIsImZha2VOb2RlIiwiY3JlYXRlRWxlbWVudCIsImludm9rZUd1YXJkZWRDYWxsYmFja0RldiIsImV2dCIsImRpZEVycm9yIiwid2luZG93RXZlbnQiLCJldmVudCIsIndpbmRvd0V2ZW50RGVzY3JpcHRvciIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNhbGxDYWxsYmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldnRUeXBlIiwiaGFzT3duUHJvcGVydHkiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJkZWZhdWx0UHJldmVudGVkIiwiX3N1cHByZXNzTG9nZ2luZyIsImlubmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImluaXRFdmVudCIsImRlZmluZVByb3BlcnR5IiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxIiwiaGFzRXJyb3IiLCJjYXVnaHRFcnJvciIsImhhc1JldGhyb3dFcnJvciIsInJldGhyb3dFcnJvciIsInJlcG9ydGVyIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsImhhc0NhdWdodEVycm9yIiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJpbmRleE9mIiwicGx1Z2lucyIsImV4dHJhY3RFdmVudHMiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudFR5cGVzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZGlzcGF0Y2hDb25maWciLCJldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJyZWdpc3RyYXRpb25OYW1lTW9kdWxlcyIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJsb3dlckNhc2VkTmFtZSIsInRvTG93ZXJDYXNlIiwiaW5qZWN0RXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJ3YXJuaW5nV2l0aG91dFN0YWNrIiwiX2xlbiIsImxlbmd0aCIsIl9rZXkiLCJjb25zb2xlIiwiX2FyZ3MkbWFwIiwibWFwIiwiaXRlbSIsImciLCJoIiwibWVzc2FnZSIsIl9tZXNzYWdlIiwieCIsIndhcm5pbmdXaXRob3V0U3RhY2skMSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSIsInNldENvbXBvbmVudFRyZWUiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbCIsImdldEluc3RhbmNlRnJvbU5vZGVJbXBsIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGwiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiX2Rpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImlzQXJyYXkiLCJsaXN0ZW5lcnNMZW4iLCJpbnN0YW5jZXNJc0FyciIsImluc3RhbmNlc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsInNpbXVsYXRlZCIsImxpc3RlbmVyIiwiaW5zdCIsInR5cGUiLCJjdXJyZW50VGFyZ2V0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlIiwicmV0IiwiZXhlY3V0ZURpcmVjdERpc3BhdGNoIiwiZGlzcGF0Y2hMaXN0ZW5lciIsImRpc3BhdGNoSW5zdGFuY2UiLCJyZXMiLCJoYXNEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZUludG8iLCJjdXJyZW50IiwibmV4dCIsInB1c2giLCJjb25jYXQiLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJjYiIsInNjb3BlIiwiZm9yRWFjaCIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJpc1BlcnNpc3RlbnQiLCJjb25zdHJ1Y3RvciIsInJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJ0YWciLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsInByb3BzIiwiZGlzYWJsZWQiLCJpbmplY3Rpb24iLCJnZXRMaXN0ZW5lciIsInN0YXRlTm9kZSIsInRvcExldmVsVHlwZSIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJydW5FdmVudHNJbkJhdGNoIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoIiwiRnVuY3Rpb25Db21wb25lbnQiLCJGdW5jdGlvbkNvbXBvbmVudExhenkiLCJDbGFzc0NvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50TGF6eSIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiRm9yd2FyZFJlZkxhenkiLCJQcm9maWxlciIsIlBsYWNlaG9sZGVyQ29tcG9uZW50IiwiUHVyZUNvbXBvbmVudCIsIlB1cmVDb21wb25lbnRMYXp5IiwiZ2V0UGFyZW50IiwicmV0dXJuIiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiYWx0ZXJuYXRlIiwiaXNBbmNlc3RvciIsImdldFBhcmVudEluc3RhbmNlIiwidHJhdmVyc2VUd29QaGFzZSIsImZuIiwiYXJnIiwicGF0aCIsImxpc3RlbmVyQXRQaGFzZSIsInByb3BhZ2F0aW9uUGhhc2UiLCJhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzIiwicGhhc2UiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiX3RhcmdldEluc3QiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCIsInBhcmVudEluc3QiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiRVZFTlRfUE9PTF9TSVpFIiwiRXZlbnRJbnRlcmZhY2UiLCJ0YXJnZXQiLCJldmVudFBoYXNlIiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJ0aW1lU3RhbXAiLCJEYXRlIiwibm93IiwiaXNUcnVzdGVkIiwiZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUiLCJmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UiLCJTeW50aGV0aWNFdmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiSW50ZXJmYWNlIiwicHJvcE5hbWUiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJkZXN0cnVjdG9yIiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsImV4dGVuZCIsIlN1cGVyIiwiRSIsIkNsYXNzIiwiYWRkRXZlbnRQb29saW5nVG8iLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwiY29uZmlndXJhYmxlIiwic2V0IiwiZ2V0IiwiZ2V0JCQxIiwidmFsIiwiYWN0aW9uIiwid2FybiIsInJlc3VsdCIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwiZXZlbnRQb29sIiwiaW5zdGFuY2UiLCJwb3AiLCJyZWxlYXNlUG9vbGVkRXZlbnQiLCJnZXRQb29sZWQiLCJSZXNwb25kZXJTeW50aGV0aWNFdmVudCIsInRvdWNoSGlzdG9yeSIsIlRPUF9UT1VDSF9TVEFSVCIsIlRPUF9UT1VDSF9NT1ZFIiwiVE9QX1RPVUNIX0VORCIsIlRPUF9UT1VDSF9DQU5DRUwiLCJUT1BfU0NST0xMIiwiVE9QX1NFTEVDVElPTl9DSEFOR0UiLCJpc1N0YXJ0aXNoIiwiaXNNb3ZlaXNoIiwiaXNFbmRpc2giLCJzdGFydERlcGVuZGVuY2llcyIsIm1vdmVEZXBlbmRlbmNpZXMiLCJlbmREZXBlbmRlbmNpZXMiLCJNQVhfVE9VQ0hfQkFOSyIsInRvdWNoQmFuayIsIm51bWJlckFjdGl2ZVRvdWNoZXMiLCJpbmRleE9mU2luZ2xlQWN0aXZlVG91Y2giLCJtb3N0UmVjZW50VGltZVN0YW1wIiwidGltZXN0YW1wRm9yVG91Y2giLCJ0b3VjaCIsInRpbWVzdGFtcCIsImNyZWF0ZVRvdWNoUmVjb3JkIiwidG91Y2hBY3RpdmUiLCJzdGFydFBhZ2VYIiwicGFnZVgiLCJzdGFydFBhZ2VZIiwicGFnZVkiLCJzdGFydFRpbWVTdGFtcCIsImN1cnJlbnRQYWdlWCIsImN1cnJlbnRQYWdlWSIsImN1cnJlbnRUaW1lU3RhbXAiLCJwcmV2aW91c1BhZ2VYIiwicHJldmlvdXNQYWdlWSIsInByZXZpb3VzVGltZVN0YW1wIiwicmVzZXRUb3VjaFJlY29yZCIsInRvdWNoUmVjb3JkIiwiZ2V0VG91Y2hJZGVudGlmaWVyIiwiX3JlZiIsImlkZW50aWZpZXIiLCJyZWNvcmRUb3VjaFN0YXJ0IiwicmVjb3JkVG91Y2hNb3ZlIiwicHJpbnRUb3VjaCIsInByaW50VG91Y2hCYW5rIiwicmVjb3JkVG91Y2hFbmQiLCJKU09OIiwic3RyaW5naWZ5IiwicHJpbnRlZCIsIlJlc3BvbmRlclRvdWNoSGlzdG9yeVN0b3JlIiwicmVjb3JkVG91Y2hUcmFjayIsImNoYW5nZWRUb3VjaGVzIiwidG91Y2hlcyIsInRvdWNoVHJhY2tUb0NoZWNrIiwiYWN0aXZlUmVjb3JkIiwiYWNjdW11bGF0ZSIsInJlc3BvbmRlckluc3QiLCJ0cmFja2VkVG91Y2hDb3VudCIsImNoYW5nZVJlc3BvbmRlciIsIm5leHRSZXNwb25kZXJJbnN0IiwiYmxvY2tIb3N0UmVzcG9uZGVyIiwib2xkUmVzcG9uZGVySW5zdCIsIlJlc3BvbmRlckV2ZW50UGx1Z2luIiwiR2xvYmFsUmVzcG9uZGVySGFuZGxlciIsIm9uQ2hhbmdlIiwiZXZlbnRUeXBlcyQxIiwic3RhcnRTaG91bGRTZXRSZXNwb25kZXIiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJzY3JvbGxTaG91bGRTZXRSZXNwb25kZXIiLCJzZWxlY3Rpb25DaGFuZ2VTaG91bGRTZXRSZXNwb25kZXIiLCJtb3ZlU2hvdWxkU2V0UmVzcG9uZGVyIiwicmVzcG9uZGVyU3RhcnQiLCJyZXNwb25kZXJNb3ZlIiwicmVzcG9uZGVyRW5kIiwicmVzcG9uZGVyUmVsZWFzZSIsInJlc3BvbmRlclRlcm1pbmF0aW9uUmVxdWVzdCIsInJlc3BvbmRlckdyYW50IiwicmVzcG9uZGVyUmVqZWN0IiwicmVzcG9uZGVyVGVybWluYXRlIiwic2V0UmVzcG9uZGVyQW5kRXh0cmFjdFRyYW5zZmVyIiwic2hvdWxkU2V0RXZlbnRUeXBlIiwiYnViYmxlU2hvdWxkU2V0RnJvbSIsInNraXBPdmVyQnViYmxlU2hvdWxkU2V0RnJvbSIsInNob3VsZFNldEV2ZW50Iiwid2FudHNSZXNwb25kZXJJbnN0IiwiZXh0cmFjdGVkIiwiZ3JhbnRFdmVudCIsInRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50Iiwic2hvdWxkU3dpdGNoIiwidGVybWluYXRlRXZlbnQiLCJyZWplY3RFdmVudCIsImNhblRyaWdnZXJUcmFuc2ZlciIsInRvcExldmVsSW5zdCIsInJlc3BvbmRlcklnbm9yZVNjcm9sbCIsIm5vUmVzcG9uZGVyVG91Y2hlcyIsImFjdGl2ZVRvdWNoIiwiX2dldFJlc3BvbmRlciIsImlzUmVzcG9uZGVyVG91Y2hTdGFydCIsImlzUmVzcG9uZGVyVG91Y2hNb3ZlIiwiaXNSZXNwb25kZXJUb3VjaEVuZCIsImluY3JlbWVudGFsVG91Y2giLCJnZXN0dXJlIiwiaXNSZXNwb25kZXJUZXJtaW5hdGUiLCJpc1Jlc3BvbmRlclJlbGVhc2UiLCJmaW5hbFRvdWNoIiwiZmluYWxFdmVudCIsImluamVjdEdsb2JhbFJlc3BvbmRlckhhbmRsZXIiLCJjdXN0b21CdWJibGluZ0V2ZW50VHlwZXMkMSIsImN1c3RvbUJ1YmJsaW5nRXZlbnRUeXBlcyIsImN1c3RvbURpcmVjdEV2ZW50VHlwZXMkMSIsImN1c3RvbURpcmVjdEV2ZW50VHlwZXMiLCJldmVudFR5cGVzJDIiLCJSZWFjdE5hdGl2ZUJyaWRnZUV2ZW50UGx1Z2luIiwiYnViYmxlRGlzcGF0Y2hDb25maWciLCJkaXJlY3REaXNwYXRjaENvbmZpZyIsIlJlYWN0TmF0aXZlRXZlbnRQbHVnaW5PcmRlciIsImluc3RhbmNlQ2FjaGUiLCJpbnN0YW5jZVByb3BzIiwicHJlY2FjaGVGaWJlck5vZGUiLCJob3N0SW5zdCIsInVuY2FjaGVGaWJlck5vZGUiLCJnZXRJbnN0YW5jZUZyb21UYWciLCJnZXRUYWdGcm9tSW5zdGFuY2UiLCJfbmF0aXZlVGFnIiwiY2Fub25pY2FsIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyIsInJlc3RvcmVJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsIm5lZWRzU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJxdWV1ZWRUYXJnZXRzIiwiX2JhdGNoZWRVcGRhdGVzSW1wbCIsImJvb2trZWVwaW5nIiwiX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCIsImlzQmF0Y2hpbmciLCJiYXRjaGVkVXBkYXRlcyIsImNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzIiwic2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbiIsImJhdGNoZWRVcGRhdGVzSW1wbCIsImludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJmbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJFTVBUWV9OQVRJVkVfRVZFTlQiLCJ0b3VjaFN1YnNlcXVlbmNlIiwiaW5kaWNlcyIsInJlbW92ZVRvdWNoZXNBdEluZGljZXMiLCJyaXBwZWRPdXQiLCJ0ZW1wIiwiaW5kZXgiLCJmaWxsQXQiLCJqIiwiY3VyIiwiX3JlY2VpdmVSb290Tm9kZUlERXZlbnQiLCJyb290Tm9kZUlEIiwibmF0aXZlRXZlbnRQYXJhbSIsInJlY2VpdmVFdmVudCIsInJlY2VpdmVUb3VjaGVzIiwiZXZlbnRUb3BMZXZlbFR5cGUiLCJjaGFuZ2VkSW5kaWNlcyIsImpqIiwiUmVhY3ROYXRpdmVFdmVudEVtaXR0ZXIiLCJmcmVlemUiLCJyZWdpc3RyYXRpb25OYW1lcyIsIlJlYWN0TmF0aXZlR2xvYmFsUmVzcG9uZGVySGFuZGxlciIsImZyb20iLCJ0byIsImJsb2NrTmF0aXZlUmVzcG9uZGVyIiwic2V0SlNSZXNwb25kZXIiLCJjbGVhckpTUmVzcG9uZGVyIiwicmVnaXN0ZXIiLCJnZXQkMSIsImtleSIsIl9yZWFjdEludGVybmFsRmliZXIiLCJ2YWx1ZSIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9QTEFDRUhPTERFUl9UWVBFIiwiUkVBQ1RfUFVSRV9UWVBFIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlBlbmRpbmciLCJSZXNvbHZlZCIsIlJlamVjdGVkIiwiZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUiLCJ0aGVuYWJsZSIsIl9yZWFjdFJlc3VsdCIsInJlZmluZVJlc29sdmVkVGhlbmFibGUiLCJfcmVhY3RTdGF0dXMiLCJnZXRDb21wb25lbnROYW1lIiwiZGlzcGxheU5hbWUiLCIkJHR5cGVvZiIsInJlbmRlckZuIiwicmVuZGVyIiwiZnVuY3Rpb25OYW1lIiwidGhlbiIsInJlc29sdmVkVGhlbmFibGUiLCJOb0VmZmVjdCIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJVcGRhdGUiLCJQbGFjZW1lbnRBbmRVcGRhdGUiLCJEZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRGlkQ2FwdHVyZSIsIlJlZiIsIlNuYXBzaG90IiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiUmVhY3RDdXJyZW50T3duZXIiLCJNT1VOVElORyIsIk1PVU5URUQiLCJVTk1PVU5URUQiLCJpc0ZpYmVyTW91bnRlZEltcGwiLCJmaWJlciIsIm5vZGUiLCJlZmZlY3RUYWciLCJpc0ZpYmVyTW91bnRlZCIsImlzTW91bnRlZCIsImNvbXBvbmVudCIsIm93bmVyIiwib3duZXJGaWJlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwic3RhdGUiLCJwYXJlbnRBIiwicGFyZW50QiIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImVtcHR5T2JqZWN0IiwicmVtb3ZlZEtleXMiLCJyZW1vdmVkS2V5Q291bnQiLCJkZWZhdWx0RGlmZmVyIiwicHJldlByb3AiLCJuZXh0UHJvcCIsInJlc3RvcmVEZWxldGVkVmFsdWVzSW5OZXN0ZWRBcnJheSIsInVwZGF0ZVBheWxvYWQiLCJ2YWxpZEF0dHJpYnV0ZXMiLCJvYmoiLCJwcm9wS2V5IiwiYXR0cmlidXRlQ29uZmlnIiwiZGlmZiIsInByb2Nlc3MiLCJuZXh0VmFsdWUiLCJkaWZmTmVzdGVkQXJyYXlQcm9wZXJ0eSIsInByZXZBcnJheSIsIm5leHRBcnJheSIsIm1pbkxlbmd0aCIsImRpZmZOZXN0ZWRQcm9wZXJ0eSIsImNsZWFyTmVzdGVkUHJvcGVydHkiLCJhZGROZXN0ZWRQcm9wZXJ0eSIsImRpZmZQcm9wZXJ0aWVzIiwiYWRkUHJvcGVydGllcyIsImNsZWFyUHJvcGVydGllcyIsInByZXZQcm9wcyIsIm5leHRQcm9wcyIsInNob3VsZFVwZGF0ZSIsIl9uZXh0VmFsdWUiLCJfcHJvcEtleSIsImNyZWF0ZSIsIm1vdW50U2FmZUNhbGxiYWNrX05PVF9SRUFMTFlfU0FGRSIsImNhbGxiYWNrIiwiX19pc01vdW50ZWQiLCJ0aHJvd09uU3R5bGVzUHJvcCIsInN0eWxlcyIsIl9vd25lciIsIm1zZyIsIndhcm5Gb3JTdHlsZVByb3BzIiwic3R5bGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIlJlYWN0TmF0aXZlRmliZXJIb3N0Q29tcG9uZW50Iiwidmlld0NvbmZpZyIsIl9jaGlsZHJlbiIsImJsdXIiLCJibHVyVGV4dElucHV0IiwiZm9jdXMiLCJmb2N1c1RleHRJbnB1dCIsIm1lYXN1cmUiLCJtZWFzdXJlSW5XaW5kb3ciLCJtZWFzdXJlTGF5b3V0IiwicmVsYXRpdmVUb05hdGl2ZU5vZGUiLCJvblN1Y2Nlc3MiLCJvbkZhaWwiLCJzZXROYXRpdmVQcm9wcyIsIm5hdGl2ZVByb3BzIiwidXBkYXRlVmlldyIsInVpVmlld0NsYXNzTmFtZSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJub3ckMSIsInNjaGVkdWxlZENhbGxiYWNrIiwiZnJhbWVEZWFkbGluZSIsImZyYW1lRGVhZGxpbmVPYmplY3QiLCJ0aW1lUmVtYWluaW5nIiwiZGlkVGltZW91dCIsInNldFRpbWVvdXRDYWxsYmFjayIsInNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayQxIiwib3B0aW9ucyIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjYW5jZWxEZWZlcnJlZENhbGxiYWNrJDEiLCJjYWxsYmFja0lEIiwiY2xlYXJUaW1lb3V0Iiwic2hpbSIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJjbG9uZUluc3RhbmNlIiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwic2hpbSQxIiwic3VwcG9ydHNIeWRyYXRpb24iLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJVUERBVEVfU0lHTkFMIiwibmV4dFJlYWN0VGFnIiwiYWxsb2NhdGVUYWciLCJyZWN1cnNpdmVseVVuY2FjaGVGaWJlck5vZGUiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImNyZWF0ZUluc3RhbmNlIiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaXNJbkFQYXJlbnRUZXh0IiwiY3JlYXRlVmlldyIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInRleHQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsIm5hdGl2ZVRhZ3MiLCJzZXRDaGlsZHJlbiIsImdldFJvb3RIb3N0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsInByZXZJc0luQVBhcmVudFRleHQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJjb250YWluZXJJbmZvIiwicHJlcGFyZVVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJyZXNldEFmdGVyQ29tbWl0IiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2siLCJjYW5jZWxEZWZlcnJlZENhbGxiYWNrIiwic2NoZWR1bGVUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIm5vVGltZW91dCIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsInN1cHBvcnRzTXV0YXRpb24iLCJhcHBlbmRDaGlsZCIsImNoaWxkVGFnIiwiY2hpbGRyZW4iLCJzcGxpY2UiLCJtYW5hZ2VDaGlsZHJlbiIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb21taXRUZXh0VXBkYXRlIiwidGV4dEluc3RhbmNlIiwib2xkVGV4dCIsIm5ld1RleHQiLCJjb21taXRVcGRhdGUiLCJ1cGRhdGVQYXlsb2FkVE9ETyIsImluc2VydEJlZm9yZSIsImJlZm9yZUNoaWxkIiwiYmVmb3JlQ2hpbGRJbmRleCIsIl9iZWZvcmVDaGlsZEluZGV4IiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsInJlc2V0VGV4dENvbnRlbnQiLCJCRUZPUkVfU0xBU0hfUkUiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwic291cmNlIiwib3duZXJOYW1lIiwic291cmNlSW5mbyIsImZpbGVOYW1lIiwidGVzdCIsIm1hdGNoIiwicGF0aEJlZm9yZVNsYXNoIiwiZm9sZGVyTmFtZSIsImxpbmVOdW1iZXIiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwiZGVzY3JpYmVGaWJlciIsIl9kZWJ1Z093bmVyIiwiX2RlYnVnU291cmNlIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJpbmZvIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwiLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicmVzZXRDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50UGhhc2UiLCJsaWZlQ3ljbGVQaGFzZSIsImRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyIsImRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUiLCJlbmFibGVTdXNwZW5zZSIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJyZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjayIsIndhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzIiwiZW5hYmxlUHJvZmlsZXJUaW1lciIsImVuYWJsZVNjaGVkdWxlclRyYWNpbmciLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwibWFyayIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwiY3VycmVudEZpYmVyIiwiY3VycmVudFBoYXNlIiwiY3VycmVudFBoYXNlRmliZXIiLCJpc0NvbW1pdHRpbmciLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQiLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSIsImNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AiLCJlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCIsImlzV2FpdGluZ0ZvckNhbGxiYWNrIiwibGFiZWxzSW5DdXJyZW50Q29tbWl0IiwiU2V0IiwiZm9ybWF0TWFya05hbWUiLCJtYXJrTmFtZSIsImZvcm1hdExhYmVsIiwibGFiZWwiLCJ3YXJuaW5nIiwicHJlZml4Iiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJlcnIiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJjb21wb25lbnROYW1lIiwiYmVnaW5GaWJlck1hcmsiLCJfZGVidWdJRCIsImhhcyIsImFkZCIsImNsZWFyRmliZXJNYXJrIiwiZW5kRmliZXJNYXJrIiwic2hvdWxkSWdub3JlRmliZXIiLCJjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50IiwicGF1c2VUaW1lcnMiLCJfZGVidWdJc0N1cnJlbnRseVRpbWluZyIsInJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5IiwicmVzdW1lVGltZXJzIiwicmVjb3JkRWZmZWN0IiwicmVjb3JkU2NoZWR1bGVVcGRhdGUiLCJzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyIiwic3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyIiwiZGlkRXhwaXJlIiwiZXhwaXJhdGlvblRpbWUiLCJzdGFydFdvcmtUaW1lciIsImNhbmNlbFdvcmtUaW1lciIsInN0b3BXb3JrVGltZXIiLCJzdG9wRmFpbGVkV29ya1RpbWVyIiwic3RhcnRQaGFzZVRpbWVyIiwic3RvcFBoYXNlVGltZXIiLCJzdGFydFdvcmtMb29wVGltZXIiLCJuZXh0VW5pdE9mV29yayIsInN0b3BXb3JrTG9vcFRpbWVyIiwiaW50ZXJydXB0ZWRCeSIsImRpZENvbXBsZXRlUm9vdCIsInN0YXJ0Q29tbWl0VGltZXIiLCJjbGVhciIsInN0b3BDb21taXRUaW1lciIsInN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIiLCJzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIiLCJjb3VudCIsInN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJjdXJzb3IiLCJjaGVja1RoYXRTdGFja0lzRW1wdHkiLCJyZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yIiwicHJldmlvdXNDb250ZXh0IiwiZ2V0VW5tYXNrZWRDb250ZXh0IiwiQ29tcG9uZW50IiwiZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyIiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsImhhc0NvbnRleHRDaGFuZ2VkIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwb3BDb250ZXh0IiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIl9Db21wb25lbnQiLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiaGFzTG9nZ2VkRXJyb3IiLCJjYXRjaEVycm9ycyIsImlzRGV2VG9vbHNQcmVzZW50IiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwicmVuZGVyZXJJRCIsImluamVjdCIsInJvb3QiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJtYXhTaWduZWQzMUJpdEludCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImV4cGlyYXRpb25UaW1lVG9NcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJMT1dfUFJJT1JJVFlfRVhQSVJBVElPTiIsIkxPV19QUklPUklUWV9CQVRDSF9TSVpFIiwiY29tcHV0ZUFzeW5jRXhwaXJhdGlvbiIsIkhJR0hfUFJJT1JJVFlfRVhQSVJBVElPTiIsIkhJR0hfUFJJT1JJVFlfQkFUQ0hfU0laRSIsImNvbXB1dGVJbnRlcmFjdGl2ZUV4cGlyYXRpb24iLCJOb0NvbnRleHQiLCJDb25jdXJyZW50TW9kZSIsIlN0cmljdE1vZGUiLCJQcm9maWxlTW9kZSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwidGVzdE1hcCIsIk1hcCIsInRlc3RTZXQiLCJkZWJ1Z0NvdW50ZXIiLCJGaWJlck5vZGUiLCJwZW5kaW5nUHJvcHMiLCJtb2RlIiwicmVmIiwibWVtb2l6ZWRQcm9wcyIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRTdGF0ZSIsImZpcnN0Q29udGV4dERlcGVuZGVuY3kiLCJuZXh0RWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJsYXN0RWZmZWN0IiwiY2hpbGRFeHBpcmF0aW9uVGltZSIsImFjdHVhbER1cmF0aW9uIiwiYWN0dWFsU3RhcnRUaW1lIiwic2VsZkJhc2VEdXJhdGlvbiIsInRyZWVCYXNlRHVyYXRpb24iLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCIsImlzUmVhY3RDb21wb25lbnQiLCJyZXNvbHZlTGF6eUNvbXBvbmVudFRhZyIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImlzQ29uY3VycmVudCIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJlbGVtZW50IiwiZmliZXJUYWciLCJnZXRUYWciLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyIiwia2V5cyIsIl9zb3VyY2UiLCJlbGVtZW50cyIsImlkIiwib25SZW5kZXIiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY29udGVudCIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwicG9ydGFsIiwicGVuZGluZ0NoaWxkcmVuIiwiaW1wbGVtZW50YXRpb24iLCJhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFViIsImNyZWF0ZUZpYmVyUm9vdCIsImh5ZHJhdGUiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJlYXJsaWVzdFBlbmRpbmdUaW1lIiwibGF0ZXN0UGVuZGluZ1RpbWUiLCJlYXJsaWVzdFN1c3BlbmRlZFRpbWUiLCJsYXRlc3RTdXNwZW5kZWRUaW1lIiwibGF0ZXN0UGluZ2VkVGltZSIsInBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSIsImZpbmlzaGVkV29yayIsInRpbWVvdXRIYW5kbGUiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uIiwiZmlyc3RCYXRjaCIsIm5leHRTY2hlZHVsZWRSb290IiwiaW50ZXJhY3Rpb25UaHJlYWRJRCIsInVuc3RhYmxlX2dldFRocmVhZElEIiwibWVtb2l6ZWRJbnRlcmFjdGlvbnMiLCJwZW5kaW5nSW50ZXJhY3Rpb25NYXAiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuMiIsIl9rZXkyIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJSZWFjdFN0cmljdE1vZGVXYXJuaW5ncyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzIiwiZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJyZWNvcmREZXByZWNhdGlvbldhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmciLCJMSUZFQ1lDTEVfU1VHR0VTVElPTlMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsInBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwicGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMiLCJkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzIiwiZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCIsInNldFRvU29ydGVkU3RyaW5nIiwiYXJyYXkiLCJzb3J0Iiwiam9pbiIsImxpZmVjeWNsZVdhcm5pbmdzTWFwIiwic3RyaWN0Um9vdCIsImxpZmVjeWNsZXNXYXJuaW5nTWVzYWdlcyIsImxpZmVjeWNsZSIsImxpZmVjeWNsZVdhcm5pbmdzIiwiY29tcG9uZW50TmFtZXMiLCJmb3JtYXR0ZWQiLCJzdWdnZXN0aW9uIiwic29ydGVkQ29tcG9uZW50TmFtZXMiLCJzdHJpY3RSb290Q29tcG9uZW50U3RhY2siLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsInVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJfdW5pcXVlTmFtZXMiLCJfc29ydGVkTmFtZXMiLCJfdW5pcXVlTmFtZXMyIiwiX3NvcnRlZE5hbWVzMiIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIndhcm5pbmdzRm9yUm9vdCIsInVuc2FmZUxpZmVjeWNsZXMiLCJmaWJlckFycmF5IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsIm1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbCIsImZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiIsIm1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyIsImVhcmxpZXN0UmVtYWluaW5nVGltZSIsImhhc0xvd2VyUHJpb3JpdHlXb3JrIiwiZXJyb3JlZEV4cGlyYXRpb25UaW1lIiwiaXNQcmlvcml0eUxldmVsU3VzcGVuZGVkIiwibWFya1N1c3BlbmRlZFByaW9yaXR5TGV2ZWwiLCJzdXNwZW5kZWRUaW1lIiwiY2xlYXJQaW5nIiwibWFya1BpbmdlZFByaW9yaXR5TGV2ZWwiLCJwaW5nZWRUaW1lIiwiY29tcGxldGVkVGltZSIsImZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbCIsInJlbmRlckV4cGlyYXRpb25UaW1lIiwiZWFybGllc3RFeHBpcmF0aW9uVGltZSIsImRpZEV4cGlyZUF0RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiRm9yY2VVcGRhdGUiLCJDYXB0dXJlVXBkYXRlIiwiaGFzRm9yY2VVcGRhdGUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlIiwicmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJjcmVhdGVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsInF1ZXVlIiwiZmlyc3RVcGRhdGUiLCJsYXN0VXBkYXRlIiwiZmlyc3RDYXB0dXJlZFVwZGF0ZSIsImxhc3RDYXB0dXJlZFVwZGF0ZSIsImZpcnN0Q2FwdHVyZWRFZmZlY3QiLCJsYXN0Q2FwdHVyZWRFZmZlY3QiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiY3JlYXRlVXBkYXRlIiwicGF5bG9hZCIsImFwcGVuZFVwZGF0ZVRvUXVldWUiLCJ1cGRhdGUiLCJlbnF1ZXVlVXBkYXRlIiwicXVldWUxIiwicXVldWUyIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwid29ya0luUHJvZ3Jlc3NRdWV1ZSIsImVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSIsImdldFN0YXRlRnJvbVVwZGF0ZSIsInByZXZTdGF0ZSIsIl9wYXlsb2FkIiwiX3BheWxvYWQyIiwicGFydGlhbFN0YXRlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwibmV3QmFzZVN0YXRlIiwibmV3Rmlyc3RVcGRhdGUiLCJuZXdFeHBpcmF0aW9uVGltZSIsInJlc3VsdFN0YXRlIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfY2FsbGJhY2siLCJuZXdGaXJzdENhcHR1cmVkVXBkYXRlIiwiX3VwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX2NhbGxiYWNrMiIsInJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nIiwiY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyIsImNvbW1pdFVwZGF0ZVF1ZXVlIiwiZmluaXNoZWRRdWV1ZSIsImNvbW1pdFVwZGF0ZUVmZmVjdHMiLCJlZmZlY3QiLCJfY2FsbGJhY2szIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsIndhcm5pbmckMSIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJTaWdpbCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwibGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jZXMiLCJwdXNoUHJvdmlkZXIiLCJwcm92aWRlckZpYmVyIiwiX2NvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50VmFsdWUyIiwiX2N1cnJlbnRSZW5kZXJlcjIiLCJwb3BQcm92aWRlciIsImN1cnJlbnRWYWx1ZSIsImNhbGN1bGF0ZUNoYW5nZWRCaXRzIiwibmV3VmFsdWUiLCJvbGRWYWx1ZSIsImNoYW5nZWRCaXRzIiwiX2NhbGN1bGF0ZUNoYW5nZWRCaXRzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsIm5leHRGaWJlciIsImRlcGVuZGVuY3kiLCJvYnNlcnZlZEJpdHMiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsInJlYWRDb250ZXh0IiwicmVzb2x2ZWRPYnNlcnZlZEJpdHMiLCJjb250ZXh0SXRlbSIsIk5PX0NPTlRFWFQiLCJjb250ZXh0U3RhY2tDdXJzb3IkMSIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJyZXF1aXJlZENvbnRleHQiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInJvb3RJbnN0YW5jZSIsInB1c2hIb3N0Q29udGFpbmVyIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsIm5leHRDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJjb21taXRUaW1lIiwicHJvZmlsZXJTdGFydFRpbWUiLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJlbGFwc2VkVGltZSIsImlzIiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiaXNBcnJheSQxIiwiZW1wdHlSZWZzT2JqZWN0IiwicmVmcyIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsImVudW1lcmFibGUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImN0b3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJyZXF1ZXN0Q3VycmVudFRpbWUiLCJjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyIiwic2NoZWR1bGVXb3JrIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVGb3JjZVVwZGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsIm5vR2V0SW5pdGlhbFN0YXRlT25FUzYiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsIm5vR2V0RGVmYXVsdFByb3BzT25FUzYiLCJnZXREZWZhdWx0UHJvcHMiLCJub0luc3RhbmNlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwibm9JbnN0YW5jZUNvbnRleHRUeXBlIiwiY29udGV4dFR5cGUiLCJub0luc3RhbmNlQ29udGV4dFR5cGVzIiwibm9Db21wb25lbnRTaG91bGRVcGRhdGUiLCJjb21wb25lbnRTaG91bGRVcGRhdGUiLCJub0NvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRVbm1vdW50Iiwibm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwibm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwiZGVmYXVsdFByb3BzIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwibm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIm5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJfc3RhdGUiLCJhZG9wdENsYXNzSW5zdGFuY2UiLCJ1cGRhdGVyIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJpc0xlZ2FjeUNvbnRleHRDb25zdW1lciIsInVuc3RhYmxlX3JlYWQiLCJmb3VuZFdpbGxNb3VudE5hbWUiLCJmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIiwiZm91bmRXaWxsVXBkYXRlTmFtZSIsIl9jb21wb25lbnROYW1lIiwibmV3QXBpTmFtZSIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsImNvbXBvbmVudERpZE1vdW50IiwicmVzdW1lTW91bnRDbGFzc0luc3RhbmNlIiwib2xkQ29udGV4dCIsIm5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQiLCJoYXNOZXdMaWZlY3ljbGVzIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsImRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZSIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNvZXJjZVJlZiIsInJldHVybkZpYmVyIiwiY3VycmVudCQkMSIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwiX3N0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsIm5ld0NoaWxkIiwiYWRkZW5kdW0iLCJ0b1N0cmluZyIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJsYXN0IiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNsb25lIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsInRleHRDb250ZW50IiwiY3JlYXRlZCIsImV4aXN0aW5nIiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZVBvcnRhbCIsInVwZGF0ZUZyYWdtZW50IiwiZnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9jcmVhdGVkIiwiX2NyZWF0ZWQyIiwiX2NyZWF0ZWQzIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIm1hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyMiIsIl9tYXRjaGVkRmliZXIzIiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwiX25ld0ZpYmVyIiwiX25ld0ZpYmVyMiIsImRlbGV0ZSIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IiLCJuZXdDaGlsZHJlbkl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsInRvU3RyaW5nVGFnIiwiZW50cmllcyIsIl9uZXdDaGlsZHJlbiIsIl9zdGVwIiwiZG9uZSIsInN0ZXAiLCJfbmV3RmliZXIzIiwiX25ld0ZpYmVyNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9jcmVhdGVkNCIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCIsImlzT2JqZWN0IiwiX2lzTW9ja0Z1bmN0aW9uIiwibW91bnRDaGlsZEZpYmVycyIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlIiwicGFyZW50Q29udGFpbmVyIiwicGFyZW50VHlwZSIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwicmVhZExhenlDb21wb25lbnRUeXBlIiwic3RhdHVzIiwicmVzb2x2ZWRWYWx1ZSIsImRlZmF1bHRFeHBvcnQiLCJkZWZhdWx0IiwiUmVhY3RDdXJyZW50T3duZXIkMyIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwiZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZSIsInVwZGF0ZUZvcndhcmRSZWYiLCJjdXJyZW50UmVmIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1lbW9pemVQcm9wcyIsInVwZGF0ZVB1cmVDb21wb25lbnQiLCJjb21wYXJlIiwidXBkYXRlTW9kZSIsInVwZGF0ZVByb2ZpbGVyIiwibWFya1JlZiIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJkaWRDYXB0dXJlRXJyb3IiLCJtZW1vaXplU3RhdGUiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJwcmV2Q2hpbGRyZW4iLCJuZXh0U3RhdGUiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsInJlc29sdmVEZWZhdWx0UHJvcHMiLCJiYXNlUHJvcHMiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJyZXNvbHZlZFRhZyIsInJlc29sdmVkUHJvcHMiLCJ3YXJuaW5nS2V5IiwiZGVidWdTb3VyY2UiLCJfY29tcG9uZW50TmFtZTIiLCJ1cGRhdGVQbGFjZWhvbGRlckNvbXBvbmVudCIsImFscmVhZHlDYXB0dXJlZCIsIm5leHREaWRUaW1lb3V0IiwiZmFsbGJhY2siLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJwcm92aWRlclByb3BUeXBlcyIsInVwZGF0ZUNvbnRleHRDb25zdW1lciIsInVuc3RhYmxlX29ic2VydmVkQml0cyIsImJlZ2luV29yayIsIl9Db21wb25lbnQyIiwiX0NvbXBvbmVudDMiLCJ1bnJlc29sdmVkUHJvcHMiLCJfdGhlbmFibGUiLCJfQ29tcG9uZW50NCIsIl91bnJlc29sdmVkUHJvcHMiLCJfQ29tcG9uZW50NSIsIl91bnJlc29sdmVkUHJvcHMyIiwiX3RoZW5hYmxlMiIsIl9Db21wb25lbnQ2IiwiX3VucmVzb2x2ZWRQcm9wczMiLCJfdGhlbmFibGUzIiwiX0NvbXBvbmVudDciLCJfdW5yZXNvbHZlZFByb3BzNCIsIl9jaGlsZDIiLCJfdGhlbmFibGU0IiwiX0NvbXBvbmVudDgiLCJfdW5yZXNvbHZlZFByb3BzNSIsIl9jaGlsZDMiLCJtYXJrVXBkYXRlIiwibWFya1JlZiQxIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwidXBkYXRlSG9zdENvbXBvbmVudCQxIiwidXBkYXRlSG9zdFRleHQkMSIsImN1cnJlbnRIb3N0Q29udGV4dCIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsInBvcnRhbE9yUm9vdCIsImNoaWxkcmVuVW5jaGFuZ2VkIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjdXJyZW50SW5zdGFuY2UiLCJyZWN5Y2xhYmxlSW5zdGFuY2UiLCJuZXdJbnN0YW5jZSIsImNvbXBsZXRlV29yayIsImZpYmVyUm9vdCIsIndhc0h5ZHJhdGVkIiwiX3Jvb3RDb250YWluZXJJbnN0YW5jZSIsIl9jdXJyZW50SG9zdENvbnRleHQiLCJfd2FzSHlkcmF0ZWQiLCJzaG93RXJyb3JEaWFsb2ciLCJjYXB0dXJlZEVycm9yIiwiY29tcG9uZW50U3RhY2siLCJlcnJvclRvSGFuZGxlIiwic3VtbWFyeSIsImhhbmRsZUV4Y2VwdGlvbiIsImxvZ0NhcHR1cmVkRXJyb3IiLCJsb2dFcnJvciIsImVycm9yQm91bmRhcnlOYW1lIiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwid2lsbFJldHJ5IiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbWJpbmVkTWVzc2FnZSIsImVtcHR5T2JqZWN0JDEiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImJvdW5kYXJ5IiwiZXJyb3JJbmZvIiwiZXJyb3JCb3VuZGFyeSIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsImNvbXBvbmVudFdpbGxVbm1vdW50Iiwic2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwidW5tb3VudEVycm9yIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlEZXRhY2hSZWYiLCJyZWZFcnJvciIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyIsInNuYXBzaG90IiwiZGlkV2FyblNldCIsIl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tbWl0TGlmZUN5Y2xlcyIsImZpbmlzaGVkUm9vdCIsImNvbW1pdHRlZEV4cGlyYXRpb25UaW1lIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlIiwiX2luc3RhbmNlMiIsInRpbWVkT3V0QXQiLCJjb21taXRBdHRhY2hSZWYiLCJpbnN0YW5jZVRvVXNlIiwiY29tbWl0RGV0YWNoUmVmIiwiY29tbWl0VW5tb3VudCIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJkZXRhY2hGaWJlciIsImVtcHR5Q2hpbGRTZXQiLCJjb21taXRDb250YWluZXIiLCJfcGVuZGluZ0NoaWxkcmVuIiwiZ2V0SG9zdFBhcmVudEZpYmVyIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJzaWJsaW5ncyIsImNvbW1pdFBsYWNlbWVudCIsInBhcmVudEZpYmVyIiwiaXNDb250YWluZXIiLCJiZWZvcmUiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRSZXNldFRleHRDb250ZW50IiwiTm9vcENvbXBvbmVudCIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsIm9uVW5jYXVnaHRFcnJvciIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJjb21wb25lbnREaWRDYXRjaCIsIm1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQiLCJ0aHJvd0V4Y2VwdGlvbiIsInNvdXJjZUZpYmVyIiwiX3dvcmtJblByb2dyZXNzIiwiZWFybGllc3RUaW1lb3V0TXMiLCJzdGFydFRpbWVNcyIsInRpbWVvdXRQcm9wTXMiLCJkZWxheU1zIiwicGluZ1RpbWUiLCJvblJlc29sdmVPclJlamVjdCIsInJldHJ5U3VzcGVuZGVkUm9vdCIsImJpbmQiLCJ1bnN0YWJsZV93cmFwIiwiYWJzb2x1dGVUaW1lb3V0TXMiLCJlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMiLCJyZW5kZXJEaWRTdXNwZW5kIiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl91cGRhdGUiLCJ1bndpbmRXb3JrIiwiX2VmZmVjdFRhZyIsIl9lZmZlY3RUYWcyIiwiX2VmZmVjdFRhZzMiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJfY2hpbGRDb250ZXh0VHlwZXMiLCJEaXNwYXRjaGVyIiwiUmVhY3RDdXJyZW50T3duZXIkMiIsImRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiIsImRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCIsIndhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkIiwid2FybkFib3V0SW52YWxpZFVwZGF0ZXMiLCJfX2ludGVyYWN0aW9uc1JlZiIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsImV4cGlyYXRpb25Db250ZXh0IiwiaXNXb3JraW5nIiwibmV4dFJvb3QiLCJuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUiLCJuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMiLCJuZXh0UmVuZGVyRGlkRXJyb3IiLCJpc0NvbW1pdHRpbmckMSIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwic3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyIsInJlcGxheVVuaXRPZldvcmsiLCJpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsiLCJvcmlnaW5hbFJlcGxheUVycm9yIiwicmV0aHJvd09yaWdpbmFsRXJyb3IiLCJmYWlsZWRVbml0T2ZXb3JrIiwidGhyb3duVmFsdWUiLCJpc1lpZWxkeSIsIndvcmtMb29wIiwicmVwbGF5RXJyb3IiLCJyZXNldFN0YWNrIiwiY29tbWl0QWxsSG9zdEVmZmVjdHMiLCJwcmltYXJ5RWZmZWN0VGFnIiwiX2N1cnJlbnQiLCJfY3VycmVudDIiLCJjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVjeWNsZXMiLCJjb21taXRBbGxMaWZlQ3ljbGVzIiwiY29tbWl0Um9vdCIsInVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0IiwiY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCIsImVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCIsInByZXZJbnRlcmFjdGlvbnMiLCJfZGlkRXJyb3IiLCJfZXJyb3IiLCJfZGlkRXJyb3IyIiwiX2Vycm9yMiIsIm9uQ29tbWl0V29yayIsInVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQiLCJjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQiLCJlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCIsIm9uQ29tbWl0Iiwic3Vic2NyaWJlciIsIl9fc3Vic2NyaWJlclJlZiIsInNpemUiLCJ0aHJlYWRJRCIsImNvbXB1dGVUaHJlYWRJRCIsIm9uV29ya1N0b3BwZWQiLCJoYXNVbmhhbmRsZWRFcnJvciIsInVuaGFuZGxlZEVycm9yIiwic2NoZWR1bGVkSW50ZXJhY3Rpb25zIiwic2NoZWR1bGVkRXhwaXJhdGlvblRpbWUiLCJpbnRlcmFjdGlvbiIsIl9fY291bnQiLCJvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZCIsInJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSIsInJlbmRlclRpbWUiLCJuZXdDaGlsZEV4cGlyYXRpb25UaW1lIiwic2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zIiwiY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSIsImNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsIl9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsImNvbXBsZXRlVW5pdE9mV29yayIsInNpYmxpbmdGaWJlciIsIm9uQ29tcGxldGVXb3JrIiwicGVyZm9ybVVuaXRPZldvcmsiLCJvbkJlZ2luV29yayIsInNob3VsZFlpZWxkIiwicmVuZGVyUm9vdCIsImlzRXhwaXJlZCIsImN1cnJlbnREaXNwYXRjaGVyIiwiaW50ZXJhY3Rpb25zIiwib25Xb3JrU3RhcnRlZCIsImRpZEZhdGFsIiwiX2RpZENvbXBsZXRlUm9vdCIsIm9uRmF0YWwiLCJfZGlkQ29tcGxldGVSb290MiIsIm9uWWllbGQiLCJyb290V29ya0luUHJvZ3Jlc3MiLCJzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSIsInJvb3RFeHBpcmF0aW9uVGltZSIsIm9uU3VzcGVuZCIsIl9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZSIsIl9yb290RXhwaXJhdGlvblRpbWUiLCJfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyIiwiY3VycmVudFRpbWVNcyIsIm1zVW50aWxUaW1lb3V0IiwiX3Jvb3RFeHBpcmF0aW9uVGltZTIiLCJvbkNvbXBsZXRlIiwiZGlzcGF0Y2giLCJyb290RmliZXIiLCJfZXJyb3JJbmZvMiIsIl91cGRhdGUyIiwiaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyIsImxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUiLCJyZXRyeVRpbWUiLCJzY2hlZHVsZVdvcmtUb1Jvb3QiLCJyZXF1ZXN0V29yayIsInBlbmRpbmdJbnRlcmFjdGlvbnMiLCJvbldvcmtTY2hlZHVsZWQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImNhbGxiYWNrRXhwaXJhdGlvblRpbWUiLCJpc1JlbmRlcmluZyIsIm5leHRGbHVzaGVkUm9vdCIsIm5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUiLCJkZWFkbGluZURpZEV4cGlyZSIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiY29tcGxldGVkQmF0Y2hlcyIsIm9yaWdpbmFsU3RhcnRUaW1lTXMiLCJjdXJyZW50UmVuZGVyZXJUaW1lIiwiY3VycmVudFNjaGVkdWxlclRpbWUiLCJsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCIsInRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrIiwicmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSIsInNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50TXMiLCJleHBpcmF0aW9uVGltZU1zIiwidGltZW91dCIsInBlcmZvcm1Bc3luY1dvcmsiLCJvblRpbWVvdXQiLCJmbHVzaFJvb3QiLCJmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCIsImFkZFJvb3RUb1NjaGVkdWxlIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtU3luY1dvcmsiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsImhpZ2hlc3RQcmlvcml0eVdvcmsiLCJoaWdoZXN0UHJpb3JpdHlSb290IiwicHJldmlvdXNTY2hlZHVsZWRSb290IiwiZGwiLCJwZXJmb3JtV29yayIsIm1pbkV4cGlyYXRpb25UaW1lIiwiZmluaXNoUmVuZGVyaW5nIiwiYmF0Y2hlcyIsImJhdGNoIiwiX29uQ29tcGxldGUiLCJjb21wbGV0ZVJvb3QiLCJfZmluaXNoZWRXb3JrIiwiX3RpbWVvdXRIYW5kbGUiLCJfaXNZaWVsZHkiLCJfZXhwaXJhdGlvblRpbWUiLCJfZGVmZXIiLCJiYXRjaGVkVXBkYXRlcyQxIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsImludGVyYWN0aXZlVXBkYXRlcyQxIiwicHJldmlvdXNJc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzIiwiZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMkMSIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsInNjaGVkdWxlUm9vdFVwZGF0ZSIsInVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJmaW5kSG9zdEluc3RhbmNlJDEiLCJob3N0RmliZXIiLCJjcmVhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImNyZWF0ZVBvcnRhbCIsIlJlYWN0VmVyc2lvbiIsIk5hdGl2ZU1ldGhvZHNNaXhpbiIsImZpbmROb2RlSGFuZGxlIiwiZmluZEhvc3RJbnN0YW5jZSIsIm1heWJlSW5zdGFuY2UiLCJOYXRpdmVNZXRob2RzTWl4aW5fREVWIiwiX2NsYXNzQ2FsbENoZWNrJDEiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsIndyaXRhYmxlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJSZWFjdE5hdGl2ZUNvbXBvbmVudCIsIl9SZWFjdCRDb21wb25lbnQiLCJlbXB0eU9iamVjdCQyIiwiZ2V0SW5zcGVjdG9yRGF0YUZvclZpZXdUYWciLCJ0cmF2ZXJzZU93bmVyVHJlZVVwIiwiaGllcmFyY2h5IiwidW5zaGlmdCIsImdldE93bmVySGllcmFyY2h5IiwibGFzdE5vbkhvc3RJbnN0YW5jZSIsImdldEhvc3RQcm9wcyIsImhvc3QiLCJnZXRIb3N0Tm9kZSIsImhvc3ROb2RlIiwiY3JlYXRlSGllcmFyY2h5IiwiZmliZXJIaWVyYXJjaHkiLCJnZXRJbnNwZWN0b3JEYXRhIiwidmlld1RhZyIsImNsb3Nlc3RJbnN0YW5jZSIsInNlbGVjdGlvbiIsImNvbXBvbmVudE9ySGFuZGxlIiwiaG9zdEluc3RhbmNlIiwiY29tcHV0ZUNvbXBvbmVudFN0YWNrRm9yRXJyb3JSZXBvcnRpbmciLCJyZWFjdFRhZyIsInJvb3RzIiwiUmVhY3ROYXRpdmVSZW5kZXJlciIsIk5hdGl2ZUNvbXBvbmVudCIsImNvbnRhaW5lclRhZyIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlQW5kUmVtb3ZlQ29udGFpbmVyIiwicmVtb3ZlUm9vdFZpZXciLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsImJ1bmRsZVR5cGUiLCJ2ZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsIlJlYWN0TmF0aXZlUmVuZGVyZXIkMiIsIlJlYWN0TmF0aXZlUmVuZGVyZXIkMyIsInJlYWN0TmF0aXZlUmVuZGVyZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQVlBOzs7O0FBRUEs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bUI7QUFDakJFLCtCQUF5Qmp4QyxrQkFEUjtBQUVqQnV5QyxrQ0FBNEJBLDBCQUZYO0FBR2pCNEIsa0JBQVksQ0FISztBQUlqQkMsZUFBU2hELFlBSlE7QUFLakJpRCwyQkFBcUI7QUFMSixLQUFuQjs7QUFRQSxRQUFJQyx3QkFBd0I5cUQsT0FBT21aLE1BQVAsQ0FBYztBQUN4QyszQixlQUFTa1o7QUFEK0IsS0FBZCxDQUE1Qjs7QUFJQSxRQUFJVyx3QkFDREQseUJBQXlCVixtQkFBMUIsSUFBa0RVLHFCQURwRDs7QUFLQSxRQUFJRSxzQkFDRkQsc0JBQXNCN1osT0FBdEIsSUFBaUM2WixxQkFEbkM7O0FBR0FFLFdBQU9DLE9BQVAsR0FBaUJGLG1CQUFqQjtBQUVHLEdBeGpnQkQ7QUF5amdCRCIsImZpbGUiOiJSZWFjdE5hdGl2ZVJlbmRlcmVyLWRldi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQG5vZmxvd1xuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TmF0aXZlUmVuZGVyZXItZGV2XG4gKiBAcHJldmVudE11bmdlXG4gKiBAZ2VuZXJhdGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoX19ERVZfXykge1xuICAoZnVuY3Rpb24oKSB7XG5cInVzZSBzdHJpY3RcIjtcblxucmVxdWlyZShcIkluaXRpYWxpemVDb3JlXCIpO1xudmFyIFJlYWN0TmF0aXZlVmlld0NvbmZpZ1JlZ2lzdHJ5ID0gcmVxdWlyZShcIlJlYWN0TmF0aXZlVmlld0NvbmZpZ1JlZ2lzdHJ5XCIpO1xudmFyIFVJTWFuYWdlciA9IHJlcXVpcmUoXCJVSU1hbmFnZXJcIik7XG52YXIgUkNURXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIlJDVEV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBkZWVwRnJlZXplQW5kVGhyb3dPbk11dGF0aW9uSW5EZXYgPSByZXF1aXJlKFwiZGVlcEZyZWV6ZUFuZFRocm93T25NdXRhdGlvbkluRGV2XCIpO1xudmFyIGRlZXBEaWZmZXIgPSByZXF1aXJlKFwiZGVlcERpZmZlclwiKTtcbnZhciBmbGF0dGVuU3R5bGUgPSByZXF1aXJlKFwiZmxhdHRlblN0eWxlXCIpO1xudmFyIFRleHRJbnB1dFN0YXRlID0gcmVxdWlyZShcIlRleHRJbnB1dFN0YXRlXCIpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZShcInByb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXNcIik7XG52YXIgdHJhY2luZyA9IHJlcXVpcmUoXCJzY2hlZHVsZXIvdHJhY2luZ1wiKTtcbnZhciBFeGNlcHRpb25zTWFuYWdlciA9IHJlcXVpcmUoXCJFeGNlcHRpb25zTWFuYWdlclwiKTtcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24oKSB7fTtcblxue1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnRcIik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBcIk1pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IFwiICtcbiAgICAgICAgICBcImZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uKFxuICBuYW1lLFxuICBmdW5jLFxuICBjb250ZXh0LFxuICBhLFxuICBiLFxuICBjLFxuICBkLFxuICBlLFxuICBmXG4pIHtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gXCJmdW5jdGlvblwiXG4gICkge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJyZWFjdFwiKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbihcbiAgICAgIG5hbWUsXG4gICAgICBmdW5jLFxuICAgICAgY29udGV4dCxcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBlLFxuICAgICAgZlxuICAgICkge1xuICAgICAgLy8gSWYgZG9jdW1lbnQgZG9lc24ndCBleGlzdCB3ZSBrbm93IGZvciBzdXJlIHdlIHdpbGwgY3Jhc2ggaW4gdGhpcyBtZXRob2RcbiAgICAgIC8vIHdoZW4gd2UgY2FsbCBkb2N1bWVudC5jcmVhdGVFdmVudCgpLiBIb3dldmVyIHRoaXMgY2FuIGNhdXNlIGNvbmZ1c2luZ1xuICAgICAgLy8gZXJyb3JzOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcC9pc3N1ZXMvMzQ4MlxuICAgICAgLy8gU28gd2UgcHJlZW1wdGl2ZWx5IHRocm93IHdpdGggYSBiZXR0ZXIgbWVzc2FnZSBpbnN0ZWFkLlxuICAgICAgaW52YXJpYW50KFxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgICAgIFwiVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IFwiICtcbiAgICAgICAgICBcImRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgXCJzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgXCIgK1xuICAgICAgICAgIFwiZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IFwiICtcbiAgICAgICAgICBcInRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBcIiArXG4gICAgICAgICAgXCJjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIFwiICtcbiAgICAgICAgICBcInRvIGJlIGFzeW5jaHJvbm91cy5cIlxuICAgICAgKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdmFsdWUgb2Ygd2luZG93LmV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlc2V0IGl0XG4gICAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcbiAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdC5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgd2luZG93LFxuICAgICAgICBcImV2ZW50XCJcbiAgICAgICk7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgICAvLyBXZSBjaGVjayBmb3Igd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpIHRvIHByZXZlbnQgdGhlXG4gICAgICAgIC8vIHdpbmRvdy5ldmVudCBhc3NpZ25tZW50IGluIGJvdGggSUUgPD0gMTAgYXMgdGhleSB0aHJvdyBhbiBlcnJvclxuICAgICAgICAvLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCB3aW5kb3cuZXZlbnQuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgd2luZG93Lmhhc093blByb3BlcnR5KFwiZXZlbnRcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikge1xuICAgICAgICAgICAgICAvLyBJZ25vcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6IFwiaW52b2tlZ3VhcmRlZGNhbGxiYWNrXCIpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZVdpbmRvd0Vycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJldmVudFwiLCB3aW5kb3dFdmVudERlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgXCIgK1xuICAgICAgICAgICAgICBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgK1xuICAgICAgICAgICAgICAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgK1xuICAgICAgICAgICAgICAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICtcbiAgICAgICAgICAgICAgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgK1xuICAgICAgICAgICAgICBcInlvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgXCIgK1xuICAgICAgICAgICAgICBcIm9yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgXCIgK1xuICAgICAgICAgICAgICBcImFjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArXG4gICAgICAgICAgICAgIFwidGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuIFwiICtcbiAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlV2luZG93RXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO1xuXG4vLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG5cbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihcbiAgbmFtZSxcbiAgZnVuYyxcbiAgY29udGV4dCxcbiAgYSxcbiAgYixcbiAgYyxcbiAgZCxcbiAgZSxcbiAgZlxuKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG4gIHJldHVybiBoYXNFcnJvcjtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgXCJjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBcIiArXG4gICAgICAgIFwiaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBwbHVnaW5JbmRleCA+IC0xLFxuICAgICAgXCJFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gXCIgK1xuICAgICAgICBcInRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuXCIsXG4gICAgICBwbHVnaW5OYW1lXG4gICAgKTtcbiAgICBpZiAocGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoXG4gICAgICBwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyxcbiAgICAgIFwiRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgXCIgK1xuICAgICAgICBcIm1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuXCIsXG4gICAgICBwbHVnaW5OYW1lXG4gICAgKTtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oXG4gICAgICAgICAgcHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sXG4gICAgICAgICAgcGx1Z2luTW9kdWxlLFxuICAgICAgICAgIGV2ZW50TmFtZVxuICAgICAgICApLFxuICAgICAgICBcIkV2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLlwiLFxuICAgICAgICBldmVudE5hbWUsXG4gICAgICAgIHBsdWdpbk5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgaW52YXJpYW50KFxuICAgICFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSxcbiAgICBcIkV2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBcIiArXG4gICAgICBcImV2ZW50IG5hbWUsIGAlc2AuXCIsXG4gICAgZXZlbnROYW1lXG4gICk7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShcbiAgICAgICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lLFxuICAgICAgICAgIHBsdWdpbk1vZHVsZSxcbiAgICAgICAgICBldmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKFxuICAgICAgZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgIHBsdWdpbk1vZHVsZSxcbiAgICAgIGV2ZW50TmFtZVxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gIGludmFyaWFudChcbiAgICAhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0sXG4gICAgXCJFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgXCIgK1xuICAgICAgXCJyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC5cIixcbiAgICByZWdpc3RyYXRpb25OYW1lXG4gICk7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID1cbiAgICBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gIGludmFyaWFudChcbiAgICAhZXZlbnRQbHVnaW5PcmRlcixcbiAgICBcIkV2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBcIiArXG4gICAgICBcIm9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC5cIlxuICApO1xuICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xufVxuXG4vKipcbiAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAqXG4gKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICBpZiAoXG4gICAgICAhbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHxcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGVcbiAgICApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdLFxuICAgICAgICBcIkV2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIFwiICtcbiAgICAgICAgICBcInVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuXCIsXG4gICAgICAgIHBsdWdpbk5hbWVcbiAgICAgICk7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24oKSB7fTtcblxue1xuICB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLFxuICAgICAgICBfa2V5ID0gMjtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJgd2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyBcIiArXG4gICAgICAgICAgXCJtZXNzYWdlIGFyZ3VtZW50XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICAgIC8vIENoZWNrIGJlZm9yZSB0aGUgY29uZGl0aW9uIHRvIGNhdGNoIHZpb2xhdGlvbnMgZWFybHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwid2FybmluZ1dpdGhvdXRTdGFjaygpIGN1cnJlbnRseSBzdXBwb3J0cyBhdCBtb3N0IDggYXJndW1lbnRzLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFyIF9hcmdzJG1hcCA9IGFyZ3MubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gXCJcIiArIGl0ZW07XG4gICAgICAgIH0pLFxuICAgICAgICBhID0gX2FyZ3MkbWFwWzBdLFxuICAgICAgICBiID0gX2FyZ3MkbWFwWzFdLFxuICAgICAgICBjID0gX2FyZ3MkbWFwWzJdLFxuICAgICAgICBkID0gX2FyZ3MkbWFwWzNdLFxuICAgICAgICBlID0gX2FyZ3MkbWFwWzRdLFxuICAgICAgICBmID0gX2FyZ3MkbWFwWzVdLFxuICAgICAgICBnID0gX2FyZ3MkbWFwWzZdLFxuICAgICAgICBoID0gX2FyZ3MkbWFwWzddO1xuXG4gICAgICB2YXIgbWVzc2FnZSA9IFwiV2FybmluZzogXCIgKyBmb3JtYXQ7XG5cbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBiZWNhdXNlIGl0IGJyZWFrcyBJRTk6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYywgZCwgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlLCBhLCBiLCBjLCBkLCBlLCBmLCBnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgYSwgYiwgYywgZCwgZSwgZiwgZywgaCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJ3YXJuaW5nV2l0aG91dFN0YWNrKCkgY3VycmVudGx5IHN1cHBvcnRzIGF0IG1vc3QgOCBhcmd1bWVudHMuXCJcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgX21lc3NhZ2UgPVxuICAgICAgICBcIldhcm5pbmc6IFwiICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihfbWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2skMSA9IHdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gbnVsbDtcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gbnVsbDtcbnZhciBnZXROb2RlRnJvbUluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0Q29tcG9uZW50VHJlZShcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZUltcGwsXG4gIGdldEluc3RhbmNlRnJvbU5vZGVJbXBsLFxuICBnZXROb2RlRnJvbUluc3RhbmNlSW1wbFxuKSB7XG4gIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbDtcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IGdldEluc3RhbmNlRnJvbU5vZGVJbXBsO1xuICBnZXROb2RlRnJvbUluc3RhbmNlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGw7XG4gIHtcbiAgICAhKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSlcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiRXZlbnRQbHVnaW5VdGlscy5zZXRDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkIFwiICtcbiAgICAgICAgICAgIFwibW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLlwiXG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IHZvaWQgMDtcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnJcbiAgICAgID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoXG4gICAgICA6IGRpc3BhdGNoTGlzdGVuZXJzXG4gICAgICAgID8gMVxuICAgICAgICA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnJcbiAgICAgID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoXG4gICAgICA6IGRpc3BhdGNoSW5zdGFuY2VzXG4gICAgICAgID8gMVxuICAgICAgICA6IDA7XG5cbiAgICAhKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbilcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcIkV2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC5cIilcbiAgICAgIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBcInVua25vd24tZXZlbnRcIjtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKFxuICAgICAgICBldmVudCxcbiAgICAgICAgc2ltdWxhdGVkLFxuICAgICAgICBkaXNwYXRjaExpc3RlbmVyc1tpXSxcbiAgICAgICAgZGlzcGF0Y2hJbnN0YW5jZXNbaV1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcywgYnV0IHN0b3BzXG4gKiBhdCB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHJldHVybmluZyB0cnVlLCBhbmQgcmV0dXJucyB0aGF0IGlkLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJuc1xuICogdHJ1ZSwgb3IgbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZSA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAgaW52YXJpYW50KFxuICAgICFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpLFxuICAgIFwiZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC5cIlxuICApO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lclxuICAgID8gZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKVxuICAgIDogbnVsbDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50KSA6IG51bGw7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICBpbnZhcmlhbnQoXG4gICAgbmV4dCAhPSBudWxsLFxuICAgIFwiYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXCJcbiAgKTtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbihldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiAoXG4gICAgdGFnID09PSBcImJ1dHRvblwiIHx8XG4gICAgdGFnID09PSBcImlucHV0XCIgfHxcbiAgICB0YWcgPT09IFwic2VsZWN0XCIgfHxcbiAgICB0YWcgPT09IFwidGV4dGFyZWFcIlxuICApO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwib25DbGlja1wiOlxuICAgIGNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6XG4gICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VEb3duXCI6XG4gICAgY2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlTW92ZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpcbiAgICBjYXNlIFwib25Nb3VzZVVwXCI6XG4gICAgY2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaW52YXJpYW50KFxuICAgICFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcIkV4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuXCIsXG4gICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICB0eXBlb2YgbGlzdGVuZXJcbiAgKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKFxuICB0b3BMZXZlbFR5cGUsXG4gIHRhcmdldEluc3QsXG4gIG5hdGl2ZUV2ZW50LFxuICBuYXRpdmVFdmVudFRhcmdldFxuKSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRhcmdldEluc3QsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgKTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudHMgIT09IG51bGwpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxuXG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcblxuICBpZiAoIXByb2Nlc3NpbmdFdmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChcbiAgICAgIHByb2Nlc3NpbmdFdmVudFF1ZXVlLFxuICAgICAgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQoXG4gICAgICBwcm9jZXNzaW5nRXZlbnRRdWV1ZSxcbiAgICAgIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsXG4gICAgKTtcbiAgfVxuICBpbnZhcmlhbnQoXG4gICAgIWV2ZW50UXVldWUsXG4gICAgXCJwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgXCIgK1xuICAgICAgXCJhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLlwiXG4gICk7XG4gIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICByZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxuZnVuY3Rpb24gcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChcbiAgdG9wTGV2ZWxUeXBlLFxuICB0YXJnZXRJbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgbmF0aXZlRXZlbnRUYXJnZXRcbikge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyhcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldFxuICApO1xuICBydW5FdmVudHNJbkJhdGNoKGV2ZW50cywgZmFsc2UpO1xufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIEZ1bmN0aW9uQ29tcG9uZW50TGF6eSA9IDE7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAyO1xudmFyIENsYXNzQ29tcG9uZW50TGF6eSA9IDM7XG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDQ7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb24gb3IgY2xhc3NcbnZhciBIb3N0Um9vdCA9IDU7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA2OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA3O1xudmFyIEhvc3RUZXh0ID0gODtcbnZhciBGcmFnbWVudCA9IDk7XG52YXIgTW9kZSA9IDEwO1xudmFyIENvbnRleHRDb25zdW1lciA9IDExO1xudmFyIENvbnRleHRQcm92aWRlciA9IDEyO1xudmFyIEZvcndhcmRSZWYgPSAxMztcbnZhciBGb3J3YXJkUmVmTGF6eSA9IDE0O1xudmFyIFByb2ZpbGVyID0gMTU7XG52YXIgUGxhY2Vob2xkZXJDb21wb25lbnQgPSAxNjtcbnZhciBQdXJlQ29tcG9uZW50ID0gMTc7XG52YXIgUHVyZUNvbXBvbmVudExhenkgPSAxODtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB3aGlsZSAoaW5zdEIpIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpID0gdm9pZCAwO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDsgKSB7XG4gICAgZm4ocGF0aFtpXSwgXCJjYXB0dXJlZFwiLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgXCJidWJibGVkXCIsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9XG4gICAgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICAhaW5zdFxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwiRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsXCIpXG4gICAgICA6IHZvaWQgMDtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oXG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsXG4gICAgICBsaXN0ZW5lclxuICAgICk7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IGdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhcbiAgICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLFxuICAgICAgICBsaXN0ZW5lclxuICAgICAgKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG4vKiBlc2xpbnQgdmFsaWQtdHlwZW9mOiAwICovXG5cbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoXG4gIGRpc3BhdGNoQ29uZmlnLFxuICB0YXJnZXRJbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgbmF0aXZlRXZlbnRUYXJnZXRcbikge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICAgIGRlbGV0ZSB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZDtcbiAgICBkZWxldGUgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZDtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJ0YXJnZXRcIikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPVxuICAgIG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbFxuICAgICAgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5PYmplY3QuYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09IFwidW5rbm93blwiKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSBcInVua25vd25cIikge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHRoaXMuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgICB0aGlzLl9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBcIm5hdGl2ZUV2ZW50XCIsXG4gICAgICAgIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oXCJuYXRpdmVFdmVudFwiLCBudWxsKVxuICAgICAgKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJpc0RlZmF1bHRQcmV2ZW50ZWRcIixcbiAgICAgICAgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihcbiAgICAgICAgICBcImlzRGVmYXVsdFByZXZlbnRlZFwiLFxuICAgICAgICAgIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBcImlzUHJvcGFnYXRpb25TdG9wcGVkXCIsXG4gICAgICAgIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oXG4gICAgICAgICAgXCJpc1Byb3BhZ2F0aW9uU3RvcHBlZFwiLFxuICAgICAgICAgIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICB0aGlzLFxuICAgICAgICBcInByZXZlbnREZWZhdWx0XCIsXG4gICAgICAgIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oXCJwcmV2ZW50RGVmYXVsdFwiLCBmdW5jdGlvbigpIHt9KVxuICAgICAgKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJzdG9wUHJvcGFnYXRpb25cIixcbiAgICAgICAgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihcInN0b3BQcm9wYWdhdGlvblwiLCBmdW5jdGlvbigpIHt9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqL1xuU3ludGhldGljRXZlbnQuZXh0ZW5kID0gZnVuY3Rpb24oSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbigpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgZnVuY3Rpb24gQ2xhc3MoKSB7XG4gICAgcmV0dXJuIFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gT2JqZWN0LmFzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcblxuICByZXR1cm4gQ2xhc3M7XG59O1xuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gXCJmdW5jdGlvblwiO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldCQkMVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/IFwic2V0dGluZyB0aGUgbWV0aG9kXCIgOiBcInNldHRpbmcgdGhlIHByb3BlcnR5XCI7XG4gICAgd2FybihhY3Rpb24sIFwiVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wXCIpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyBcImFjY2Vzc2luZyB0aGUgbWV0aG9kXCIgOiBcImFjY2Vzc2luZyB0aGUgcHJvcGVydHlcIjtcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvblxuICAgICAgPyBcIlRoaXMgaXMgYSBuby1vcCBmdW5jdGlvblwiXG4gICAgICA6IFwiVGhpcyBpcyBzZXQgdG8gbnVsbFwiO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICAhd2FybmluZ0NvbmRpdGlvblxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgK1xuICAgICAgICAgICAgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuIFwiICtcbiAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIixcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIGRpc3BhdGNoQ29uZmlnLFxuICAgICAgdGFyZ2V0SW5zdCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgbmF0aXZlSW5zdFxuICAgICk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihcbiAgICBkaXNwYXRjaENvbmZpZyxcbiAgICB0YXJnZXRJbnN0LFxuICAgIG5hdGl2ZUV2ZW50LFxuICAgIG5hdGl2ZUluc3RcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaW52YXJpYW50KFxuICAgIGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcixcbiAgICBcIlRyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuXCJcbiAgKTtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbi8qKlxuICogYHRvdWNoSGlzdG9yeWAgaXNuJ3QgYWN0dWFsbHkgb24gdGhlIG5hdGl2ZSBldmVudCwgYnV0IHB1dHRpbmcgaXQgaW4gdGhlXG4gKiBpbnRlcmZhY2Ugd2lsbCBlbnN1cmUgdGhhdCBpdCBpcyBjbGVhbmVkIHVwIHdoZW4gcG9vbGVkL2Rlc3Ryb3llZC4gVGhlXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIHdpbGwgcG9wdWxhdGUgaXQgYXBwcm9wcmlhdGVseS5cbiAqL1xudmFyIFJlc3BvbmRlclN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgdG91Y2hIaXN0b3J5OiBmdW5jdGlvbihuYXRpdmVFdmVudCkge1xuICAgIHJldHVybiBudWxsOyAvLyBBY3R1YWxseSBkb2Vzbid0IGV2ZW4gbG9vayBhdCB0aGUgbmF0aXZlIGV2ZW50LlxuICB9XG59KTtcblxudmFyIFRPUF9UT1VDSF9TVEFSVCA9IFwidG9wVG91Y2hTdGFydFwiO1xudmFyIFRPUF9UT1VDSF9NT1ZFID0gXCJ0b3BUb3VjaE1vdmVcIjtcbnZhciBUT1BfVE9VQ0hfRU5EID0gXCJ0b3BUb3VjaEVuZFwiO1xudmFyIFRPUF9UT1VDSF9DQU5DRUwgPSBcInRvcFRvdWNoQ2FuY2VsXCI7XG52YXIgVE9QX1NDUk9MTCA9IFwidG9wU2Nyb2xsXCI7XG52YXIgVE9QX1NFTEVDVElPTl9DSEFOR0UgPSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiO1xuXG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfVE9VQ0hfU1RBUlQ7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gVE9QX1RPVUNIX01PVkU7XG59XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSBUT1BfVE9VQ0hfRU5EIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1RPVUNIX0NBTkNFTDtcbn1cblxudmFyIHN0YXJ0RGVwZW5kZW5jaWVzID0gW1RPUF9UT1VDSF9TVEFSVF07XG52YXIgbW92ZURlcGVuZGVuY2llcyA9IFtUT1BfVE9VQ0hfTU9WRV07XG52YXIgZW5kRGVwZW5kZW5jaWVzID0gW1RPUF9UT1VDSF9DQU5DRUwsIFRPUF9UT1VDSF9FTkRdO1xuXG4vKipcbiAqIFRyYWNrcyB0aGUgcG9zaXRpb24gYW5kIHRpbWUgb2YgZWFjaCBhY3RpdmUgdG91Y2ggYnkgYHRvdWNoLmlkZW50aWZpZXJgLiBXZVxuICogc2hvdWxkIHR5cGljYWxseSBvbmx5IHNlZSBJRHMgaW4gdGhlIHJhbmdlIG9mIDEtMjAgYmVjYXVzZSBJRHMgZ2V0IHJlY3ljbGVkXG4gKiB3aGVuIHRvdWNoZXMgZW5kIGFuZCBzdGFydCBhZ2Fpbi5cbiAqL1xuXG52YXIgTUFYX1RPVUNIX0JBTksgPSAyMDtcbnZhciB0b3VjaEJhbmsgPSBbXTtcbnZhciB0b3VjaEhpc3RvcnkgPSB7XG4gIHRvdWNoQmFuazogdG91Y2hCYW5rLFxuICBudW1iZXJBY3RpdmVUb3VjaGVzOiAwLFxuICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSBhY3RpdmUgdG91Y2gsIHdlIHJlbWVtYmVyIGl0cyBsb2NhdGlvbi4gVGhpcyBwcmV2ZW50c1xuICAvLyB1cyBoYXZpbmcgdG8gbG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgdG91Y2hlcyBhbGwgdGhlIHRpbWUgaW4gdGhlIG1vc3RcbiAgLy8gY29tbW9uIGNhc2UuXG4gIGluZGV4T2ZTaW5nbGVBY3RpdmVUb3VjaDogLTEsXG4gIG1vc3RSZWNlbnRUaW1lU3RhbXA6IDBcbn07XG5cbmZ1bmN0aW9uIHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKSB7XG4gIC8vIFRoZSBsZWdhY3kgaW50ZXJuYWwgaW1wbGVtZW50YXRpb24gcHJvdmlkZXMgXCJ0aW1lU3RhbXBcIiwgd2hpY2ggaGFzIGJlZW5cbiAgLy8gcmVuYW1lZCB0byBcInRpbWVzdGFtcFwiLiBMZXQgYm90aCB3b3JrIGZvciBub3cgd2hpbGUgd2UgaXJvbiBpdCBvdXRcbiAgLy8gVE9ETyAoZXZ2KTogcmVuYW1lIHRpbWVTdGFtcCB0byB0aW1lc3RhbXAgaW4gaW50ZXJuYWwgY29kZVxuICByZXR1cm4gdG91Y2gudGltZVN0YW1wIHx8IHRvdWNoLnRpbWVzdGFtcDtcbn1cblxuLyoqXG4gKiBUT0RPOiBJbnN0ZWFkIG9mIG1ha2luZyBnZXN0dXJlcyByZWNvbXB1dGUgZmlsdGVyZWQgdmVsb2NpdHksIHdlIGNvdWxkXG4gKiBpbmNsdWRlIGEgYnVpbHQgaW4gdmVsb2NpdHkgY29tcHV0YXRpb24gdGhhdCBjYW4gYmUgcmV1c2VkIGdsb2JhbGx5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVUb3VjaFJlY29yZCh0b3VjaCkge1xuICByZXR1cm4ge1xuICAgIHRvdWNoQWN0aXZlOiB0cnVlLFxuICAgIHN0YXJ0UGFnZVg6IHRvdWNoLnBhZ2VYLFxuICAgIHN0YXJ0UGFnZVk6IHRvdWNoLnBhZ2VZLFxuICAgIHN0YXJ0VGltZVN0YW1wOiB0aW1lc3RhbXBGb3JUb3VjaCh0b3VjaCksXG4gICAgY3VycmVudFBhZ2VYOiB0b3VjaC5wYWdlWCxcbiAgICBjdXJyZW50UGFnZVk6IHRvdWNoLnBhZ2VZLFxuICAgIGN1cnJlbnRUaW1lU3RhbXA6IHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKSxcbiAgICBwcmV2aW91c1BhZ2VYOiB0b3VjaC5wYWdlWCxcbiAgICBwcmV2aW91c1BhZ2VZOiB0b3VjaC5wYWdlWSxcbiAgICBwcmV2aW91c1RpbWVTdGFtcDogdGltZXN0YW1wRm9yVG91Y2godG91Y2gpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0VG91Y2hSZWNvcmQodG91Y2hSZWNvcmQsIHRvdWNoKSB7XG4gIHRvdWNoUmVjb3JkLnRvdWNoQWN0aXZlID0gdHJ1ZTtcbiAgdG91Y2hSZWNvcmQuc3RhcnRQYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICB0b3VjaFJlY29yZC5zdGFydFBhZ2VZID0gdG91Y2gucGFnZVk7XG4gIHRvdWNoUmVjb3JkLnN0YXJ0VGltZVN0YW1wID0gdGltZXN0YW1wRm9yVG91Y2godG91Y2gpO1xuICB0b3VjaFJlY29yZC5jdXJyZW50UGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgdG91Y2hSZWNvcmQuY3VycmVudFBhZ2VZID0gdG91Y2gucGFnZVk7XG4gIHRvdWNoUmVjb3JkLmN1cnJlbnRUaW1lU3RhbXAgPSB0aW1lc3RhbXBGb3JUb3VjaCh0b3VjaCk7XG4gIHRvdWNoUmVjb3JkLnByZXZpb3VzUGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgdG91Y2hSZWNvcmQucHJldmlvdXNQYWdlWSA9IHRvdWNoLnBhZ2VZO1xuICB0b3VjaFJlY29yZC5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hJZGVudGlmaWVyKF9yZWYpIHtcbiAgdmFyIGlkZW50aWZpZXIgPSBfcmVmLmlkZW50aWZpZXI7XG5cbiAgaW52YXJpYW50KGlkZW50aWZpZXIgIT0gbnVsbCwgXCJUb3VjaCBvYmplY3QgaXMgbWlzc2luZyBpZGVudGlmaWVyLlwiKTtcbiAge1xuICAgICEoaWRlbnRpZmllciA8PSBNQVhfVE9VQ0hfQkFOSylcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiVG91Y2ggaWRlbnRpZmllciAlcyBpcyBncmVhdGVyIHRoYW4gbWF4aW11bSBzdXBwb3J0ZWQgJXMgd2hpY2ggY2F1c2VzIFwiICtcbiAgICAgICAgICAgIFwicGVyZm9ybWFuY2UgaXNzdWVzIGJhY2tmaWxsaW5nIGFycmF5IGxvY2F0aW9ucyBmb3IgYWxsIG9mIHRoZSBpbmRpY2VzLlwiLFxuICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgTUFYX1RPVUNIX0JBTktcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXI7XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoU3RhcnQodG91Y2gpIHtcbiAgdmFyIGlkZW50aWZpZXIgPSBnZXRUb3VjaElkZW50aWZpZXIodG91Y2gpO1xuICB2YXIgdG91Y2hSZWNvcmQgPSB0b3VjaEJhbmtbaWRlbnRpZmllcl07XG4gIGlmICh0b3VjaFJlY29yZCkge1xuICAgIHJlc2V0VG91Y2hSZWNvcmQodG91Y2hSZWNvcmQsIHRvdWNoKTtcbiAgfSBlbHNlIHtcbiAgICB0b3VjaEJhbmtbaWRlbnRpZmllcl0gPSBjcmVhdGVUb3VjaFJlY29yZCh0b3VjaCk7XG4gIH1cbiAgdG91Y2hIaXN0b3J5Lm1vc3RSZWNlbnRUaW1lU3RhbXAgPSB0aW1lc3RhbXBGb3JUb3VjaCh0b3VjaCk7XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoTW92ZSh0b3VjaCkge1xuICB2YXIgdG91Y2hSZWNvcmQgPSB0b3VjaEJhbmtbZ2V0VG91Y2hJZGVudGlmaWVyKHRvdWNoKV07XG4gIGlmICh0b3VjaFJlY29yZCkge1xuICAgIHRvdWNoUmVjb3JkLnRvdWNoQWN0aXZlID0gdHJ1ZTtcbiAgICB0b3VjaFJlY29yZC5wcmV2aW91c1BhZ2VYID0gdG91Y2hSZWNvcmQuY3VycmVudFBhZ2VYO1xuICAgIHRvdWNoUmVjb3JkLnByZXZpb3VzUGFnZVkgPSB0b3VjaFJlY29yZC5jdXJyZW50UGFnZVk7XG4gICAgdG91Y2hSZWNvcmQucHJldmlvdXNUaW1lU3RhbXAgPSB0b3VjaFJlY29yZC5jdXJyZW50VGltZVN0YW1wO1xuICAgIHRvdWNoUmVjb3JkLmN1cnJlbnRQYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgIHRvdWNoUmVjb3JkLmN1cnJlbnRQYWdlWSA9IHRvdWNoLnBhZ2VZO1xuICAgIHRvdWNoUmVjb3JkLmN1cnJlbnRUaW1lU3RhbXAgPSB0aW1lc3RhbXBGb3JUb3VjaCh0b3VjaCk7XG4gICAgdG91Y2hIaXN0b3J5Lm1vc3RSZWNlbnRUaW1lU3RhbXAgPSB0aW1lc3RhbXBGb3JUb3VjaCh0b3VjaCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiQ2Fubm90IHJlY29yZCB0b3VjaCBtb3ZlIHdpdGhvdXQgYSB0b3VjaCBzdGFydC5cXG5cIiArIFwiVG91Y2ggTW92ZTogJXNcXG5cIixcbiAgICAgIFwiVG91Y2ggQmFuazogJXNcIixcbiAgICAgIHByaW50VG91Y2godG91Y2gpLFxuICAgICAgcHJpbnRUb3VjaEJhbmsoKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hFbmQodG91Y2gpIHtcbiAgdmFyIHRvdWNoUmVjb3JkID0gdG91Y2hCYW5rW2dldFRvdWNoSWRlbnRpZmllcih0b3VjaCldO1xuICBpZiAodG91Y2hSZWNvcmQpIHtcbiAgICB0b3VjaFJlY29yZC50b3VjaEFjdGl2ZSA9IGZhbHNlO1xuICAgIHRvdWNoUmVjb3JkLnByZXZpb3VzUGFnZVggPSB0b3VjaFJlY29yZC5jdXJyZW50UGFnZVg7XG4gICAgdG91Y2hSZWNvcmQucHJldmlvdXNQYWdlWSA9IHRvdWNoUmVjb3JkLmN1cnJlbnRQYWdlWTtcbiAgICB0b3VjaFJlY29yZC5wcmV2aW91c1RpbWVTdGFtcCA9IHRvdWNoUmVjb3JkLmN1cnJlbnRUaW1lU3RhbXA7XG4gICAgdG91Y2hSZWNvcmQuY3VycmVudFBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgdG91Y2hSZWNvcmQuY3VycmVudFBhZ2VZID0gdG91Y2gucGFnZVk7XG4gICAgdG91Y2hSZWNvcmQuY3VycmVudFRpbWVTdGFtcCA9IHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKTtcbiAgICB0b3VjaEhpc3RvcnkubW9zdFJlY2VudFRpbWVTdGFtcCA9IHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJDYW5ub3QgcmVjb3JkIHRvdWNoIGVuZCB3aXRob3V0IGEgdG91Y2ggc3RhcnQuXFxuXCIgKyBcIlRvdWNoIEVuZDogJXNcXG5cIixcbiAgICAgIFwiVG91Y2ggQmFuazogJXNcIixcbiAgICAgIHByaW50VG91Y2godG91Y2gpLFxuICAgICAgcHJpbnRUb3VjaEJhbmsoKVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRUb3VjaCh0b3VjaCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGlkZW50aWZpZXI6IHRvdWNoLmlkZW50aWZpZXIsXG4gICAgcGFnZVg6IHRvdWNoLnBhZ2VYLFxuICAgIHBhZ2VZOiB0b3VjaC5wYWdlWSxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcEZvclRvdWNoKHRvdWNoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJpbnRUb3VjaEJhbmsoKSB7XG4gIHZhciBwcmludGVkID0gSlNPTi5zdHJpbmdpZnkodG91Y2hCYW5rLnNsaWNlKDAsIE1BWF9UT1VDSF9CQU5LKSk7XG4gIGlmICh0b3VjaEJhbmsubGVuZ3RoID4gTUFYX1RPVUNIX0JBTkspIHtcbiAgICBwcmludGVkICs9IFwiIChvcmlnaW5hbCBzaXplOiBcIiArIHRvdWNoQmFuay5sZW5ndGggKyBcIilcIjtcbiAgfVxuICByZXR1cm4gcHJpbnRlZDtcbn1cblxudmFyIFJlc3BvbmRlclRvdWNoSGlzdG9yeVN0b3JlID0ge1xuICByZWNvcmRUb3VjaFRyYWNrOiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpKSB7XG4gICAgICBuYXRpdmVFdmVudC5jaGFuZ2VkVG91Y2hlcy5mb3JFYWNoKHJlY29yZFRvdWNoTW92ZSk7XG4gICAgfSBlbHNlIGlmIChpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIG5hdGl2ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLmZvckVhY2gocmVjb3JkVG91Y2hTdGFydCk7XG4gICAgICB0b3VjaEhpc3RvcnkubnVtYmVyQWN0aXZlVG91Y2hlcyA9IG5hdGl2ZUV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuICAgICAgaWYgKHRvdWNoSGlzdG9yeS5udW1iZXJBY3RpdmVUb3VjaGVzID09PSAxKSB7XG4gICAgICAgIHRvdWNoSGlzdG9yeS5pbmRleE9mU2luZ2xlQWN0aXZlVG91Y2ggPVxuICAgICAgICAgIG5hdGl2ZUV2ZW50LnRvdWNoZXNbMF0uaWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRW5kaXNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIG5hdGl2ZUV2ZW50LmNoYW5nZWRUb3VjaGVzLmZvckVhY2gocmVjb3JkVG91Y2hFbmQpO1xuICAgICAgdG91Y2hIaXN0b3J5Lm51bWJlckFjdGl2ZVRvdWNoZXMgPSBuYXRpdmVFdmVudC50b3VjaGVzLmxlbmd0aDtcbiAgICAgIGlmICh0b3VjaEhpc3RvcnkubnVtYmVyQWN0aXZlVG91Y2hlcyA9PT0gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoQmFuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB0b3VjaFRyYWNrVG9DaGVjayA9IHRvdWNoQmFua1tpXTtcbiAgICAgICAgICBpZiAodG91Y2hUcmFja1RvQ2hlY2sgIT0gbnVsbCAmJiB0b3VjaFRyYWNrVG9DaGVjay50b3VjaEFjdGl2ZSkge1xuICAgICAgICAgICAgdG91Y2hIaXN0b3J5LmluZGV4T2ZTaW5nbGVBY3RpdmVUb3VjaCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIHZhciBhY3RpdmVSZWNvcmQgPSB0b3VjaEJhbmtbdG91Y2hIaXN0b3J5LmluZGV4T2ZTaW5nbGVBY3RpdmVUb3VjaF07XG4gICAgICAgICAgIShhY3RpdmVSZWNvcmQgIT0gbnVsbCAmJiBhY3RpdmVSZWNvcmQudG91Y2hBY3RpdmUpXG4gICAgICAgICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW5ub3QgZmluZCBzaW5nbGUgYWN0aXZlIHRvdWNoLlwiKVxuICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdG91Y2hIaXN0b3J5OiB0b3VjaEhpc3Rvcnlcbn07XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShjdXJyZW50LCBuZXh0KSB7XG4gIGludmFyaWFudChcbiAgICBuZXh0ICE9IG51bGwsXG4gICAgXCJhY2N1bXVsYXRlKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3QgYmUgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLlwiXG4gICk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICByZXR1cm4gY3VycmVudC5jb25jYXQobmV4dCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBJbnN0YW5jZSBvZiBlbGVtZW50IHRoYXQgc2hvdWxkIHJlc3BvbmQgdG8gdG91Y2gvbW92ZSB0eXBlcyBvZiBpbnRlcmFjdGlvbnMsXG4gKiBhcyBpbmRpY2F0ZWQgZXhwbGljaXRseSBieSByZWxldmFudCBjYWxsYmFja3MuXG4gKi9cbnZhciByZXNwb25kZXJJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBDb3VudCBvZiBjdXJyZW50IHRvdWNoZXMuIEEgdGV4dElucHV0IHNob3VsZCBiZWNvbWUgcmVzcG9uZGVyIGlmZiB0aGVcbiAqIHNlbGVjdGlvbiBjaGFuZ2VzIHdoaWxlIHRoZXJlIGlzIGEgdG91Y2ggb24gdGhlIHNjcmVlbi5cbiAqL1xudmFyIHRyYWNrZWRUb3VjaENvdW50ID0gMDtcblxudmFyIGNoYW5nZVJlc3BvbmRlciA9IGZ1bmN0aW9uKG5leHRSZXNwb25kZXJJbnN0LCBibG9ja0hvc3RSZXNwb25kZXIpIHtcbiAgdmFyIG9sZFJlc3BvbmRlckluc3QgPSByZXNwb25kZXJJbnN0O1xuICByZXNwb25kZXJJbnN0ID0gbmV4dFJlc3BvbmRlckluc3Q7XG4gIGlmIChSZXNwb25kZXJFdmVudFBsdWdpbi5HbG9iYWxSZXNwb25kZXJIYW5kbGVyICE9PSBudWxsKSB7XG4gICAgUmVzcG9uZGVyRXZlbnRQbHVnaW4uR2xvYmFsUmVzcG9uZGVySGFuZGxlci5vbkNoYW5nZShcbiAgICAgIG9sZFJlc3BvbmRlckluc3QsXG4gICAgICBuZXh0UmVzcG9uZGVySW5zdCxcbiAgICAgIGJsb2NrSG9zdFJlc3BvbmRlclxuICAgICk7XG4gIH1cbn07XG5cbnZhciBldmVudFR5cGVzJDEgPSB7XG4gIC8qKlxuICAgKiBPbiBhIGB0b3VjaFN0YXJ0YC9gbW91c2VEb3duYCwgaXMgaXQgZGVzaXJlZCB0aGF0IHRoaXMgZWxlbWVudCBiZWNvbWUgdGhlXG4gICAqIHJlc3BvbmRlcj9cbiAgICovXG4gIHN0YXJ0U2hvdWxkU2V0UmVzcG9uZGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IFwib25TdGFydFNob3VsZFNldFJlc3BvbmRlclwiLFxuICAgICAgY2FwdHVyZWQ6IFwib25TdGFydFNob3VsZFNldFJlc3BvbmRlckNhcHR1cmVcIlxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBzdGFydERlcGVuZGVuY2llc1xuICB9LFxuXG4gIC8qKlxuICAgKiBPbiBhIGBzY3JvbGxgLCBpcyBpdCBkZXNpcmVkIHRoYXQgdGhpcyBlbGVtZW50IGJlY29tZSB0aGUgcmVzcG9uZGVyPyBUaGlzXG4gICAqIGlzIHVzdWFsbHkgbm90IG5lZWRlZCwgYnV0IHNob3VsZCBiZSB1c2VkIHRvIHJldHJvYWN0aXZlbHkgaW5mZXIgdGhhdCBhXG4gICAqIGB0b3VjaFN0YXJ0YCBoYWQgb2NjdXJyZWQgZHVyaW5nIG1vbWVudHVtIHNjcm9sbC4gRHVyaW5nIGEgbW9tZW50dW0gc2Nyb2xsLFxuICAgKiBhIHRvdWNoIHN0YXJ0IHdpbGwgYmUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYSBzY3JvbGwgZXZlbnQgaWYgdGhlIHZpZXcgaXNcbiAgICogY3VycmVudGx5IHNjcm9sbGluZy5cbiAgICpcbiAgICogVE9ETzogVGhpcyBzaG91bGRuJ3QgYnViYmxlLlxuICAgKi9cbiAgc2Nyb2xsU2hvdWxkU2V0UmVzcG9uZGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IFwib25TY3JvbGxTaG91bGRTZXRSZXNwb25kZXJcIixcbiAgICAgIGNhcHR1cmVkOiBcIm9uU2Nyb2xsU2hvdWxkU2V0UmVzcG9uZGVyQ2FwdHVyZVwiXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfU0NST0xMXVxuICB9LFxuXG4gIC8qKlxuICAgKiBPbiB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2UsIHNob3VsZCB0aGlzIGVsZW1lbnQgYmVjb21lIHRoZSByZXNwb25kZXI/IFRoaXNcbiAgICogaXMgbmVlZGVkIGZvciB0ZXh0IGlucHV0cyBvciBvdGhlciB2aWV3cyB3aXRoIG5hdGl2ZSBzZWxlY3Rpb24sIHNvIHRoZVxuICAgKiBKUyB2aWV3IGNhbiBjbGFpbSB0aGUgcmVzcG9uZGVyLlxuICAgKlxuICAgKiBUT0RPOiBUaGlzIHNob3VsZG4ndCBidWJibGUuXG4gICAqL1xuICBzZWxlY3Rpb25DaGFuZ2VTaG91bGRTZXRSZXNwb25kZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogXCJvblNlbGVjdGlvbkNoYW5nZVNob3VsZFNldFJlc3BvbmRlclwiLFxuICAgICAgY2FwdHVyZWQ6IFwib25TZWxlY3Rpb25DaGFuZ2VTaG91bGRTZXRSZXNwb25kZXJDYXB0dXJlXCJcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9TRUxFQ1RJT05fQ0hBTkdFXVxuICB9LFxuXG4gIC8qKlxuICAgKiBPbiBhIGB0b3VjaE1vdmVgL2Btb3VzZU1vdmVgLCBpcyBpdCBkZXNpcmVkIHRoYXQgdGhpcyBlbGVtZW50IGJlY29tZSB0aGVcbiAgICogcmVzcG9uZGVyP1xuICAgKi9cbiAgbW92ZVNob3VsZFNldFJlc3BvbmRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBcIm9uTW92ZVNob3VsZFNldFJlc3BvbmRlclwiLFxuICAgICAgY2FwdHVyZWQ6IFwib25Nb3ZlU2hvdWxkU2V0UmVzcG9uZGVyQ2FwdHVyZVwiXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IG1vdmVEZXBlbmRlbmNpZXNcbiAgfSxcblxuICAvKipcbiAgICogRGlyZWN0IHJlc3BvbmRlciBldmVudHMgZGlzcGF0Y2hlZCBkaXJlY3RseSB0byByZXNwb25kZXIuIERvIG5vdCBidWJibGUuXG4gICAqL1xuICByZXNwb25kZXJTdGFydDoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IFwib25SZXNwb25kZXJTdGFydFwiLFxuICAgIGRlcGVuZGVuY2llczogc3RhcnREZXBlbmRlbmNpZXNcbiAgfSxcbiAgcmVzcG9uZGVyTW92ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IFwib25SZXNwb25kZXJNb3ZlXCIsXG4gICAgZGVwZW5kZW5jaWVzOiBtb3ZlRGVwZW5kZW5jaWVzXG4gIH0sXG4gIHJlc3BvbmRlckVuZDoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IFwib25SZXNwb25kZXJFbmRcIixcbiAgICBkZXBlbmRlbmNpZXM6IGVuZERlcGVuZGVuY2llc1xuICB9LFxuICByZXNwb25kZXJSZWxlYXNlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogXCJvblJlc3BvbmRlclJlbGVhc2VcIixcbiAgICBkZXBlbmRlbmNpZXM6IGVuZERlcGVuZGVuY2llc1xuICB9LFxuICByZXNwb25kZXJUZXJtaW5hdGlvblJlcXVlc3Q6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBcIm9uUmVzcG9uZGVyVGVybWluYXRpb25SZXF1ZXN0XCIsXG4gICAgZGVwZW5kZW5jaWVzOiBbXVxuICB9LFxuICByZXNwb25kZXJHcmFudDoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IFwib25SZXNwb25kZXJHcmFudFwiLFxuICAgIGRlcGVuZGVuY2llczogW11cbiAgfSxcbiAgcmVzcG9uZGVyUmVqZWN0OiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogXCJvblJlc3BvbmRlclJlamVjdFwiLFxuICAgIGRlcGVuZGVuY2llczogW11cbiAgfSxcbiAgcmVzcG9uZGVyVGVybWluYXRlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogXCJvblJlc3BvbmRlclRlcm1pbmF0ZVwiLFxuICAgIGRlcGVuZGVuY2llczogW11cbiAgfVxufTtcblxuLyoqXG4gKlxuICogUmVzcG9uZGVyIFN5c3RlbTpcbiAqIC0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAtIEEgZ2xvYmFsLCBzb2xpdGFyeSBcImludGVyYWN0aW9uIGxvY2tcIiBvbiBhIHZpZXcuXG4gKiAtIElmIGEgbm9kZSBiZWNvbWVzIHRoZSByZXNwb25kZXIsIGl0IHNob3VsZCBjb252ZXkgdmlzdWFsIGZlZWRiYWNrXG4gKiAgIGltbWVkaWF0ZWx5IHRvIGluZGljYXRlIHNvLCBlaXRoZXIgYnkgaGlnaGxpZ2h0aW5nIG9yIG1vdmluZyBhY2NvcmRpbmdseS5cbiAqIC0gVG8gYmUgdGhlIHJlc3BvbmRlciBtZWFucywgdGhhdCB0b3VjaGVzIGFyZSBleGNsdXNpdmVseSBpbXBvcnRhbnQgdG8gdGhhdFxuICogICByZXNwb25kZXIgdmlldywgYW5kIG5vIG90aGVyIHZpZXcuXG4gKiAtIFdoaWxlIHRvdWNoZXMgYXJlIHN0aWxsIG9jY3VycmluZywgdGhlIHJlc3BvbmRlciBsb2NrIGNhbiBiZSB0cmFuc2ZlcnJlZCB0b1xuICogICBhIG5ldyB2aWV3LCBidXQgb25seSB0byBpbmNyZWFzaW5nbHkgXCJoaWdoZXJcIiB2aWV3cyAobWVhbmluZyBhbmNlc3RvcnMgb2ZcbiAqICAgdGhlIGN1cnJlbnQgcmVzcG9uZGVyKS5cbiAqXG4gKiBSZXNwb25kZXIgYmVpbmcgZ3JhbnRlZDpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gVG91Y2ggc3RhcnRzLCBtb3ZlcywgYW5kIHNjcm9sbHMgY2FuIGNhdXNlIGFuIElEIHRvIGJlY29tZSB0aGUgcmVzcG9uZGVyLlxuICogLSBXZSBjYXB0dXJlL2J1YmJsZSBgc3RhcnRTaG91bGRTZXRSZXNwb25kZXJgL2Btb3ZlU2hvdWxkU2V0UmVzcG9uZGVyYCB0b1xuICogICB0aGUgXCJhcHByb3ByaWF0ZSBwbGFjZVwiLlxuICogLSBJZiBub3RoaW5nIGlzIGN1cnJlbnRseSB0aGUgcmVzcG9uZGVyLCB0aGUgXCJhcHByb3ByaWF0ZSBwbGFjZVwiIGlzIHRoZVxuICogICBpbml0aWF0aW5nIGV2ZW50J3MgYHRhcmdldElEYC5cbiAqIC0gSWYgc29tZXRoaW5nICppcyogYWxyZWFkeSB0aGUgcmVzcG9uZGVyLCB0aGUgXCJhcHByb3ByaWF0ZSBwbGFjZVwiIGlzIHRoZVxuICogICBmaXJzdCBjb21tb24gYW5jZXN0b3Igb2YgdGhlIGV2ZW50IHRhcmdldCBhbmQgdGhlIGN1cnJlbnQgYHJlc3BvbmRlckluc3RgLlxuICogLSBTb21lIG5lZ290aWF0aW9uIGhhcHBlbnM6IFNlZSB0aGUgdGltaW5nIGRpYWdyYW0gYmVsb3cuXG4gKiAtIFNjcm9sbGVkIHZpZXdzIGF1dG9tYXRpY2FsbHkgYmVjb21lIHJlc3BvbmRlci4gVGhlIHJlYXNvbmluZyBpcyB0aGF0IGFcbiAqICAgcGxhdGZvcm0gc2Nyb2xsIHZpZXcgdGhhdCBpc24ndCBidWlsdCBvbiB0b3Agb2YgdGhlIHJlc3BvbmRlciBzeXN0ZW0gaGFzXG4gKiAgIGJlZ2FuIHNjcm9sbGluZywgYW5kIHRoZSBhY3RpdmUgcmVzcG9uZGVyIG11c3Qgbm93IGJlIG5vdGlmaWVkIHRoYXQgdGhlXG4gKiAgIGludGVyYWN0aW9uIGlzIG5vIGxvbmdlciBsb2NrZWQgdG8gaXQgLSB0aGUgc3lzdGVtIGhhcyB0YWtlbiBvdmVyLlxuICpcbiAqIC0gUmVzcG9uZGVyIGJlaW5nIHJlbGVhc2VkOlxuICogICBBcyBzb29uIGFzIG5vIG1vcmUgdG91Y2hlcyB0aGF0ICpzdGFydGVkKiBpbnNpZGUgb2YgZGVzY2VuZGFudHMgb2YgdGhlXG4gKiAgICpjdXJyZW50KiByZXNwb25kZXJJbnN0LCBhbiBgb25SZXNwb25kZXJSZWxlYXNlYCBldmVudCBpcyBkaXNwYXRjaGVkIHRvIHRoZVxuICogICBjdXJyZW50IHJlc3BvbmRlciwgYW5kIHRoZSByZXNwb25kZXIgbG9jayBpcyByZWxlYXNlZC5cbiAqXG4gKiBUT0RPOlxuICogLSBvbiBcImVuZFwiLCBhIGNhbGxiYWNrIGhvb2sgZm9yIGBvblJlc3BvbmRlckVuZFNob3VsZFJlbWFpblJlc3BvbmRlcmAgdGhhdFxuICogICBkZXRlcm1pbmVzIGlmIHRoZSByZXNwb25kZXIgbG9jayBzaG91bGQgcmVtYWluLlxuICogLSBJZiBhIHZpZXcgc2hvdWxkbid0IFwicmVtYWluXCIgdGhlIHJlc3BvbmRlciwgYW55IGFjdGl2ZSB0b3VjaGVzIHNob3VsZCBieVxuICogICBkZWZhdWx0IGJlIGNvbnNpZGVyZWQgXCJkZWFkXCIgYW5kIGRvIG5vdCBpbmZsdWVuY2UgZnV0dXJlIG5lZ290aWF0aW9ucyBvclxuICogICBidWJibGUgcGF0aHMuIEl0IHNob3VsZCBiZSBhcyBpZiB0aG9zZSB0b3VjaGVzIGRvIG5vdCBleGlzdC5cbiAqIC0tIEZvciBtdWx0aXRvdWNoOiBVc3VhbGx5IGEgdHJhbnNsYXRlLXogd2lsbCBjaG9vc2UgdG8gXCJyZW1haW5cIiByZXNwb25kZXJcbiAqICBhZnRlciBvbmUgb3V0IG9mIG1hbnkgdG91Y2hlcyBlbmRlZC4gRm9yIHRyYW5zbGF0ZS15LCB1c3VhbGx5IHRoZSB2aWV3XG4gKiAgZG9lc24ndCB3aXNoIHRvIFwicmVtYWluXCIgcmVzcG9uZGVyIGFmdGVyIG9uZSBvZiBtYW55IHRvdWNoZXMgZW5kLlxuICogLSBDb25zaWRlciBidWlsZGluZyB0aGlzIG9uIHRvcCBvZiBhIGBzdG9wUHJvcGFnYXRpb25gIG1vZGVsIHNpbWlsYXIgdG9cbiAqICAgYFczQ2AgZXZlbnRzLlxuICogLSBFbnN1cmUgdGhhdCBgb25SZXNwb25kZXJUZXJtaW5hdGVgIGlzIGNhbGxlZCBvbiB0b3VjaCBjYW5jZWxzLCB3aGV0aGVyIG9yXG4gKiAgIG5vdCBgb25SZXNwb25kZXJUZXJtaW5hdGlvblJlcXVlc3RgIHJldHVybnMgYHRydWVgIG9yIGBmYWxzZWAuXG4gKlxuICovXG5cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmVnb3RpYXRpb24gUGVyZm9ybWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgICAgXFxcblByb2Nlc3MgbG93IGxldmVsIGV2ZW50cyB0byAgICArICAgICBDdXJyZW50IFJlc3BvbmRlciAgICAgICsgICB3YW50c1Jlc3BvbmRlcklEXG5kZXRlcm1pbmUgd2hvIHRvIHBlcmZvcm0gbmVnb3QtfCAgIChpZiBhbnkgZXhpc3RzIGF0IGFsbCkgICB8XG5pYXRpb24vdHJhbnNpdGlvbiAgICAgICAgICAgICAgfCBPdGhlcndpc2UganVzdCBwYXNzIHRocm91Z2h8XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tK1xuQnViYmxlIHRvIGZpbmQgZmlyc3QgSUQgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxudG8gcmV0dXJuIHRydWU6d2FudHNSZXNwb25kZXJJRHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICArLS0tLS0tLS0tLS0tLSsgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICB8IG9uVG91Y2hTdGFydHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICArLS0tLS0tKy0tLS0tLSsgICAgIG5vbmUgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAgICAgICAgfCAgICAgICAgICAgIHJldHVybnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuKy0tLS0tLS0tLS0tdi0tLS0tLS0tLS0tLS0rdHJ1ZXwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfFxufG9uU3RhcnRTaG91bGRTZXRSZXNwb25kZXJ8LS0tLS0+fG9uUmVzcG9uZGVyU3RhcnQgKGN1cikgIHw8LS0tLS0tLS0tLS0rXG4rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSsgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8ICAgICAgICAgIHxcbiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKy0tLS0tLS0tKy0tLS0tLS0rXG4gICAgICAgICAgICB8IHJldHVybmVkIHRydWUgZm9yfCAgICAgICBmYWxzZTpSRUpFQ1QgKy0tLS0tLS0tPnxvblJlc3BvbmRlclJlamVjdFxuICAgICAgICAgICAgfCB3YW50c1Jlc3BvbmRlcklEIHwgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgIHwgKG5vdyBhdHRlbXB0ICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0rIHxcbiAgICAgICAgICAgIHwgIGhhbmRvZmYpICAgICAgICB8IHwgICBvblJlc3BvbmRlciAgICAgICAgICB8IHxcbiAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tPnwgICAgICBUZXJtaW5hdGlvblJlcXVlc3R8IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgIHRydWU6R1JBTlQgKy0tLS0tLS0tPnxvblJlc3BvbmRlckdyYW50fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCArLS0tLS0tLS0rLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgfCAgIG9uUmVzcG9uZGVyVGVybWluYXRlIHw8LS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tKyB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLT58b25SZXNwb25kZXJTdGFydHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0rXG5CdWJibGUgdG8gZmluZCBmaXJzdCBJRCAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG50byByZXR1cm4gdHJ1ZTp3YW50c1Jlc3BvbmRlcklEfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICstLS0tLS0tLS0tLS0tKyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgIHwgb25Ub3VjaE1vdmUgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICstLS0tLS0rLS0tLS0tKyAgICAgbm9uZSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICB8ICAgICAgICAgICAgcmV0dXJufCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4rLS0tLS0tLS0tLS12LS0tLS0tLS0tLS0tLSt0cnVlfCArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyB8XG58b25Nb3ZlU2hvdWxkU2V0UmVzcG9uZGVyIHwtLS0tLT58b25SZXNwb25kZXJNb3ZlIChjdXIpICAgfDwtLS0tLS0tLS0tLStcbistLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tKyAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHwgICAgICAgICAgfFxuICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCArLS0tLS0tLS0rLS0tLS0tLStcbiAgICAgICAgICAgIHwgcmV0dXJuZWQgdHJ1ZSBmb3J8ICAgICAgIGZhbHNlOlJFSkVDVCArLS0tLS0tLS0+fG9uUmVzcG9uZGVyUmVqZWN8XG4gICAgICAgICAgICB8IHdhbnRzUmVzcG9uZGVySUQgfCAgICAgICAgICAgICAgICAgICAgfCAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tK1xuICAgICAgICAgICAgfCAobm93IGF0dGVtcHQgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLSsgfFxuICAgICAgICAgICAgfCAgaGFuZG9mZikgICAgICAgIHwgfCAgIG9uUmVzcG9uZGVyICAgICAgICAgIHwgfFxuICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0+fCAgICAgIFRlcm1pbmF0aW9uUmVxdWVzdHwgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLSsgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgdHJ1ZTpHUkFOVCArLS0tLS0tLS0+fG9uUmVzcG9uZGVyR3JhbnR8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLSstLS0tLS0tK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgfCAgICAgICAgICB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB8ICAgb25SZXNwb25kZXJUZXJtaW5hdGUgfDwtLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICB8ICAgICAgIHwgKy0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tPnxvblJlc3BvbmRlck1vdmUgfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCArLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgIFNvbWUgYWN0aXZlIHRvdWNoIHN0YXJ0ZWR8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgIGluc2lkZSBjdXJyZW50IHJlc3BvbmRlciB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPnwgICAgICBvblJlc3BvbmRlckVuZCAgICB8IHxcbiAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgKy0tLSstLS0tLS0tLS0rICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgfCBvblRvdWNoRW5kICB8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgKy0tLSstLS0tLS0tLS0rICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPnwgICAgIG9uUmVzcG9uZGVyRW5kICAgICB8IHxcbiAgICAgIE5vIGFjdGl2ZSB0b3VjaGVzIHN0YXJ0ZWR8ICstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0rIHxcbiAgICAgIGluc2lkZSBjdXJyZW50IHJlc3BvbmRlciB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIHYgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHwgICAgb25SZXNwb25kZXJSZWxlYXNlICB8IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgKi9cblxuLyoqXG4gKiBBIG5vdGUgYWJvdXQgZXZlbnQgb3JkZXJpbmcgaW4gdGhlIGBFdmVudFBsdWdpbkh1YmAuXG4gKlxuICogU3VwcG9zZSBwbHVnaW5zIGFyZSBpbmplY3RlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICpcbiAqIGBbUiwgUywgQ11gXG4gKlxuICogVG8gaGVscCBpbGx1c3RyYXRlIHRoZSBleGFtcGxlLCBhc3N1bWUgYFNgIGlzIGBTaW1wbGVFdmVudFBsdWdpbmAgKGZvclxuICogYG9uQ2xpY2tgIGV0YykgYW5kIGBSYCBpcyBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gLlxuICpcbiAqIFwiRGVmZXJyZWQtRGlzcGF0Y2hlZCBFdmVudHNcIjpcbiAqXG4gKiAtIFRoZSBjdXJyZW50IGV2ZW50IHBsdWdpbiBzeXN0ZW0gd2lsbCB0cmF2ZXJzZSB0aGUgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLFxuICogICBpbiBvcmRlciwgYW5kIGV4dHJhY3QgZXZlbnRzIGJ5IGNvbGxlY3RpbmcgdGhlIHBsdWdpbidzIHJldHVybiB2YWx1ZSBvZlxuICogICBgZXh0cmFjdEV2ZW50cygpYC5cbiAqIC0gVGhlc2UgZXZlbnRzIHRoYXQgYXJlIHJldHVybmVkIGZyb20gYGV4dHJhY3RFdmVudHNgIGFyZSBcImRlZmVycmVkXG4gKiAgIGRpc3BhdGNoZWQgZXZlbnRzXCIuXG4gKiAtIFdoZW4gcmV0dXJuZWQgZnJvbSBgZXh0cmFjdEV2ZW50c2AsIGRlZmVycmVkLWRpc3BhdGNoZWQgZXZlbnRzIGNvbnRhaW4gYW5cbiAqICAgXCJhY2N1bXVsYXRpb25cIiBvZiBkZWZlcnJlZCBkaXNwYXRjaGVzLlxuICogLSBUaGVzZSBkZWZlcnJlZCBkaXNwYXRjaGVzIGFyZSBhY2N1bXVsYXRlZC9jb2xsZWN0ZWQgYmVmb3JlIHRoZXkgYXJlXG4gKiAgIHJldHVybmVkLCBidXQgcHJvY2Vzc2VkIGF0IGEgbGF0ZXIgdGltZSBieSB0aGUgYEV2ZW50UGx1Z2luSHViYCAoaGVuY2UgdGhlXG4gKiAgIG5hbWUgZGVmZXJyZWQpLlxuICpcbiAqIEluIHRoZSBwcm9jZXNzIG9mIHJldHVybmluZyB0aGVpciBkZWZlcnJlZC1kaXNwYXRjaGVkIGV2ZW50cywgZXZlbnQgcGx1Z2luc1xuICogdGhlbXNlbHZlcyBjYW4gZGlzcGF0Y2ggZXZlbnRzIG9uLWRlbWFuZCB3aXRob3V0IHJldHVybmluZyB0aGVtIGZyb21cbiAqIGBleHRyYWN0RXZlbnRzYC4gUGx1Z2lucyBtaWdodCB3YW50IHRvIGRvIHRoaXMsIHNvIHRoYXQgdGhleSBjYW4gdXNlIGV2ZW50XG4gKiBkaXNwYXRjaGluZyBhcyBhIHRvb2wgdGhhdCBoZWxwcyB0aGVtIGRlY2lkZSB3aGljaCBldmVudHMgc2hvdWxkIGJlIGV4dHJhY3RlZFxuICogaW4gdGhlIGZpcnN0IHBsYWNlLlxuICpcbiAqIFwiT24tRGVtYW5kLURpc3BhdGNoZWQgRXZlbnRzXCI6XG4gKlxuICogLSBPbi1kZW1hbmQtZGlzcGF0Y2hlZCBldmVudHMgYXJlIG5vdCByZXR1cm5lZCBmcm9tIGBleHRyYWN0RXZlbnRzYC5cbiAqIC0gT24tZGVtYW5kLWRpc3BhdGNoZWQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcHJvY2VzcyBvZiByZXR1cm5pbmdcbiAqICAgdGhlIGRlZmVycmVkLWRpc3BhdGNoZWQgZXZlbnRzLlxuICogLSBUaGV5IHNob3VsZCBub3QgaGF2ZSBzaWRlIGVmZmVjdHMuXG4gKiAtIFRoZXkgc2hvdWxkIGJlIGF2b2lkZWQsIGFuZC9vciBldmVudHVhbGx5IGJlIHJlcGxhY2VkIHdpdGggYW5vdGhlclxuICogICBhYnN0cmFjdGlvbiB0aGF0IGFsbG93cyBldmVudCBwbHVnaW5zIHRvIHBlcmZvcm0gbXVsdGlwbGUgXCJyb3VuZHNcIiBvZiBldmVudFxuICogICBleHRyYWN0aW9uLlxuICpcbiAqIFRoZXJlZm9yZSwgdGhlIHNlcXVlbmNlIG9mIGV2ZW50IGRpc3BhdGNoZXMgYmVjb21lczpcbiAqXG4gKiAtIGBSYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBSYCBvbi1kZW1hbmQpXG4gKiAtIGBTYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBTYCBvbi1kZW1hbmQpXG4gKiAtIGBDYHMgb24tZGVtYW5kIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBDYCBvbi1kZW1hbmQpXG4gKiAtIGBSYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKiAtIGBTYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKiAtIGBDYHMgZXh0cmFjdGVkIGV2ZW50cyAoaWYgYW55KSAgIChkaXNwYXRjaGVkIGJ5IGBFdmVudFBsdWdpbkh1YmApXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYFJlc3BvbmRlckV2ZW50UGx1Z2luYDogSWYgdGhlIGBzdGFydFNob3VsZFNldFJlc3BvbmRlcmBcbiAqIG9uLWRlbWFuZCBkaXNwYXRjaCByZXR1cm5zIGB0cnVlYCAoYW5kIHNvbWUgb3RoZXIgZGV0YWlscyBhcmUgc2F0aXNmaWVkKSB0aGVcbiAqIGBvblJlc3BvbmRlckdyYW50YCBkZWZlcnJlZCBkaXNwYXRjaGVkIGV2ZW50IGlzIHJldHVybmVkIGZyb21cbiAqIGBleHRyYWN0RXZlbnRzYC4gVGhlIHNlcXVlbmNlIG9mIGRpc3BhdGNoIGV4ZWN1dGlvbnMgaW4gdGhpcyBjYXNlXG4gKiB3aWxsIGFwcGVhciBhcyBmb2xsb3dzOlxuICpcbiAqIC0gYHN0YXJ0U2hvdWxkU2V0UmVzcG9uZGVyYCAoYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBkaXNwYXRjaGVzIG9uLWRlbWFuZClcbiAqIC0gYHRvdWNoU3RhcnRDYXB0dXJlYCAgICAgICAoYEV2ZW50UGx1Z2luSHViYCBkaXNwYXRjaGVzIGFzIHVzdWFsKVxuICogLSBgdG91Y2hTdGFydGAgICAgICAgICAgICAgIChgRXZlbnRQbHVnaW5IdWJgIGRpc3BhdGNoZXMgYXMgdXN1YWwpXG4gKiAtIGByZXNwb25kZXJHcmFudC9SZWplY3RgICAgKGBFdmVudFBsdWdpbkh1YmAgZGlzcGF0Y2hlcyBhcyB1c3VhbClcbiAqL1xuXG5mdW5jdGlvbiBzZXRSZXNwb25kZXJBbmRFeHRyYWN0VHJhbnNmZXIoXG4gIHRvcExldmVsVHlwZSxcbiAgdGFyZ2V0SW5zdCxcbiAgbmF0aXZlRXZlbnQsXG4gIG5hdGl2ZUV2ZW50VGFyZ2V0XG4pIHtcbiAgdmFyIHNob3VsZFNldEV2ZW50VHlwZSA9IGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKVxuICAgID8gZXZlbnRUeXBlcyQxLnN0YXJ0U2hvdWxkU2V0UmVzcG9uZGVyXG4gICAgOiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKVxuICAgICAgPyBldmVudFR5cGVzJDEubW92ZVNob3VsZFNldFJlc3BvbmRlclxuICAgICAgOiB0b3BMZXZlbFR5cGUgPT09IFRPUF9TRUxFQ1RJT05fQ0hBTkdFXG4gICAgICAgID8gZXZlbnRUeXBlcyQxLnNlbGVjdGlvbkNoYW5nZVNob3VsZFNldFJlc3BvbmRlclxuICAgICAgICA6IGV2ZW50VHlwZXMkMS5zY3JvbGxTaG91bGRTZXRSZXNwb25kZXI7XG5cbiAgLy8gVE9ETzogc3RvcCBvbmUgc2hvcnQgb2YgdGhlIGN1cnJlbnQgcmVzcG9uZGVyLlxuICB2YXIgYnViYmxlU2hvdWxkU2V0RnJvbSA9ICFyZXNwb25kZXJJbnN0XG4gICAgPyB0YXJnZXRJbnN0XG4gICAgOiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihyZXNwb25kZXJJbnN0LCB0YXJnZXRJbnN0KTtcblxuICAvLyBXaGVuIGNhcHR1cmluZy9idWJibGluZyB0aGUgXCJzaG91bGRTZXRcIiBldmVudCwgd2Ugd2FudCB0byBza2lwIHRoZSB0YXJnZXRcbiAgLy8gKGRlZXBlc3QgSUQpIGlmIGl0IGhhcHBlbnMgdG8gYmUgdGhlIGN1cnJlbnQgcmVzcG9uZGVyLiBUaGUgcmVhc29uaW5nOlxuICAvLyBJdCdzIHN0cmFuZ2UgdG8gZ2V0IGFuIGBvbk1vdmVTaG91bGRTZXRSZXNwb25kZXJgIHdoZW4geW91J3JlICphbHJlYWR5KlxuICAvLyB0aGUgcmVzcG9uZGVyLlxuICB2YXIgc2tpcE92ZXJCdWJibGVTaG91bGRTZXRGcm9tID0gYnViYmxlU2hvdWxkU2V0RnJvbSA9PT0gcmVzcG9uZGVySW5zdDtcbiAgdmFyIHNob3VsZFNldEV2ZW50ID0gUmVzcG9uZGVyU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgIHNob3VsZFNldEV2ZW50VHlwZSxcbiAgICBidWJibGVTaG91bGRTZXRGcm9tLFxuICAgIG5hdGl2ZUV2ZW50LFxuICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICk7XG4gIHNob3VsZFNldEV2ZW50LnRvdWNoSGlzdG9yeSA9IFJlc3BvbmRlclRvdWNoSGlzdG9yeVN0b3JlLnRvdWNoSGlzdG9yeTtcbiAgaWYgKHNraXBPdmVyQnViYmxlU2hvdWxkU2V0RnJvbSkge1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KHNob3VsZFNldEV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHNob3VsZFNldEV2ZW50KTtcbiAgfVxuICB2YXIgd2FudHNSZXNwb25kZXJJbnN0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShzaG91bGRTZXRFdmVudCk7XG4gIGlmICghc2hvdWxkU2V0RXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICBzaG91bGRTZXRFdmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKHNob3VsZFNldEV2ZW50KTtcbiAgfVxuXG4gIGlmICghd2FudHNSZXNwb25kZXJJbnN0IHx8IHdhbnRzUmVzcG9uZGVySW5zdCA9PT0gcmVzcG9uZGVySW5zdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBleHRyYWN0ZWQgPSB2b2lkIDA7XG4gIHZhciBncmFudEV2ZW50ID0gUmVzcG9uZGVyU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgIGV2ZW50VHlwZXMkMS5yZXNwb25kZXJHcmFudCxcbiAgICB3YW50c1Jlc3BvbmRlckluc3QsXG4gICAgbmF0aXZlRXZlbnQsXG4gICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgKTtcbiAgZ3JhbnRFdmVudC50b3VjaEhpc3RvcnkgPSBSZXNwb25kZXJUb3VjaEhpc3RvcnlTdG9yZS50b3VjaEhpc3Rvcnk7XG5cbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZ3JhbnRFdmVudCk7XG4gIHZhciBibG9ja0hvc3RSZXNwb25kZXIgPSBleGVjdXRlRGlyZWN0RGlzcGF0Y2goZ3JhbnRFdmVudCkgPT09IHRydWU7XG4gIGlmIChyZXNwb25kZXJJbnN0KSB7XG4gICAgdmFyIHRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50ID0gUmVzcG9uZGVyU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcyQxLnJlc3BvbmRlclRlcm1pbmF0aW9uUmVxdWVzdCxcbiAgICAgIHJlc3BvbmRlckluc3QsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgKTtcbiAgICB0ZXJtaW5hdGlvblJlcXVlc3RFdmVudC50b3VjaEhpc3RvcnkgPVxuICAgICAgUmVzcG9uZGVyVG91Y2hIaXN0b3J5U3RvcmUudG91Y2hIaXN0b3J5O1xuICAgIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKHRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50KTtcbiAgICB2YXIgc2hvdWxkU3dpdGNoID1cbiAgICAgICFoYXNEaXNwYXRjaGVzKHRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50KSB8fFxuICAgICAgZXhlY3V0ZURpcmVjdERpc3BhdGNoKHRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50KTtcbiAgICBpZiAoIXRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICB0ZXJtaW5hdGlvblJlcXVlc3RFdmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKHRlcm1pbmF0aW9uUmVxdWVzdEV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU3dpdGNoKSB7XG4gICAgICB2YXIgdGVybWluYXRlRXZlbnQgPSBSZXNwb25kZXJTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICAgIGV2ZW50VHlwZXMkMS5yZXNwb25kZXJUZXJtaW5hdGUsXG4gICAgICAgIHJlc3BvbmRlckluc3QsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgKTtcbiAgICAgIHRlcm1pbmF0ZUV2ZW50LnRvdWNoSGlzdG9yeSA9IFJlc3BvbmRlclRvdWNoSGlzdG9yeVN0b3JlLnRvdWNoSGlzdG9yeTtcbiAgICAgIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKHRlcm1pbmF0ZUV2ZW50KTtcbiAgICAgIGV4dHJhY3RlZCA9IGFjY3VtdWxhdGUoZXh0cmFjdGVkLCBbZ3JhbnRFdmVudCwgdGVybWluYXRlRXZlbnRdKTtcbiAgICAgIGNoYW5nZVJlc3BvbmRlcih3YW50c1Jlc3BvbmRlckluc3QsIGJsb2NrSG9zdFJlc3BvbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZWplY3RFdmVudCA9IFJlc3BvbmRlclN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgZXZlbnRUeXBlcyQxLnJlc3BvbmRlclJlamVjdCxcbiAgICAgICAgd2FudHNSZXNwb25kZXJJbnN0LFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICk7XG4gICAgICByZWplY3RFdmVudC50b3VjaEhpc3RvcnkgPSBSZXNwb25kZXJUb3VjaEhpc3RvcnlTdG9yZS50b3VjaEhpc3Rvcnk7XG4gICAgICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhyZWplY3RFdmVudCk7XG4gICAgICBleHRyYWN0ZWQgPSBhY2N1bXVsYXRlKGV4dHJhY3RlZCwgcmVqZWN0RXZlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBleHRyYWN0ZWQgPSBhY2N1bXVsYXRlKGV4dHJhY3RlZCwgZ3JhbnRFdmVudCk7XG4gICAgY2hhbmdlUmVzcG9uZGVyKHdhbnRzUmVzcG9uZGVySW5zdCwgYmxvY2tIb3N0UmVzcG9uZGVyKTtcbiAgfVxuICByZXR1cm4gZXh0cmFjdGVkO1xufVxuXG4vKipcbiAqIEEgdHJhbnNmZXIgaXMgYSBuZWdvdGlhdGlvbiBiZXR3ZWVuIGEgY3VycmVudGx5IHNldCByZXNwb25kZXIgYW5kIHRoZSBuZXh0XG4gKiBlbGVtZW50IHRvIGNsYWltIHJlc3BvbmRlciBzdGF0dXMuIEFueSBzdGFydCBldmVudCBjb3VsZCB0cmlnZ2VyIGEgdHJhbnNmZXJcbiAqIG9mIHJlc3BvbmRlckluc3QuIEFueSBtb3ZlIGV2ZW50IGNvdWxkIHRyaWdnZXIgYSB0cmFuc2Zlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIHRyYW5zZmVyIG9mIHJlc3BvbmRlciBjb3VsZCBwb3NzaWJseSBvY2N1ci5cbiAqL1xuZnVuY3Rpb24gY2FuVHJpZ2dlclRyYW5zZmVyKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxJbnN0LCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKFxuICAgIHRvcExldmVsSW5zdCAmJlxuICAgIC8vIHJlc3BvbmRlcklnbm9yZVNjcm9sbDogV2UgYXJlIHRyeWluZyB0byBtaWdyYXRlIGF3YXkgZnJvbSBzcGVjaWZpY2FsbHlcbiAgICAvLyB0cmFja2luZyBuYXRpdmUgc2Nyb2xsIGV2ZW50cyBoZXJlIGFuZCByZXNwb25kZXJJZ25vcmVTY3JvbGwgaW5kaWNhdGVzIHdlXG4gICAgLy8gd2lsbCBzZW5kIHRvcFRvdWNoQ2FuY2VsIHRvIGhhbmRsZSBjYW5jZWxpbmcgdG91Y2ggZXZlbnRzIGluc3RlYWRcbiAgICAoKHRvcExldmVsVHlwZSA9PT0gVE9QX1NDUk9MTCAmJiAhbmF0aXZlRXZlbnQucmVzcG9uZGVySWdub3JlU2Nyb2xsKSB8fFxuICAgICAgKHRyYWNrZWRUb3VjaENvdW50ID4gMCAmJiB0b3BMZXZlbFR5cGUgPT09IFRPUF9TRUxFQ1RJT05fQ0hBTkdFKSB8fFxuICAgICAgaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHx8XG4gICAgICBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgdG91Y2ggZW5kIGV2ZW50IG1ha2VzIGl0IHN1Y2ggdGhhdCB0aGVyZSBhcmUgbm9cbiAqIGxvbmdlciBhbnkgdG91Y2hlcyB0aGF0IHN0YXJ0ZWQgaW5zaWRlIG9mIHRoZSBjdXJyZW50IGByZXNwb25kZXJJbnN0YC5cbiAqXG4gKiBAcGFyYW0ge05hdGl2ZUV2ZW50fSBuYXRpdmVFdmVudCBOYXRpdmUgdG91Y2ggZW5kIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhpcyB0b3VjaCBlbmQgZXZlbnQgZW5kcyB0aGUgcmVzcG9uZGVyLlxuICovXG5mdW5jdGlvbiBub1Jlc3BvbmRlclRvdWNoZXMobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRvdWNoZXMgPSBuYXRpdmVFdmVudC50b3VjaGVzO1xuICBpZiAoIXRvdWNoZXMgfHwgdG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYWN0aXZlVG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgIHZhciB0YXJnZXQgPSBhY3RpdmVUb3VjaC50YXJnZXQ7XG4gICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IDApIHtcbiAgICAgIC8vIElzIHRoZSBvcmlnaW5hbCB0b3VjaCBsb2NhdGlvbiBpbnNpZGUgb2YgdGhlIGN1cnJlbnQgcmVzcG9uZGVyP1xuICAgICAgdmFyIHRhcmdldEluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gICAgICBpZiAoaXNBbmNlc3RvcihyZXNwb25kZXJJbnN0LCB0YXJnZXRJbnN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgUmVzcG9uZGVyRXZlbnRQbHVnaW4gPSB7XG4gIC8qIEZvciB1bml0IHRlc3Rpbmcgb25seSAqL1xuICBfZ2V0UmVzcG9uZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcmVzcG9uZGVySW5zdDtcbiAgfSxcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgLyoqXG4gICAqIFdlIG11c3QgYmUgcmVzaWxpZW50IHRvIGB0YXJnZXRJbnN0YCBiZWluZyBgbnVsbGAgb24gYHRvdWNoTW92ZWAgb3JcbiAgICogYHRvdWNoRW5kYC4gT24gY2VydGFpbiBwbGF0Zm9ybXMsIHRoaXMgbWVhbnMgdGhhdCBhIG5hdGl2ZSBzY3JvbGwgaGFzXG4gICAqIGFzc3VtZWQgY29udHJvbCBhbmQgdGhlIG9yaWdpbmFsIHRvdWNoIHRhcmdldHMgYXJlIGRlc3Ryb3llZC5cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0YXJnZXRJbnN0LFxuICAgIG5hdGl2ZUV2ZW50LFxuICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICkge1xuICAgIGlmIChpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkpIHtcbiAgICAgIHRyYWNrZWRUb3VjaENvdW50ICs9IDE7XG4gICAgfSBlbHNlIGlmIChpc0VuZGlzaCh0b3BMZXZlbFR5cGUpKSB7XG4gICAgICBpZiAodHJhY2tlZFRvdWNoQ291bnQgPj0gMCkge1xuICAgICAgICB0cmFja2VkVG91Y2hDb3VudCAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkVuZGVkIGEgdG91Y2ggZXZlbnQgd2hpY2ggd2FzIG5vdCBjb3VudGVkIGluIGB0cmFja2VkVG91Y2hDb3VudGAuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmVzcG9uZGVyVG91Y2hIaXN0b3J5U3RvcmUucmVjb3JkVG91Y2hUcmFjayh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcblxuICAgIHZhciBleHRyYWN0ZWQgPSBjYW5UcmlnZ2VyVHJhbnNmZXIodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudClcbiAgICAgID8gc2V0UmVzcG9uZGVyQW5kRXh0cmFjdFRyYW5zZmVyKFxuICAgICAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgICAgICB0YXJnZXRJbnN0LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgIClcbiAgICAgIDogbnVsbDtcbiAgICAvLyBSZXNwb25kZXIgbWF5IG9yIG1heSBub3QgaGF2ZSB0cmFuc2ZlcnJlZCBvbiBhIG5ldyB0b3VjaCBzdGFydC9tb3ZlLlxuICAgIC8vIFJlZ2FyZGxlc3MsIHdob2V2ZXIgaXMgdGhlIHJlc3BvbmRlciBhZnRlciBhbnkgcG90ZW50aWFsIHRyYW5zZmVyLCB3ZVxuICAgIC8vIGRpcmVjdCBhbGwgdG91Y2ggc3RhcnQvbW92ZS9lbmRzIHRvIHRoZW0gaW4gdGhlIGZvcm0gb2ZcbiAgICAvLyBgb25SZXNwb25kZXJNb3ZlL1N0YXJ0L0VuZGAuIFRoZXNlIHdpbGwgYmUgY2FsbGVkIGZvciAqZXZlcnkqIGFkZGl0aW9uYWxcbiAgICAvLyBmaW5nZXIgdGhhdCBtb3ZlL3N0YXJ0L2VuZCwgZGlzcGF0Y2hlZCBkaXJlY3RseSB0byB3aG9ldmVyIGlzIHRoZVxuICAgIC8vIGN1cnJlbnQgcmVzcG9uZGVyIGF0IHRoYXQgbW9tZW50LCB1bnRpbCB0aGUgcmVzcG9uZGVyIGlzIFwicmVsZWFzZWRcIi5cbiAgICAvL1xuICAgIC8vIFRoZXNlIG11bHRpcGxlIGluZGl2aWR1YWwgY2hhbmdlIHRvdWNoIGV2ZW50cyBhcmUgYXJlIGFsd2F5cyBib29rZW5kZWRcbiAgICAvLyBieSBgb25SZXNwb25kZXJHcmFudGAsIGFuZCBvbmUgb2ZcbiAgICAvLyAoYG9uUmVzcG9uZGVyUmVsZWFzZS9vblJlc3BvbmRlclRlcm1pbmF0ZWApLlxuICAgIHZhciBpc1Jlc3BvbmRlclRvdWNoU3RhcnQgPSByZXNwb25kZXJJbnN0ICYmIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKTtcbiAgICB2YXIgaXNSZXNwb25kZXJUb3VjaE1vdmUgPSByZXNwb25kZXJJbnN0ICYmIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpO1xuICAgIHZhciBpc1Jlc3BvbmRlclRvdWNoRW5kID0gcmVzcG9uZGVySW5zdCAmJiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpO1xuICAgIHZhciBpbmNyZW1lbnRhbFRvdWNoID0gaXNSZXNwb25kZXJUb3VjaFN0YXJ0XG4gICAgICA/IGV2ZW50VHlwZXMkMS5yZXNwb25kZXJTdGFydFxuICAgICAgOiBpc1Jlc3BvbmRlclRvdWNoTW92ZVxuICAgICAgICA/IGV2ZW50VHlwZXMkMS5yZXNwb25kZXJNb3ZlXG4gICAgICAgIDogaXNSZXNwb25kZXJUb3VjaEVuZFxuICAgICAgICAgID8gZXZlbnRUeXBlcyQxLnJlc3BvbmRlckVuZFxuICAgICAgICAgIDogbnVsbDtcblxuICAgIGlmIChpbmNyZW1lbnRhbFRvdWNoKSB7XG4gICAgICB2YXIgZ2VzdHVyZSA9IFJlc3BvbmRlclN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgaW5jcmVtZW50YWxUb3VjaCxcbiAgICAgICAgcmVzcG9uZGVySW5zdCxcbiAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICApO1xuICAgICAgZ2VzdHVyZS50b3VjaEhpc3RvcnkgPSBSZXNwb25kZXJUb3VjaEhpc3RvcnlTdG9yZS50b3VjaEhpc3Rvcnk7XG4gICAgICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhnZXN0dXJlKTtcbiAgICAgIGV4dHJhY3RlZCA9IGFjY3VtdWxhdGUoZXh0cmFjdGVkLCBnZXN0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNwb25kZXJUZXJtaW5hdGUgPVxuICAgICAgcmVzcG9uZGVySW5zdCAmJiB0b3BMZXZlbFR5cGUgPT09IFRPUF9UT1VDSF9DQU5DRUw7XG4gICAgdmFyIGlzUmVzcG9uZGVyUmVsZWFzZSA9XG4gICAgICByZXNwb25kZXJJbnN0ICYmXG4gICAgICAhaXNSZXNwb25kZXJUZXJtaW5hdGUgJiZcbiAgICAgIGlzRW5kaXNoKHRvcExldmVsVHlwZSkgJiZcbiAgICAgIG5vUmVzcG9uZGVyVG91Y2hlcyhuYXRpdmVFdmVudCk7XG4gICAgdmFyIGZpbmFsVG91Y2ggPSBpc1Jlc3BvbmRlclRlcm1pbmF0ZVxuICAgICAgPyBldmVudFR5cGVzJDEucmVzcG9uZGVyVGVybWluYXRlXG4gICAgICA6IGlzUmVzcG9uZGVyUmVsZWFzZVxuICAgICAgICA/IGV2ZW50VHlwZXMkMS5yZXNwb25kZXJSZWxlYXNlXG4gICAgICAgIDogbnVsbDtcbiAgICBpZiAoZmluYWxUb3VjaCkge1xuICAgICAgdmFyIGZpbmFsRXZlbnQgPSBSZXNwb25kZXJTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICAgIGZpbmFsVG91Y2gsXG4gICAgICAgIHJlc3BvbmRlckluc3QsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgKTtcbiAgICAgIGZpbmFsRXZlbnQudG91Y2hIaXN0b3J5ID0gUmVzcG9uZGVyVG91Y2hIaXN0b3J5U3RvcmUudG91Y2hIaXN0b3J5O1xuICAgICAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZmluYWxFdmVudCk7XG4gICAgICBleHRyYWN0ZWQgPSBhY2N1bXVsYXRlKGV4dHJhY3RlZCwgZmluYWxFdmVudCk7XG4gICAgICBjaGFuZ2VSZXNwb25kZXIobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgfSxcblxuICBHbG9iYWxSZXNwb25kZXJIYW5kbGVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e29uQ2hhbmdlOiAoUmVhY3RJRCwgUmVhY3RJRCkgPT4gdm9pZH0gR2xvYmFsUmVzcG9uZGVySGFuZGxlclxuICAgICAqIE9iamVjdCB0aGF0IGhhbmRsZXMgYW55IGNoYW5nZSBpbiByZXNwb25kZXIuIFVzZSB0aGlzIHRvIGluamVjdFxuICAgICAqIGludGVncmF0aW9uIHdpdGggYW4gZXhpc3RpbmcgdG91Y2ggaGFuZGxpbmcgc3lzdGVtIGV0Yy5cbiAgICAgKi9cbiAgICBpbmplY3RHbG9iYWxSZXNwb25kZXJIYW5kbGVyOiBmdW5jdGlvbihHbG9iYWxSZXNwb25kZXJIYW5kbGVyKSB7XG4gICAgICBSZXNwb25kZXJFdmVudFBsdWdpbi5HbG9iYWxSZXNwb25kZXJIYW5kbGVyID0gR2xvYmFsUmVzcG9uZGVySGFuZGxlcjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjdXN0b21CdWJibGluZ0V2ZW50VHlwZXMkMSA9XG4gIFJlYWN0TmF0aXZlVmlld0NvbmZpZ1JlZ2lzdHJ5LmN1c3RvbUJ1YmJsaW5nRXZlbnRUeXBlcztcbnZhciBjdXN0b21EaXJlY3RFdmVudFR5cGVzJDEgPVxuICBSZWFjdE5hdGl2ZVZpZXdDb25maWdSZWdpc3RyeS5jdXN0b21EaXJlY3RFdmVudFR5cGVzO1xudmFyIGV2ZW50VHlwZXMkMiA9IFJlYWN0TmF0aXZlVmlld0NvbmZpZ1JlZ2lzdHJ5LmV2ZW50VHlwZXM7XG5cbnZhciBSZWFjdE5hdGl2ZUJyaWRnZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDIsXG5cbiAgLyoqXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdGFyZ2V0SW5zdCxcbiAgICBuYXRpdmVFdmVudCxcbiAgICBuYXRpdmVFdmVudFRhcmdldFxuICApIHtcbiAgICBpZiAodGFyZ2V0SW5zdCA9PSBudWxsKSB7XG4gICAgICAvLyBQcm9iYWJseSBhIG5vZGUgYmVsb25naW5nIHRvIGFub3RoZXIgcmVuZGVyZXIncyB0cmVlLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBidWJibGVEaXNwYXRjaENvbmZpZyA9IGN1c3RvbUJ1YmJsaW5nRXZlbnRUeXBlcyQxW3RvcExldmVsVHlwZV07XG4gICAgdmFyIGRpcmVjdERpc3BhdGNoQ29uZmlnID0gY3VzdG9tRGlyZWN0RXZlbnRUeXBlcyQxW3RvcExldmVsVHlwZV07XG4gICAgaW52YXJpYW50KFxuICAgICAgYnViYmxlRGlzcGF0Y2hDb25maWcgfHwgZGlyZWN0RGlzcGF0Y2hDb25maWcsXG4gICAgICAnVW5zdXBwb3J0ZWQgdG9wIGxldmVsIGV2ZW50IHR5cGUgXCIlc1wiIGRpc3BhdGNoZWQnLFxuICAgICAgdG9wTGV2ZWxUeXBlXG4gICAgKTtcbiAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICBidWJibGVEaXNwYXRjaENvbmZpZyB8fCBkaXJlY3REaXNwYXRjaENvbmZpZyxcbiAgICAgIHRhcmdldEluc3QsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgKTtcbiAgICBpZiAoYnViYmxlRGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0RGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxudmFyIFJlYWN0TmF0aXZlRXZlbnRQbHVnaW5PcmRlciA9IFtcbiAgXCJSZXNwb25kZXJFdmVudFBsdWdpblwiLFxuICBcIlJlYWN0TmF0aXZlQnJpZGdlRXZlbnRQbHVnaW5cIlxuXTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgZXNzZW50aWFsIGdsb2JhbHMgYXJlIGF2YWlsYWJsZSBhbmQgYXJlIHBhdGNoZWQgY29ycmVjdGx5LiBQbGVhc2UgZG9uJ3QgcmVtb3ZlIHRoaXNcbiAqIGxpbmUuIEJ1bmRsZXMgY3JlYXRlZCBieSByZWFjdC1wYWNrYWdlciBgcmVxdWlyZWAgaXQgYmVmb3JlIGV4ZWN1dGluZyBhbnkgYXBwbGljYXRpb24gY29kZS4gVGhpc1xuICogZW5zdXJlcyBpdCBleGlzdHMgaW4gdGhlIGRlcGVuZGVuY3kgZ3JhcGggYW5kIGNhbiBiZSBgcmVxdWlyZWBkLlxuICogVE9ETzogcmVxdWlyZSB0aGlzIGluIHBhY2thZ2VyLCBub3QgaW4gUmVhY3QgIzEwOTMyNTE3XG4gKi9cbi8vIE1vZHVsZSBwcm92aWRlZCBieSBSTjpcbi8qKlxuICogSW5qZWN0IG1vZHVsZSBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoUmVhY3ROYXRpdmVFdmVudFBsdWdpbk9yZGVyKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgUmVzcG9uZGVyRXZlbnRQbHVnaW46IFJlc3BvbmRlckV2ZW50UGx1Z2luLFxuICBSZWFjdE5hdGl2ZUJyaWRnZUV2ZW50UGx1Z2luOiBSZWFjdE5hdGl2ZUJyaWRnZUV2ZW50UGx1Z2luXG59KTtcblxudmFyIGluc3RhbmNlQ2FjaGUgPSB7fTtcbnZhciBpbnN0YW5jZVByb3BzID0ge307XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlKGhvc3RJbnN0LCB0YWcpIHtcbiAgaW5zdGFuY2VDYWNoZVt0YWddID0gaG9zdEluc3Q7XG59XG5cbmZ1bmN0aW9uIHVuY2FjaGVGaWJlck5vZGUodGFnKSB7XG4gIGRlbGV0ZSBpbnN0YW5jZUNhY2hlW3RhZ107XG4gIGRlbGV0ZSBpbnN0YW5jZVByb3BzW3RhZ107XG59XG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbVRhZyh0YWcpIHtcbiAgcmV0dXJuIGluc3RhbmNlQ2FjaGVbdGFnXSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYWdGcm9tSW5zdGFuY2UoaW5zdCkge1xuICB2YXIgdGFnID0gaW5zdC5zdGF0ZU5vZGUuX25hdGl2ZVRhZztcbiAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGFnID0gaW5zdC5zdGF0ZU5vZGUuY2Fub25pY2FsLl9uYXRpdmVUYWc7XG4gIH1cbiAgaW52YXJpYW50KHRhZywgXCJBbGwgbmF0aXZlIGluc3RhbmNlcyBzaG91bGQgaGF2ZSBhIHRhZy5cIik7XG4gIHJldHVybiB0YWc7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShzdGF0ZU5vZGUpIHtcbiAgcmV0dXJuIGluc3RhbmNlUHJvcHNbc3RhdGVOb2RlLl9uYXRpdmVUYWddIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHModGFnLCBwcm9wcykge1xuICBpbnN0YW5jZVByb3BzW3RhZ10gPSBwcm9wcztcbn1cblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciByZXN0b3JlSW1wbCA9IG51bGw7XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIGludmFyaWFudChcbiAgICB0eXBlb2YgcmVzdG9yZUltcGwgPT09IFwiZnVuY3Rpb25cIixcbiAgICBcInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbigpIG5lZWRzIHRvIGJlIGNhbGxlZCB0byBoYW5kbGUgYSB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgXCIgK1xuICAgICAgXCJldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgX2JhdGNoZWRVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcbnZhciBfZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsID0gZnVuY3Rpb24oKSB7fTtcblxudmFyIGlzQmF0Y2hpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNCYXRjaGluZykge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLlxuICAgIHJldHVybiBmbihib29ra2VlcGluZyk7XG4gIH1cbiAgaXNCYXRjaGluZyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIF9iYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNCYXRjaGluZyA9IGZhbHNlO1xuICAgIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG4gICAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBJZiBhIGNvbnRyb2xsZWQgZXZlbnQgd2FzIGZpcmVkLCB3ZSBtYXkgbmVlZCB0byByZXN0b3JlIHRoZSBzdGF0ZSBvZlxuICAgICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICAgIF9mbHVzaEludGVyYWN0aXZlVXBkYXRlc0ltcGwoKTtcbiAgICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oXG4gIGJhdGNoZWRVcGRhdGVzSW1wbCxcbiAgaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCxcbiAgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsXG4pIHtcbiAgX2JhdGNoZWRVcGRhdGVzSW1wbCA9IGJhdGNoZWRVcGRhdGVzSW1wbDtcbiAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbDtcbn1cblxuLyoqXG4gKiBWZXJzaW9uIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIHRoYXQgd29ya3Mgb24gdGhlIHJlY2VpdmluZyBzaWRlIG9mIGFcbiAqIHNlcmlhbGl6ZWQgd29ya2VyIGJvdW5kYXJ5LlxuICovXG5cbi8vIFNoYXJlZCBkZWZhdWx0IGVtcHR5IG5hdGl2ZSBldmVudCAtIGNvbnNlcnZlIG1lbW9yeS5cbnZhciBFTVBUWV9OQVRJVkVfRVZFTlQgPSB7fTtcblxuLyoqXG4gKiBTZWxlY3RzIGEgc3Vic2VxdWVuY2Ugb2YgYFRvdWNoYGVzLCB3aXRob3V0IGRlc3Ryb3lpbmcgYHRvdWNoZXNgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VG91Y2g+fSB0b3VjaGVzIERlc2VyaWFsaXplZCB0b3VjaCBvYmplY3RzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBpbmRpY2VzIEluZGljZXMgYnkgd2hpY2ggdG8gcHVsbCBzdWJzZXF1ZW5jZS5cbiAqIEByZXR1cm4ge0FycmF5PFRvdWNoPn0gU3Vic2VxdWVuY2Ugb2YgdG91Y2ggb2JqZWN0cy5cbiAqL1xudmFyIHRvdWNoU3Vic2VxdWVuY2UgPSBmdW5jdGlvbih0b3VjaGVzLCBpbmRpY2VzKSB7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0LnB1c2godG91Y2hlc1tpbmRpY2VzW2ldXSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogVE9ETzogUG9vbCBhbGwgb2YgdGhpcy5cbiAqXG4gKiBEZXN0cm95cyBgdG91Y2hlc2AgYnkgcmVtb3ZpbmcgdG91Y2ggb2JqZWN0cyBhdCBpbmRpY2VzIGBpbmRpY2VzYC4gVGhpcyBpc1xuICogdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIFczQyB0b3VjaCBcImVuZFwiIGV2ZW50cywgd2hlcmUgdGhlIGFjdGl2ZVxuICogdG91Y2hlcyBkb24ndCBpbmNsdWRlIHRoZSBzZXQgdGhhdCBoYXMganVzdCBiZWVuIFwiZW5kZWRcIi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRvdWNoPn0gdG91Y2hlcyBEZXNlcmlhbGl6ZWQgdG91Y2ggb2JqZWN0cy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW5kaWNlcyBJbmRpY2VzIHRvIHJlbW92ZSBmcm9tIGB0b3VjaGVzYC5cbiAqIEByZXR1cm4ge0FycmF5PFRvdWNoPn0gU3Vic2VxdWVuY2Ugb2YgcmVtb3ZlZCB0b3VjaCBvYmplY3RzLlxuICovXG52YXIgcmVtb3ZlVG91Y2hlc0F0SW5kaWNlcyA9IGZ1bmN0aW9uKHRvdWNoZXMsIGluZGljZXMpIHtcbiAgdmFyIHJpcHBlZE91dCA9IFtdO1xuICAvLyB1c2UgYW4gdW5zYWZlIGRvd25jYXN0IHRvIGFsaWFzIHRvIG51bGxhYmxlIGVsZW1lbnRzLFxuICAvLyBzbyB3ZSBjYW4gZGVsZXRlIGFuZCB0aGVuIGNvbXBhY3QuXG4gIHZhciB0ZW1wID0gdG91Y2hlcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kaWNlc1tpXTtcbiAgICByaXBwZWRPdXQucHVzaCh0b3VjaGVzW2luZGV4XSk7XG4gICAgdGVtcFtpbmRleF0gPSBudWxsO1xuICB9XG4gIHZhciBmaWxsQXQgPSAwO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICB2YXIgY3VyID0gdGVtcFtqXTtcbiAgICBpZiAoY3VyICE9PSBudWxsKSB7XG4gICAgICB0ZW1wW2ZpbGxBdCsrXSA9IGN1cjtcbiAgICB9XG4gIH1cbiAgdGVtcC5sZW5ndGggPSBmaWxsQXQ7XG4gIHJldHVybiByaXBwZWRPdXQ7XG59O1xuXG4vKipcbiAqIEludGVybmFsIHZlcnNpb24gb2YgYHJlY2VpdmVFdmVudGAgaW4gdGVybXMgb2Ygbm9ybWFsaXplZCAobm9uLXRhZylcbiAqIGByb290Tm9kZUlEYC5cbiAqXG4gKiBAc2VlIHJlY2VpdmVFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3Jvb3ROb2RlSUR9IHJvb3ROb2RlSUQgUmVhY3Qgcm9vdCBub2RlIElEIHRoYXQgZXZlbnQgb2NjdXJyZWQgb24uXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZX0gdG9wTGV2ZWxUeXBlIFRvcCBsZXZlbCB0eXBlIG9mIGV2ZW50LlxuICogQHBhcmFtIHs/b2JqZWN0fSBuYXRpdmVFdmVudFBhcmFtIE9iamVjdCBwYXNzZWQgZnJvbSBuYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIF9yZWNlaXZlUm9vdE5vZGVJREV2ZW50KHJvb3ROb2RlSUQsIHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnRQYXJhbSkge1xuICB2YXIgbmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudFBhcmFtIHx8IEVNUFRZX05BVElWRV9FVkVOVDtcbiAgdmFyIGluc3QgPSBnZXRJbnN0YW5jZUZyb21UYWcocm9vdE5vZGVJRCk7XG4gIGJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCkge1xuICAgIHJ1bkV4dHJhY3RlZEV2ZW50c0luQmF0Y2goXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBpbnN0LFxuICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICBuYXRpdmVFdmVudC50YXJnZXRcbiAgICApO1xuICB9KTtcbiAgLy8gUmVhY3QgTmF0aXZlIGRvZXNuJ3QgdXNlIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCBidXQgaWYgaXQgZGlkLCBoZXJlJ3NcbiAgLy8gd2hlcmUgaXQgd291bGQgZG8gaXQuXG59XG5cbi8qKlxuICogUHVibGljbHkgZXhwb3NlZCBtZXRob2Qgb24gbW9kdWxlIGZvciBuYXRpdmUgb2JqYyB0byBpbnZva2Ugd2hlbiBhIHRvcFxuICogbGV2ZWwgZXZlbnQgaXMgZXh0cmFjdGVkLlxuICogQHBhcmFtIHtyb290Tm9kZUlEfSByb290Tm9kZUlEIFJlYWN0IHJvb3Qgbm9kZSBJRCB0aGF0IGV2ZW50IG9jY3VycmVkIG9uLlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGV9IHRvcExldmVsVHlwZSBUb3AgbGV2ZWwgdHlwZSBvZiBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFBhcmFtIE9iamVjdCBwYXNzZWQgZnJvbSBuYXRpdmUuXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVFdmVudChyb290Tm9kZUlELCB0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50UGFyYW0pIHtcbiAgX3JlY2VpdmVSb290Tm9kZUlERXZlbnQocm9vdE5vZGVJRCwgdG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudFBhcmFtKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgbXVsdGktd3JhcHBlciBhcm91bmQgYHJlY2VpdmVFdmVudGAgdGhhdCBpcyBpbnRlbmRlZCB0byByZWNlaXZlIGFuXG4gKiBlZmZpY2llbnQgcmVwcmVzZW50YXRpb24gb2YgYFRvdWNoYCBvYmplY3RzLCBhbmQgb3RoZXIgaW5mb3JtYXRpb24gdGhhdFxuICogY2FuIGJlIHVzZWQgdG8gY29uc3RydWN0IFczQyBjb21wbGlhbnQgYEV2ZW50YCBhbmQgYFRvdWNoYCBsaXN0cy5cbiAqXG4gKiBUaGlzIG1heSBjcmVhdGUgZGlzcGF0Y2ggYmVoYXZpb3IgdGhhdCBkaWZmZXJzIHRoYW4gd2ViIHRvdWNoIGhhbmRsaW5nLiBXZVxuICogbG9vcCB0aHJvdWdoIGVhY2ggb2YgdGhlIGNoYW5nZWQgdG91Y2hlcyBhbmQgcmVjZWl2ZSBpdCBhcyBhIHNpbmdsZSBldmVudC5cbiAqIFNvIHR3byBgdG91Y2hTdGFydGAvYHRvdWNoTW92ZWBzIHRoYXQgb2NjdXIgc2ltdWx0YW5lb3VzbHkgYXJlIHJlY2VpdmVkIGFzXG4gKiB0d28gc2VwYXJhdGUgdG91Y2ggZXZlbnQgZGlzcGF0Y2hlcyAtIHdoZW4gdGhleSBhcmd1YWJseSBzaG91bGQgYmUgb25lLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gcmV1c2VzIHRoZSBgVG91Y2hgIG9iamVjdHMgdGhlbXNlbHZlcyBhcyB0aGUgYEV2ZW50YHNcbiAqIHNpbmNlIHdlIGRpc3BhdGNoIGFuIGV2ZW50IGZvciBlYWNoIHRvdWNoICh0aG91Z2ggdGhhdCBtaWdodCBub3QgYmUgc3BlY1xuICogY29tcGxpYW50KS4gVGhlIG1haW4gcHVycG9zZSBvZiByZXVzaW5nIHRoZW0gaXMgdG8gc2F2ZSBhbGxvY2F0aW9ucy5cbiAqXG4gKiBUT0RPOiBEaXNwYXRjaCBtdWx0aXBsZSBjaGFuZ2VkIHRvdWNoZXMgaW4gb25lIGV2ZW50LiBUaGUgYnViYmxlIHBhdGhcbiAqIGNvdWxkIGJlIHRoZSBmaXJzdCBjb21tb24gYW5jZXN0b3Igb2YgYWxsIHRoZSBgY2hhbmdlZFRvdWNoZXNgLlxuICpcbiAqIE9uZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBiZWhhdmlvciBhbmQgVzNDIHNwZWM6IGNhbmNlbGxlZCB0b3VjaGVzIHdpbGxcbiAqIG5vdCBhcHBlYXIgaW4gYC50b3VjaGVzYCwgb3IgaW4gYW55IGZ1dHVyZSBgLnRvdWNoZXNgLCB0aG91Z2ggdGhleSBtYXlcbiAqIHN0aWxsIGJlIFwiYWN0aXZlbHkgdG91Y2hpbmcgdGhlIHN1cmZhY2VcIi5cbiAqXG4gKiBXZWIgZGVza3RvcCBwb2x5ZmlsbHMgb25seSBuZWVkIHRvIGNvbnN0cnVjdCBhIGZha2UgdG91Y2ggZXZlbnQgd2l0aFxuICogaWRlbnRpZmllciAwLCBhbHNvIGFiYW5kb25pbmcgdHJhZGl0aW9uYWwgY2xpY2sgaGFuZGxlcnMuXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVUb3VjaGVzKGV2ZW50VG9wTGV2ZWxUeXBlLCB0b3VjaGVzLCBjaGFuZ2VkSW5kaWNlcykge1xuICB2YXIgY2hhbmdlZFRvdWNoZXMgPVxuICAgIGV2ZW50VG9wTGV2ZWxUeXBlID09PSBcInRvcFRvdWNoRW5kXCIgfHxcbiAgICBldmVudFRvcExldmVsVHlwZSA9PT0gXCJ0b3BUb3VjaENhbmNlbFwiXG4gICAgICA/IHJlbW92ZVRvdWNoZXNBdEluZGljZXModG91Y2hlcywgY2hhbmdlZEluZGljZXMpXG4gICAgICA6IHRvdWNoU3Vic2VxdWVuY2UodG91Y2hlcywgY2hhbmdlZEluZGljZXMpO1xuXG4gIGZvciAodmFyIGpqID0gMDsgamogPCBjaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGpqKyspIHtcbiAgICB2YXIgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1tqal07XG4gICAgLy8gVG91Y2ggb2JqZWN0cyBjYW4gZnVsZmlsbCB0aGUgcm9sZSBvZiBgRE9NYCBgRXZlbnRgIG9iamVjdHMgaWYgd2Ugc2V0XG4gICAgLy8gdGhlIGBjaGFuZ2VkVG91Y2hlc2AvYHRvdWNoZXNgLiBUaGlzIHNhdmVzIGFsbG9jYXRpb25zLlxuICAgIHRvdWNoLmNoYW5nZWRUb3VjaGVzID0gY2hhbmdlZFRvdWNoZXM7XG4gICAgdG91Y2gudG91Y2hlcyA9IHRvdWNoZXM7XG4gICAgdmFyIG5hdGl2ZUV2ZW50ID0gdG91Y2g7XG4gICAgdmFyIHJvb3ROb2RlSUQgPSBudWxsO1xuICAgIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRhcmdldCA8IDEpIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJBIHZpZXcgaXMgcmVwb3J0aW5nIHRoYXQgYSB0b3VjaCBvY2N1cnJlZCBvbiB0YWcgemVyby5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3ROb2RlSUQgPSB0YXJnZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vICRGbG93Rml4TWUgU2hvdWxkbid0IHdlICpub3QqIGNhbGwgaXQgaWYgcm9vdE5vZGVJRCBpcyBudWxsP1xuICAgIF9yZWNlaXZlUm9vdE5vZGVJREV2ZW50KHJvb3ROb2RlSUQsIGV2ZW50VG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxudmFyIFJlYWN0TmF0aXZlRXZlbnRFbWl0dGVyID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcbiAgcmVnaXN0cmF0aW9uTmFtZXM6IHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuICBfcmVjZWl2ZVJvb3ROb2RlSURFdmVudDogX3JlY2VpdmVSb290Tm9kZUlERXZlbnQsXG4gIHJlY2VpdmVFdmVudDogcmVjZWl2ZUV2ZW50LFxuICByZWNlaXZlVG91Y2hlczogcmVjZWl2ZVRvdWNoZXNcbn0pO1xuXG4vLyBNb2R1bGUgcHJvdmlkZWQgYnkgUk46XG52YXIgUmVhY3ROYXRpdmVHbG9iYWxSZXNwb25kZXJIYW5kbGVyID0ge1xuICBvbkNoYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8sIGJsb2NrTmF0aXZlUmVzcG9uZGVyKSB7XG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgdGFnID0gdG8uc3RhdGVOb2RlLl9uYXRpdmVUYWc7XG4gICAgICBVSU1hbmFnZXIuc2V0SlNSZXNwb25kZXIodGFnLCBibG9ja05hdGl2ZVJlc3BvbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFVJTWFuYWdlci5jbGVhckpTUmVzcG9uZGVyKCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBNb2R1bGUgcHJvdmlkZWQgYnkgUk46XG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBldmVudCBlbWl0dGVyIHdpdGggdGhlIG5hdGl2ZSBicmlkZ2VcbiAqL1xuUkNURXZlbnRFbWl0dGVyLnJlZ2lzdGVyKFJlYWN0TmF0aXZlRXZlbnRFbWl0dGVyKTtcblxuc2V0Q29tcG9uZW50VHJlZShcbiAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuICBnZXRJbnN0YW5jZUZyb21UYWcsXG4gIGdldFRhZ0Zyb21JbnN0YW5jZVxuKTtcblxuUmVzcG9uZGVyRXZlbnRQbHVnaW4uaW5qZWN0aW9uLmluamVjdEdsb2JhbFJlc3BvbmRlckhhbmRsZXIoXG4gIFJlYWN0TmF0aXZlR2xvYmFsUmVzcG9uZGVySGFuZGxlclxuKTtcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5cbi8qKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAqL1xuXG5mdW5jdGlvbiBnZXQkMShrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyO1xufVxuXG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlciA9IHZhbHVlO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2xcbiAgPyBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIilcbiAgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpIDogMHhlYWNlO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcihcInJlYWN0LmNvbmN1cnJlbnRfbW9kZVwiKVxuICA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sXG4gID8gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpXG4gIDogMHhlYWQwO1xudmFyIFJFQUNUX1BMQUNFSE9MREVSX1RZUEUgPSBoYXNTeW1ib2xcbiAgPyBTeW1ib2wuZm9yKFwicmVhY3QucGxhY2Vob2xkZXJcIilcbiAgOiAweGVhZDE7XG52YXIgUkVBQ1RfUFVSRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcihcInJlYWN0LnB1cmVcIikgOiAweGVhZDM7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gXCJAQGl0ZXJhdG9yXCI7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID1cbiAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHJldHVybiB0aGVuYWJsZS5fcmVhY3RSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHJlZmluZVJlc29sdmVkVGhlbmFibGUodGhlbmFibGUpIHtcbiAgcmV0dXJuIHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9PT0gUmVzb2x2ZWQgPyB0aGVuYWJsZS5fcmVhY3RSZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSBcIm51bWJlclwiKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gXCIgK1xuICAgICAgICAgIFwiVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gXCJDb25jdXJyZW50TW9kZVwiO1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlBsYWNlaG9sZGVyXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuIFwiQ29udGV4dC5Db25zdW1lclwiO1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gXCJDb250ZXh0LlByb3ZpZGVyXCI7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHZhciByZW5kZXJGbiA9IHR5cGUucmVuZGVyO1xuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gcmVuZGVyRm4uZGlzcGxheU5hbWUgfHwgcmVuZGVyRm4ubmFtZSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHR5cGUuZGlzcGxheU5hbWUgfHxcbiAgICAgICAgICAoZnVuY3Rpb25OYW1lICE9PSBcIlwiXG4gICAgICAgICAgICA/IFwiRm9yd2FyZFJlZihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiXG4gICAgICAgICAgICA6IFwiRm9yd2FyZFJlZlwiKVxuICAgICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB2YXIgdGhlbmFibGUgPSB0eXBlO1xuICAgICAgdmFyIHJlc29sdmVkVGhlbmFibGUgPSByZWZpbmVSZXNvbHZlZFRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgICAgIGlmIChyZXNvbHZlZFRoZW5hYmxlKSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHJlc29sdmVkVGhlbmFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9FZmZlY3QgPSAvKiAgICAgICAgICAgICAgKi8gMDtcbnZhciBQZXJmb3JtZWRXb3JrID0gLyogICAgICAgICAqLyAxO1xuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAvKiAgICAgICAgICAgICAqLyAyO1xudmFyIFVwZGF0ZSA9IC8qICAgICAgICAgICAgICAgICovIDQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID0gLyogICAgKi8gNjtcbnZhciBEZWxldGlvbiA9IC8qICAgICAgICAgICAgICAqLyA4O1xudmFyIENvbnRlbnRSZXNldCA9IC8qICAgICAgICAgICovIDE2O1xudmFyIENhbGxiYWNrID0gLyogICAgICAgICAgICAgICovIDMyO1xudmFyIERpZENhcHR1cmUgPSAvKiAgICAgICAgICAgICovIDY0O1xudmFyIFJlZiA9IC8qICAgICAgICAgICAgICAgICAgICovIDEyODtcbnZhciBTbmFwc2hvdCA9IC8qICAgICAgICAgICAgICAqLyAyNTY7XG5cbi8vIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcbnZhciBMaWZlY3ljbGVFZmZlY3RNYXNrID0gLyogICAqLyA0MjA7XG5cbi8vIFVuaW9uIG9mIGFsbCBob3N0IGVmZmVjdHNcbnZhciBIb3N0RWZmZWN0TWFzayA9IC8qICAgICAgICAqLyA1MTE7XG5cbnZhciBJbmNvbXBsZXRlID0gLyogICAgICAgICAgICAqLyA1MTI7XG52YXIgU2hvdWxkQ2FwdHVyZSA9IC8qICAgICAgICAgKi8gMTAyNDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudDtcbiAgICBpZiAoXG4gICAgICBvd25lciAhPT0gbnVsbCAmJlxuICAgICAgKG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpXG4gICAgKSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAhaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyXG4gICAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gXCIgK1xuICAgICAgICAgICAgICBcInJlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgXCIgK1xuICAgICAgICAgICAgICBcIm5ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIFwiICtcbiAgICAgICAgICAgICAgXCJyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCBcIiArXG4gICAgICAgICAgICAgIFwiY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgXCJBIGNvbXBvbmVudFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IHZvaWQgMDtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0JDEoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGludmFyaWFudChcbiAgICBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVELFxuICAgIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgaW52YXJpYW50KFxuICAgICAgc3RhdGUgIT09IFVOTU9VTlRFRCxcbiAgICAgIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiXG4gICAgKTtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGRpZEZpbmRDaGlsZCxcbiAgICAgICAgICBcIkNoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIFwiICtcbiAgICAgICAgICAgIFwiaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgYS5hbHRlcm5hdGUgPT09IGIsXG4gICAgICBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gXCIgK1xuICAgICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICApO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgaW52YXJpYW50KFxuICAgIGEudGFnID09PSBIb3N0Um9vdCxcbiAgICBcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIlxuICApO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE1vZHVsZXMgcHJvdmlkZWQgYnkgUk46XG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGUgYSBwYXlsb2FkIHRoYXQgY29udGFpbnMgYWxsIHRoZSB1cGRhdGVzIGJldHdlZW4gdHdvIHNldHMgb2YgcHJvcHMuXG4gKlxuICogVGhlc2UgaGVscGVycyBhcmUgYWxsIGVuY2Fwc3VsYXRlZCBpbnRvIGEgc2luZ2xlIG1vZHVsZSwgYmVjYXVzZSB0aGV5IHVzZVxuICogbXV0YXRpb24gYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gd2hpY2ggbGVhZHMgdG8gc3VidGxlIHNoYXJlZFxuICogZGVwZW5kZW5jaWVzIGJldHdlZW4gdGhlIGNvZGUgcGF0aHMuIFRvIGF2b2lkIHRoaXMgbXV0YWJsZSBzdGF0ZSBsZWFraW5nXG4gKiBhY3Jvc3MgbW9kdWxlcywgSSd2ZSBrZXB0IHRoZW0gaXNvbGF0ZWQgdG8gdGhpcyBtb2R1bGUuXG4gKi9cblxuLy8gVHJhY2tzIHJlbW92ZWQga2V5c1xudmFyIHJlbW92ZWRLZXlzID0gbnVsbDtcbnZhciByZW1vdmVkS2V5Q291bnQgPSAwO1xuXG5mdW5jdGlvbiBkZWZhdWx0RGlmZmVyKHByZXZQcm9wLCBuZXh0UHJvcCkge1xuICBpZiAodHlwZW9mIG5leHRQcm9wICE9PSBcIm9iamVjdFwiIHx8IG5leHRQcm9wID09PSBudWxsKSB7XG4gICAgLy8gU2NhbGFycyBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciBlcXVhbGl0eVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIEZvciBvYmplY3RzIGFuZCBhcnJheXMsIHRoZSBkZWZhdWx0IGRpZmZpbmcgYWxnb3JpdGhtIGlzIGEgZGVlcCBjb21wYXJlXG4gICAgcmV0dXJuIGRlZXBEaWZmZXIocHJldlByb3AsIG5leHRQcm9wKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlRGVsZXRlZFZhbHVlc0luTmVzdGVkQXJyYXkoXG4gIHVwZGF0ZVBheWxvYWQsXG4gIG5vZGUsXG4gIHZhbGlkQXR0cmlidXRlc1xuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgdmFyIGkgPSBub2RlLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tICYmIHJlbW92ZWRLZXlDb3VudCA+IDApIHtcbiAgICAgIHJlc3RvcmVEZWxldGVkVmFsdWVzSW5OZXN0ZWRBcnJheShcbiAgICAgICAgdXBkYXRlUGF5bG9hZCxcbiAgICAgICAgbm9kZVtpXSxcbiAgICAgICAgdmFsaWRBdHRyaWJ1dGVzXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlICYmIHJlbW92ZWRLZXlDb3VudCA+IDApIHtcbiAgICB2YXIgb2JqID0gbm9kZTtcbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHJlbW92ZWRLZXlzKSB7XG4gICAgICBpZiAoIXJlbW92ZWRLZXlzW3Byb3BLZXldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5leHRQcm9wID0gb2JqW3Byb3BLZXldO1xuICAgICAgaWYgKG5leHRQcm9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVDb25maWcgPSB2YWxpZEF0dHJpYnV0ZXNbcHJvcEtleV07XG4gICAgICBpZiAoIWF0dHJpYnV0ZUNvbmZpZykge1xuICAgICAgICBjb250aW51ZTsgLy8gbm90IGEgdmFsaWQgbmF0aXZlIHByb3BcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG5leHRQcm9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZUNvbmZpZyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBjYXNlOiAhT2JqZWN0IGlzIHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgICAgdXBkYXRlUGF5bG9hZFtwcm9wS2V5XSA9IG5leHRQcm9wO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZUNvbmZpZy5kaWZmID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZUNvbmZpZy5wcm9jZXNzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICAvLyBjYXNlOiBDdXN0b21BdHRyaWJ1dGVDb25maWd1cmF0aW9uXG4gICAgICAgIHZhciBuZXh0VmFsdWUgPVxuICAgICAgICAgIHR5cGVvZiBhdHRyaWJ1dGVDb25maWcucHJvY2VzcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IGF0dHJpYnV0ZUNvbmZpZy5wcm9jZXNzKG5leHRQcm9wKVxuICAgICAgICAgICAgOiBuZXh0UHJvcDtcbiAgICAgICAgdXBkYXRlUGF5bG9hZFtwcm9wS2V5XSA9IG5leHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZWRLZXlzW3Byb3BLZXldID0gZmFsc2U7XG4gICAgICByZW1vdmVkS2V5Q291bnQtLTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZk5lc3RlZEFycmF5UHJvcGVydHkoXG4gIHVwZGF0ZVBheWxvYWQsXG4gIHByZXZBcnJheSxcbiAgbmV4dEFycmF5LFxuICB2YWxpZEF0dHJpYnV0ZXNcbikge1xuICB2YXIgbWluTGVuZ3RoID1cbiAgICBwcmV2QXJyYXkubGVuZ3RoIDwgbmV4dEFycmF5Lmxlbmd0aCA/IHByZXZBcnJheS5sZW5ndGggOiBuZXh0QXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IHZvaWQgMDtcbiAgZm9yIChpID0gMDsgaSA8IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRGlmZiBhbnkgaXRlbXMgaW4gdGhlIGFycmF5IGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbi4gUmVwZWF0ZWQga2V5c1xuICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgbGF0ZXIgdmFsdWVzLlxuICAgIHVwZGF0ZVBheWxvYWQgPSBkaWZmTmVzdGVkUHJvcGVydHkoXG4gICAgICB1cGRhdGVQYXlsb2FkLFxuICAgICAgcHJldkFycmF5W2ldLFxuICAgICAgbmV4dEFycmF5W2ldLFxuICAgICAgdmFsaWRBdHRyaWJ1dGVzXG4gICAgKTtcbiAgfVxuICBmb3IgKDsgaSA8IHByZXZBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIC8vIENsZWFyIG91dCBhbGwgcmVtYWluaW5nIHByb3BlcnRpZXMuXG4gICAgdXBkYXRlUGF5bG9hZCA9IGNsZWFyTmVzdGVkUHJvcGVydHkoXG4gICAgICB1cGRhdGVQYXlsb2FkLFxuICAgICAgcHJldkFycmF5W2ldLFxuICAgICAgdmFsaWRBdHRyaWJ1dGVzXG4gICAgKTtcbiAgfVxuICBmb3IgKDsgaSA8IG5leHRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIC8vIEFkZCBhbGwgcmVtYWluaW5nIHByb3BlcnRpZXMuXG4gICAgdXBkYXRlUGF5bG9hZCA9IGFkZE5lc3RlZFByb3BlcnR5KFxuICAgICAgdXBkYXRlUGF5bG9hZCxcbiAgICAgIG5leHRBcnJheVtpXSxcbiAgICAgIHZhbGlkQXR0cmlidXRlc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZOZXN0ZWRQcm9wZXJ0eShcbiAgdXBkYXRlUGF5bG9hZCxcbiAgcHJldlByb3AsXG4gIG5leHRQcm9wLFxuICB2YWxpZEF0dHJpYnV0ZXNcbikge1xuICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgcHJldlByb3AgPT09IG5leHRQcm9wKSB7XG4gICAgLy8gSWYgbm8gcHJvcGVydGllcyBoYXZlIGJlZW4gYWRkZWQsIHRoZW4gd2UgY2FuIGJhaWwgb3V0IHF1aWNrbHkgb24gb2JqZWN0XG4gICAgLy8gZXF1YWxpdHkuXG4gICAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG4gIH1cblxuICBpZiAoIXByZXZQcm9wIHx8ICFuZXh0UHJvcCkge1xuICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgcmV0dXJuIGFkZE5lc3RlZFByb3BlcnR5KHVwZGF0ZVBheWxvYWQsIG5leHRQcm9wLCB2YWxpZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3ApIHtcbiAgICAgIHJldHVybiBjbGVhck5lc3RlZFByb3BlcnR5KHVwZGF0ZVBheWxvYWQsIHByZXZQcm9wLCB2YWxpZEF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShwcmV2UHJvcCkgJiYgIUFycmF5LmlzQXJyYXkobmV4dFByb3ApKSB7XG4gICAgLy8gQm90aCBhcmUgbGVhdmVzLCB3ZSBjYW4gZGlmZiB0aGUgbGVhdmVzLlxuICAgIHJldHVybiBkaWZmUHJvcGVydGllcyh1cGRhdGVQYXlsb2FkLCBwcmV2UHJvcCwgbmV4dFByb3AsIHZhbGlkQXR0cmlidXRlcyk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwcmV2UHJvcCkgJiYgQXJyYXkuaXNBcnJheShuZXh0UHJvcCkpIHtcbiAgICAvLyBCb3RoIGFyZSBhcnJheXMsIHdlIGNhbiBkaWZmIHRoZSBhcnJheXMuXG4gICAgcmV0dXJuIGRpZmZOZXN0ZWRBcnJheVByb3BlcnR5KFxuICAgICAgdXBkYXRlUGF5bG9hZCxcbiAgICAgIHByZXZQcm9wLFxuICAgICAgbmV4dFByb3AsXG4gICAgICB2YWxpZEF0dHJpYnV0ZXNcbiAgICApO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocHJldlByb3ApKSB7XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKFxuICAgICAgdXBkYXRlUGF5bG9hZCxcbiAgICAgIC8vICRGbG93Rml4TWUgLSBXZSBrbm93IHRoYXQgdGhpcyBpcyBhbHdheXMgYW4gb2JqZWN0IHdoZW4gdGhlIGlucHV0IGlzLlxuICAgICAgZmxhdHRlblN0eWxlKHByZXZQcm9wKSxcbiAgICAgIC8vICRGbG93Rml4TWUgLSBXZSBrbm93IHRoYXQgdGhpcyBpc24ndCBhbiBhcnJheSBiZWNhdXNlIG9mIGFib3ZlIGZsb3cuXG4gICAgICBuZXh0UHJvcCxcbiAgICAgIHZhbGlkQXR0cmlidXRlc1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoXG4gICAgdXBkYXRlUGF5bG9hZCxcbiAgICBwcmV2UHJvcCxcbiAgICAvLyAkRmxvd0ZpeE1lIC0gV2Uga25vdyB0aGF0IHRoaXMgaXMgYWx3YXlzIGFuIG9iamVjdCB3aGVuIHRoZSBpbnB1dCBpcy5cbiAgICBmbGF0dGVuU3R5bGUobmV4dFByb3ApLFxuICAgIHZhbGlkQXR0cmlidXRlc1xuICApO1xufVxuXG4vKipcbiAqIGFkZE5lc3RlZFByb3BlcnR5IHRha2VzIGEgc2luZ2xlIHNldCBvZiBwcm9wcyBhbmQgdmFsaWQgYXR0cmlidXRlXG4gKiBhdHRyaWJ1dGUgY29uZmlndXJhdGlvbnMuIEl0IHByb2Nlc3NlcyBlYWNoIHByb3AgYW5kIGFkZHMgaXQgdG8gdGhlXG4gKiB1cGRhdGVQYXlsb2FkLlxuICovXG5mdW5jdGlvbiBhZGROZXN0ZWRQcm9wZXJ0eSh1cGRhdGVQYXlsb2FkLCBuZXh0UHJvcCwgdmFsaWRBdHRyaWJ1dGVzKSB7XG4gIGlmICghbmV4dFByb3ApIHtcbiAgICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShuZXh0UHJvcCkpIHtcbiAgICAvLyBBZGQgZWFjaCBwcm9wZXJ0eSBvZiB0aGUgbGVhZi5cbiAgICByZXR1cm4gYWRkUHJvcGVydGllcyh1cGRhdGVQYXlsb2FkLCBuZXh0UHJvcCwgdmFsaWRBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dFByb3AubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBBZGQgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhcnJheS5cbiAgICB1cGRhdGVQYXlsb2FkID0gYWRkTmVzdGVkUHJvcGVydHkoXG4gICAgICB1cGRhdGVQYXlsb2FkLFxuICAgICAgbmV4dFByb3BbaV0sXG4gICAgICB2YWxpZEF0dHJpYnV0ZXNcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8qKlxuICogY2xlYXJOZXN0ZWRQcm9wZXJ0eSB0YWtlcyBhIHNpbmdsZSBzZXQgb2YgcHJvcHMgYW5kIHZhbGlkIGF0dHJpYnV0ZXMuIEl0XG4gKiBhZGRzIGEgbnVsbCBzZW50aW5lbCB0byB0aGUgdXBkYXRlUGF5bG9hZCwgZm9yIGVhY2ggcHJvcCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNsZWFyTmVzdGVkUHJvcGVydHkodXBkYXRlUGF5bG9hZCwgcHJldlByb3AsIHZhbGlkQXR0cmlidXRlcykge1xuICBpZiAoIXByZXZQcm9wKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkocHJldlByb3ApKSB7XG4gICAgLy8gQWRkIGVhY2ggcHJvcGVydHkgb2YgdGhlIGxlYWYuXG4gICAgcmV0dXJuIGNsZWFyUHJvcGVydGllcyh1cGRhdGVQYXlsb2FkLCBwcmV2UHJvcCwgdmFsaWRBdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldlByb3AubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBBZGQgYWxsIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhcnJheS5cbiAgICB1cGRhdGVQYXlsb2FkID0gY2xlYXJOZXN0ZWRQcm9wZXJ0eShcbiAgICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgICBwcmV2UHJvcFtpXSxcbiAgICAgIHZhbGlkQXR0cmlidXRlc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8qKlxuICogZGlmZlByb3BlcnRpZXMgdGFrZXMgdHdvIHNldHMgb2YgcHJvcHMgYW5kIGEgc2V0IG9mIHZhbGlkIGF0dHJpYnV0ZXNcbiAqIGFuZCB3cml0ZSB0byB1cGRhdGVQYXlsb2FkIHRoZSB2YWx1ZXMgdGhhdCBjaGFuZ2VkIG9yIHdlcmUgZGVsZXRlZC5cbiAqIElmIG5vIHVwZGF0ZVBheWxvYWQgaXMgcHJvdmlkZWQsIGEgbmV3IG9uZSBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZCBpZlxuICogYW55dGhpbmcgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXModXBkYXRlUGF5bG9hZCwgcHJldlByb3BzLCBuZXh0UHJvcHMsIHZhbGlkQXR0cmlidXRlcykge1xuICB2YXIgYXR0cmlidXRlQ29uZmlnID0gdm9pZCAwO1xuICB2YXIgbmV4dFByb3AgPSB2b2lkIDA7XG4gIHZhciBwcmV2UHJvcCA9IHZvaWQgMDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGF0dHJpYnV0ZUNvbmZpZyA9IHZhbGlkQXR0cmlidXRlc1twcm9wS2V5XTtcbiAgICBpZiAoIWF0dHJpYnV0ZUNvbmZpZykge1xuICAgICAgY29udGludWU7IC8vIG5vdCBhIHZhbGlkIG5hdGl2ZSBwcm9wXG4gICAgfVxuXG4gICAgcHJldlByb3AgPSBwcmV2UHJvcHNbcHJvcEtleV07XG4gICAgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG5cbiAgICAvLyBmdW5jdGlvbnMgYXJlIGNvbnZlcnRlZCB0byBib29sZWFucyBhcyBtYXJrZXJzIHRoYXQgdGhlIGFzc29jaWF0ZWRcbiAgICAvLyBldmVudHMgc2hvdWxkIGJlIHNlbnQgZnJvbSBuYXRpdmUuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBuZXh0UHJvcCA9IHRydWU7XG4gICAgICAvLyBJZiBuZXh0UHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgdGhlbiBkb24ndCBib3RoZXIgY2hhbmdpbmcgcHJldlByb3BcbiAgICAgIC8vIHNpbmNlIG5leHRQcm9wIHdpbGwgd2luIGFuZCBnbyBpbnRvIHRoZSB1cGRhdGVQYXlsb2FkIHJlZ2FyZGxlc3MuXG4gICAgICBpZiAodHlwZW9mIHByZXZQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJldlByb3AgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGV4cGxpY2l0IHZhbHVlIG9mIHVuZGVmaW5lZCBpcyB0cmVhdGVkIGFzIGEgbnVsbCBiZWNhdXNlIGl0IG92ZXJyaWRlc1xuICAgIC8vIGFueSBvdGhlciBwcmVjZWRpbmcgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBwcmV2UHJvcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBwcmV2UHJvcCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbW92ZWRLZXlzKSB7XG4gICAgICByZW1vdmVkS2V5c1twcm9wS2V5XSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVQYXlsb2FkICYmIHVwZGF0ZVBheWxvYWRbcHJvcEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU29tZXRoaW5nIGVsc2UgYWxyZWFkeSB0cmlnZ2VyZWQgYW4gdXBkYXRlIHRvIHRoaXMga2V5IGJlY2F1c2UgYW5vdGhlclxuICAgICAgLy8gdmFsdWUgZGlmZmVkLiBTaW5jZSB3ZSdyZSBub3cgbGF0ZXIgaW4gdGhlIG5lc3RlZCBhcnJheXMgb3VyIHZhbHVlIGlzXG4gICAgICAvLyBtb3JlIGltcG9ydGFudCBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBpdCBhbmQgb3ZlcnJpZGUgdGhlIGV4aXN0aW5nXG4gICAgICAvLyB2YWx1ZS4gSXQgZG9lc24ndCBtYXR0ZXIgaWYgbm90aGluZyBjaGFuZ2VkLCB3ZSdsbCBzZXQgaXQgYW55d2F5LlxuXG4gICAgICAvLyBQYXR0ZXJuIG1hdGNoIG9uOiBhdHRyaWJ1dGVDb25maWdcbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlQ29uZmlnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIGNhc2U6ICFPYmplY3QgaXMgdGhlIGRlZmF1bHQgY2FzZVxuICAgICAgICB1cGRhdGVQYXlsb2FkW3Byb3BLZXldID0gbmV4dFByb3A7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2YgYXR0cmlidXRlQ29uZmlnLmRpZmYgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgICB0eXBlb2YgYXR0cmlidXRlQ29uZmlnLnByb2Nlc3MgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgIC8vIGNhc2U6IEN1c3RvbUF0dHJpYnV0ZUNvbmZpZ3VyYXRpb25cbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9XG4gICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZUNvbmZpZy5wcm9jZXNzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gYXR0cmlidXRlQ29uZmlnLnByb2Nlc3MobmV4dFByb3ApXG4gICAgICAgICAgICA6IG5leHRQcm9wO1xuICAgICAgICB1cGRhdGVQYXlsb2FkW3Byb3BLZXldID0gbmV4dFZhbHVlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZQcm9wID09PSBuZXh0UHJvcCkge1xuICAgICAgY29udGludWU7IC8vIG5vdGhpbmcgY2hhbmdlZFxuICAgIH1cblxuICAgIC8vIFBhdHRlcm4gbWF0Y2ggb246IGF0dHJpYnV0ZUNvbmZpZ1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlQ29uZmlnICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAvLyBjYXNlOiAhT2JqZWN0IGlzIHRoZSBkZWZhdWx0IGNhc2VcbiAgICAgIGlmIChkZWZhdWx0RGlmZmVyKHByZXZQcm9wLCBuZXh0UHJvcCkpIHtcbiAgICAgICAgLy8gYSBub3JtYWwgbGVhZiBoYXMgY2hhbmdlZFxuICAgICAgICAodXBkYXRlUGF5bG9hZCB8fCAodXBkYXRlUGF5bG9hZCA9IHt9KSlbcHJvcEtleV0gPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdHlwZW9mIGF0dHJpYnV0ZUNvbmZpZy5kaWZmID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGVDb25maWcucHJvY2VzcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAvLyBjYXNlOiBDdXN0b21BdHRyaWJ1dGVDb25maWd1cmF0aW9uXG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID1cbiAgICAgICAgcHJldlByb3AgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAodHlwZW9mIGF0dHJpYnV0ZUNvbmZpZy5kaWZmID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGF0dHJpYnV0ZUNvbmZpZy5kaWZmKHByZXZQcm9wLCBuZXh0UHJvcClcbiAgICAgICAgICA6IGRlZmF1bHREaWZmZXIocHJldlByb3AsIG5leHRQcm9wKSk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIHZhciBfbmV4dFZhbHVlID1cbiAgICAgICAgICB0eXBlb2YgYXR0cmlidXRlQ29uZmlnLnByb2Nlc3MgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBhdHRyaWJ1dGVDb25maWcucHJvY2VzcyhuZXh0UHJvcClcbiAgICAgICAgICAgIDogbmV4dFByb3A7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkIHx8ICh1cGRhdGVQYXlsb2FkID0ge30pKVtwcm9wS2V5XSA9IF9uZXh0VmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlZmF1bHQ6IGZhbGx0aHJvdWdoIGNhc2Ugd2hlbiBuZXN0ZWQgcHJvcGVydGllcyBhcmUgZGVmaW5lZFxuICAgICAgcmVtb3ZlZEtleXMgPSBudWxsO1xuICAgICAgcmVtb3ZlZEtleUNvdW50ID0gMDtcbiAgICAgIC8vIFdlIHRoaW5rIHRoYXQgYXR0cmlidXRlQ29uZmlnIGlzIG5vdCBDdXN0b21BdHRyaWJ1dGVDb25maWd1cmF0aW9uIGF0XG4gICAgICAvLyB0aGlzIHBvaW50IHNvIHdlIGFzc3VtZSBpdCBtdXN0IGJlIEF0dHJpYnV0ZUNvbmZpZ3VyYXRpb24uXG4gICAgICB1cGRhdGVQYXlsb2FkID0gZGlmZk5lc3RlZFByb3BlcnR5KFxuICAgICAgICB1cGRhdGVQYXlsb2FkLFxuICAgICAgICBwcmV2UHJvcCxcbiAgICAgICAgbmV4dFByb3AsXG4gICAgICAgIGF0dHJpYnV0ZUNvbmZpZ1xuICAgICAgKTtcbiAgICAgIGlmIChyZW1vdmVkS2V5Q291bnQgPiAwICYmIHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgcmVzdG9yZURlbGV0ZWRWYWx1ZXNJbk5lc3RlZEFycmF5KFxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgICAgICAgbmV4dFByb3AsXG4gICAgICAgICAgYXR0cmlidXRlQ29uZmlnXG4gICAgICAgICk7XG4gICAgICAgIHJlbW92ZWRLZXlzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBbHNvIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdGhlIHByZXZpb3VzIHByb3BzIHRvIGNhdGNoIGFueSB0aGF0IGhhdmUgYmVlblxuICAvLyByZW1vdmVkIGFuZCBtYWtlIHN1cmUgbmF0aXZlIGdldHMgdGhlIHNpZ25hbCBzbyBpdCBjYW4gcmVzZXQgdGhlbSB0byB0aGVcbiAgLy8gZGVmYXVsdC5cbiAgZm9yICh2YXIgX3Byb3BLZXkgaW4gcHJldlByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wc1tfcHJvcEtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7IC8vIHdlJ3ZlIGFscmVhZHkgY292ZXJlZCB0aGlzIGtleSBpbiB0aGUgcHJldmlvdXMgcGFzc1xuICAgIH1cbiAgICBhdHRyaWJ1dGVDb25maWcgPSB2YWxpZEF0dHJpYnV0ZXNbX3Byb3BLZXldO1xuICAgIGlmICghYXR0cmlidXRlQ29uZmlnKSB7XG4gICAgICBjb250aW51ZTsgLy8gbm90IGEgdmFsaWQgbmF0aXZlIHByb3BcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAmJiB1cGRhdGVQYXlsb2FkW19wcm9wS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIHdhcyBhbHJlYWR5IHVwZGF0ZWQgdG8gYSBkaWZmIHJlc3VsdCBlYXJsaWVyLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJldlByb3AgPSBwcmV2UHJvcHNbX3Byb3BLZXldO1xuICAgIGlmIChwcmV2UHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTsgLy8gd2FzIGFscmVhZHkgZW1wdHkgYW55d2F5XG4gICAgfVxuICAgIC8vIFBhdHRlcm4gbWF0Y2ggb246IGF0dHJpYnV0ZUNvbmZpZ1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGVDb25maWcgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgIHR5cGVvZiBhdHRyaWJ1dGVDb25maWcuZGlmZiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0eXBlb2YgYXR0cmlidXRlQ29uZmlnLnByb2Nlc3MgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgLy8gY2FzZTogQ3VzdG9tQXR0cmlidXRlQ29uZmlndXJhdGlvbiB8ICFPYmplY3RcbiAgICAgIC8vIEZsYWcgdGhlIGxlYWYgcHJvcGVydHkgZm9yIHJlbW92YWwgYnkgc2VuZGluZyBhIHNlbnRpbmVsLlxuICAgICAgKHVwZGF0ZVBheWxvYWQgfHwgKHVwZGF0ZVBheWxvYWQgPSB7fSkpW19wcm9wS2V5XSA9IG51bGw7XG4gICAgICBpZiAoIXJlbW92ZWRLZXlzKSB7XG4gICAgICAgIHJlbW92ZWRLZXlzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoIXJlbW92ZWRLZXlzW19wcm9wS2V5XSkge1xuICAgICAgICByZW1vdmVkS2V5c1tfcHJvcEtleV0gPSB0cnVlO1xuICAgICAgICByZW1vdmVkS2V5Q291bnQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVmYXVsdDpcbiAgICAgIC8vIFRoaXMgaXMgYSBuZXN0ZWQgYXR0cmlidXRlIGNvbmZpZ3VyYXRpb24gd2hlcmUgYWxsIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAvLyB3ZXJlIHJlbW92ZWQgc28gd2UgbmVlZCB0byBnbyB0aHJvdWdoIGFuZCBjbGVhciBvdXQgYWxsIG9mIHRoZW0uXG4gICAgICB1cGRhdGVQYXlsb2FkID0gY2xlYXJOZXN0ZWRQcm9wZXJ0eShcbiAgICAgICAgdXBkYXRlUGF5bG9hZCxcbiAgICAgICAgcHJldlByb3AsXG4gICAgICAgIGF0dHJpYnV0ZUNvbmZpZ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8qKlxuICogYWRkUHJvcGVydGllcyBhZGRzIGFsbCB0aGUgdmFsaWQgcHJvcHMgdG8gdGhlIHBheWxvYWQgYWZ0ZXIgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5mdW5jdGlvbiBhZGRQcm9wZXJ0aWVzKHVwZGF0ZVBheWxvYWQsIHByb3BzLCB2YWxpZEF0dHJpYnV0ZXMpIHtcbiAgLy8gVE9ETzogRmFzdCBwYXRoXG4gIHJldHVybiBkaWZmUHJvcGVydGllcyh1cGRhdGVQYXlsb2FkLCBlbXB0eU9iamVjdCwgcHJvcHMsIHZhbGlkQXR0cmlidXRlcyk7XG59XG5cbi8qKlxuICogY2xlYXJQcm9wZXJ0aWVzIGNsZWFycyBhbGwgdGhlIHByZXZpb3VzIHByb3BzIGJ5IGFkZGluZyBhIG51bGwgc2VudGluZWxcbiAqIHRvIHRoZSBwYXlsb2FkIGZvciBlYWNoIHZhbGlkIGtleS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJQcm9wZXJ0aWVzKHVwZGF0ZVBheWxvYWQsIHByZXZQcm9wcywgdmFsaWRBdHRyaWJ1dGVzKSB7XG4gIC8vIFRPRE86IEZhc3QgcGF0aFxuICByZXR1cm4gZGlmZlByb3BlcnRpZXModXBkYXRlUGF5bG9hZCwgcHJldlByb3BzLCBlbXB0eU9iamVjdCwgdmFsaWRBdHRyaWJ1dGVzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKHByb3BzLCB2YWxpZEF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGFkZFByb3BlcnRpZXMoXG4gICAgbnVsbCwgLy8gdXBkYXRlUGF5bG9hZFxuICAgIHByb3BzLFxuICAgIHZhbGlkQXR0cmlidXRlc1xuICApO1xufVxuXG5mdW5jdGlvbiBkaWZmKHByZXZQcm9wcywgbmV4dFByb3BzLCB2YWxpZEF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKFxuICAgIG51bGwsIC8vIHVwZGF0ZVBheWxvYWRcbiAgICBwcmV2UHJvcHMsXG4gICAgbmV4dFByb3BzLFxuICAgIHZhbGlkQXR0cmlidXRlc1xuICApO1xufVxuXG4vKipcbiAqIEluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBjbGVhbnVwIGNhbGxiYWNrcyBieSBjYW5jZWxsaW5nIHRoZW0gaW5zdGVhZCBvZlxuICogdXNpbmcgdGhpcy5cbiAqL1xuZnVuY3Rpb24gbW91bnRTYWZlQ2FsbGJhY2tfTk9UX1JFQUxMWV9TQUZFKGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBUaGlzIHByb3RlY3RzIGFnYWluc3QgY3JlYXRlQ2xhc3MoKSBjb21wb25lbnRzLlxuICAgIC8vIFdlIGRvbid0IGtub3cgaWYgdGhlcmUgaXMgY29kZSBkZXBlbmRpbmcgb24gaXQuXG4gICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgaXNNb3VudGVkKCkgYmVjYXVzZSBldmVuIGFjY2Vzc2luZ1xuICAgIC8vIGlzTW91bnRlZCBwcm9wZXJ0eSBvbiBhIFJlYWN0IEVTNiBjbGFzcyB3aWxsIHRyaWdnZXIgYSB3YXJuaW5nLlxuICAgIGlmICh0eXBlb2YgY29udGV4dC5fX2lzTW91bnRlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmICghY29udGV4dC5fX2lzTW91bnRlZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZJWE1FOiB0aGVyZSB1c2VkIHRvIGJlIG90aGVyIGJyYW5jaGVzIHRoYXQgcHJvdGVjdGVkXG4gICAgLy8gYWdhaW5zdCB1bm1vdW50ZWQgaG9zdCBjb21wb25lbnRzLiBCdXQgUk4gaG9zdCBjb21wb25lbnRzIGRvbid0XG4gICAgLy8gZGVmaW5lIGlzTW91bnRlZCgpIGFueW1vcmUsIHNvIHRob3NlIGNoZWNrcyBkaWRuJ3QgZG8gYW55dGhpbmcuXG5cbiAgICAvLyBUaGV5IGNhdXNlZCBmYWxzZSBwb3NpdGl2ZSB3YXJuaW5nIG5vaXNlIHNvIHdlIHJlbW92ZWQgdGhlbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL2lzc3Vlcy8xODg2OCNpc3N1ZWNvbW1lbnQtNDEzNTc5MDk1XG5cbiAgICAvLyBIb3dldmVyLCB0aGlzIG1lYW5zIHRoYXQgdGhlIGNhbGxiYWNrIGlzIE5PVCBndWFyYW50ZWVkIHRvIGJlIHNhZmVcbiAgICAvLyBmb3IgaG9zdCBjb21wb25lbnRzLiBUaGUgc29sdXRpb24gd2Ugc2hvdWxkIGltcGxlbWVudCBpcyB0byBtYWtlXG4gICAgLy8gVUlNYW5hZ2VyLm1lYXN1cmUoKSBhbmQgc2ltaWxhciBjYWxscyB0cnVseSBjYW5jZWxhYmxlLiBUaGVuIHdlXG4gICAgLy8gY2FuIGNoYW5nZSBvdXIgb3duIGNvZGUgY2FsbGluZyB0aGVtIHRvIGNhbmNlbCB3aGVuIHNvbWV0aGluZyB1bm1vdW50cy5cblxuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0aHJvd09uU3R5bGVzUHJvcChjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmIChwcm9wcy5zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBvd25lciA9IGNvbXBvbmVudC5fb3duZXIgfHwgbnVsbDtcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgbXNnID1cbiAgICAgIFwiYHN0eWxlc2AgaXMgbm90IGEgc3VwcG9ydGVkIHByb3BlcnR5IG9mIGBcIiArXG4gICAgICBuYW1lICtcbiAgICAgIFwiYCwgZGlkIFwiICtcbiAgICAgIFwieW91IG1lYW4gYHN0eWxlYCAoc2luZ3VsYXIpP1wiO1xuICAgIGlmIChvd25lciAmJiBvd25lci5jb25zdHJ1Y3RvciAmJiBvd25lci5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkge1xuICAgICAgbXNnICs9XG4gICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIGBcIiArXG4gICAgICAgIG93bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lICtcbiAgICAgICAgXCJgIHBhcmVudCBcIiArXG4gICAgICAgIFwiIGNvbXBvbmVudC5cIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvclN0eWxlUHJvcHMocHJvcHMsIHZhbGlkQXR0cmlidXRlcykge1xuICBmb3IgKHZhciBrZXkgaW4gdmFsaWRBdHRyaWJ1dGVzLnN0eWxlKSB7XG4gICAgaWYgKCEodmFsaWRBdHRyaWJ1dGVzW2tleV0gfHwgcHJvcHNba2V5XSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJZb3UgYXJlIHNldHRpbmcgdGhlIHN0eWxlIGB7IFwiICtcbiAgICAgICAgICBrZXkgK1xuICAgICAgICAgIFwiOiAuLi4gfWAgYXMgYSBwcm9wLiBZb3UgXCIgK1xuICAgICAgICAgIFwic2hvdWxkIG5lc3QgaXQgaW4gYSBzdHlsZSBvYmplY3QuIFwiICtcbiAgICAgICAgICBcIkUuZy4gYHsgc3R5bGU6IHsgXCIgK1xuICAgICAgICAgIGtleSArXG4gICAgICAgICAgXCI6IC4uLiB9IH1gXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbi8vIE1vZHVsZXMgcHJvdmlkZWQgYnkgUk46XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGRlZmluZXMgdGhlIHNhbWUgbWV0aG9kcyBhcyBOYXRpdmVNZXRob2RzTWl4aW4gYnV0IHdpdGhvdXQgdGhlXG4gKiBmaW5kTm9kZUhhbmRsZSB3cmFwcGVyLiBUaGlzIHdyYXBwZXIgaXMgdW5uZWNlc3NhcnkgZm9yIEhvc3RDb21wb25lbnQgdmlld3NcbiAqIGFuZCB3b3VsZCBhbHNvIHJlc3VsdCBpbiBhIGNpcmN1bGFyIHJlcXVpcmUuanMgZGVwZW5kZW5jeSAoc2luY2VcbiAqIFJlYWN0TmF0aXZlRmliZXIgZGVwZW5kcyBvbiB0aGlzIGNvbXBvbmVudCBhbmQgTmF0aXZlTWV0aG9kc01peGluIGRlcGVuZHMgb25cbiAqIFJlYWN0TmF0aXZlRmliZXIpLlxuICovXG5cbnZhciBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmVhY3ROYXRpdmVGaWJlckhvc3RDb21wb25lbnQodGFnLCB2aWV3Q29uZmlnKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0TmF0aXZlRmliZXJIb3N0Q29tcG9uZW50KTtcblxuICAgIHRoaXMuX25hdGl2ZVRhZyA9IHRhZztcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMudmlld0NvbmZpZyA9IHZpZXdDb25maWc7XG4gIH1cblxuICBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgVGV4dElucHV0U3RhdGUuYmx1clRleHRJbnB1dCh0aGlzLl9uYXRpdmVUYWcpO1xuICB9O1xuXG4gIFJlYWN0TmF0aXZlRmliZXJIb3N0Q29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIFRleHRJbnB1dFN0YXRlLmZvY3VzVGV4dElucHV0KHRoaXMuX25hdGl2ZVRhZyk7XG4gIH07XG5cbiAgUmVhY3ROYXRpdmVGaWJlckhvc3RDb21wb25lbnQucHJvdG90eXBlLm1lYXN1cmUgPSBmdW5jdGlvbiBtZWFzdXJlKGNhbGxiYWNrKSB7XG4gICAgVUlNYW5hZ2VyLm1lYXN1cmUoXG4gICAgICB0aGlzLl9uYXRpdmVUYWcsXG4gICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgY2FsbGJhY2spXG4gICAgKTtcbiAgfTtcblxuICBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudC5wcm90b3R5cGUubWVhc3VyZUluV2luZG93ID0gZnVuY3Rpb24gbWVhc3VyZUluV2luZG93KFxuICAgIGNhbGxiYWNrXG4gICkge1xuICAgIFVJTWFuYWdlci5tZWFzdXJlSW5XaW5kb3coXG4gICAgICB0aGlzLl9uYXRpdmVUYWcsXG4gICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgY2FsbGJhY2spXG4gICAgKTtcbiAgfTtcblxuICBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudC5wcm90b3R5cGUubWVhc3VyZUxheW91dCA9IGZ1bmN0aW9uIG1lYXN1cmVMYXlvdXQoXG4gICAgcmVsYXRpdmVUb05hdGl2ZU5vZGUsXG4gICAgb25TdWNjZXNzLFxuICAgIG9uRmFpbCAvKiBjdXJyZW50bHkgdW51c2VkICovXG4gICkge1xuICAgIFVJTWFuYWdlci5tZWFzdXJlTGF5b3V0KFxuICAgICAgdGhpcy5fbmF0aXZlVGFnLFxuICAgICAgcmVsYXRpdmVUb05hdGl2ZU5vZGUsXG4gICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgb25GYWlsKSxcbiAgICAgIG1vdW50U2FmZUNhbGxiYWNrX05PVF9SRUFMTFlfU0FGRSh0aGlzLCBvblN1Y2Nlc3MpXG4gICAgKTtcbiAgfTtcblxuICBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudC5wcm90b3R5cGUuc2V0TmF0aXZlUHJvcHMgPSBmdW5jdGlvbiBzZXROYXRpdmVQcm9wcyhcbiAgICBuYXRpdmVQcm9wc1xuICApIHtcbiAgICB7XG4gICAgICB3YXJuRm9yU3R5bGVQcm9wcyhuYXRpdmVQcm9wcywgdGhpcy52aWV3Q29uZmlnLnZhbGlkQXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBjcmVhdGUobmF0aXZlUHJvcHMsIHRoaXMudmlld0NvbmZpZy52YWxpZEF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gQXZvaWQgdGhlIG92ZXJoZWFkIG9mIGJyaWRnZSBjYWxscyBpZiB0aGVyZSdzIG5vIHVwZGF0ZS5cbiAgICAvLyBUaGlzIGlzIGFuIGV4cGVuc2l2ZSBuby1vcCBmb3IgQW5kcm9pZCwgYW5kIGNhdXNlcyBhbiB1bm5lY2Vzc2FyeVxuICAgIC8vIHZpZXcgaW52YWxpZGF0aW9uIGZvciBjZXJ0YWluIGNvbXBvbmVudHMgKGVnIFJDVFRleHRJbnB1dCkgb24gaU9TLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9IG51bGwpIHtcbiAgICAgIFVJTWFuYWdlci51cGRhdGVWaWV3KFxuICAgICAgICB0aGlzLl9uYXRpdmVUYWcsXG4gICAgICAgIHRoaXMudmlld0NvbmZpZy51aVZpZXdDbGFzc05hbWUsXG4gICAgICAgIHVwZGF0ZVBheWxvYWRcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdE5hdGl2ZUZpYmVySG9zdENvbXBvbmVudDtcbn0pKCk7XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSBcImZ1bmN0aW9uXCI7XG5cbnZhciBub3ckMSA9IGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93XG4gID8gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIERhdGUubm93KCk7XG4gICAgfTtcblxudmFyIHNjaGVkdWxlZENhbGxiYWNrID0gbnVsbDtcbnZhciBmcmFtZURlYWRsaW5lID0gMDtcblxudmFyIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcmFtZURlYWRsaW5lIC0gbm93JDEoKTtcbiAgfSxcbiAgZGlkVGltZW91dDogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIHNldFRpbWVvdXRDYWxsYmFjaygpIHtcbiAgLy8gVE9ETyAoYnZhdWdobikgSGFyZC1jb2RlZCA1bXMgdW5ibG9ja3MgaW5pdGlhbCBhc3luYyB0ZXN0aW5nLlxuICAvLyBSZWFjdCBBUEkgcHJvYmFibHkgY2hhbmdpbmcgdG8gYm9vbGVhbiByYXRoZXIgdGhhbiB0aW1lIHJlbWFpbmluZy5cbiAgLy8gTG9uZ2VyLXRlcm0gcGxhbiBpcyB0byByZXdyaXRlIHRoaXMgdXNpbmcgc2hhcmVkIG1lbW9yeSxcbiAgLy8gQW5kIGp1c3QgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgYml0IGFzIHRoZSBib29sZWFuLlxuICBmcmFtZURlYWRsaW5lID0gbm93JDEoKSArIDU7XG5cbiAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkQ2FsbGJhY2s7XG4gIHNjaGVkdWxlZENhbGxiYWNrID0gbnVsbDtcbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gIH1cbn1cblxuLy8gUk4gaGFzIGEgcG9vciBwb2x5ZmlsbCBmb3IgcmVxdWVzdElkbGVDYWxsYmFjayBzbyB3ZSBhcmVuJ3QgdXNpbmcgaXQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHNob3J0LXRlcm0gdXNlIGFueXdheS5cbi8vIFdlIGFsc28gZG9uJ3QgaW1wbGVtZW50IGNhbmNlbCBmdW5jdGlvbmFsaXR5IGInYyBGaWJlciBkb2Vzbid0IGN1cnJlbnRseSBuZWVkIGl0LlxuZnVuY3Rpb24gc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrJDEoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgLy8gV2UgYXNzdW1lIG9ubHkgb25lIGNhbGxiYWNrIGlzIHNjaGVkdWxlZCBhdCBhIHRpbWUgYidjIHRoYXQncyBob3cgRmliZXIgd29ya3MuXG4gIHNjaGVkdWxlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHNldFRpbWVvdXRDYWxsYmFjaywgMSk7XG4gIHJldHVybiB0aW1lb3V0SWQ7IC8vIFRpbWVvdXRzIGFyZSBhbHdheXMgbnVtYmVycyBvbiBSTlxufVxuXG5mdW5jdGlvbiBjYW5jZWxEZWZlcnJlZENhbGxiYWNrJDEoY2FsbGJhY2tJRCkge1xuICBzY2hlZHVsZWRDYWxsYmFjayA9IG51bGw7XG4gIGNsZWFyVGltZW91dChjYWxsYmFja0lEKTsgLy8gVGltZW91dHMgYXJlIGFsd2F5cyBudW1iZXJzIG9uIFJOXG59XG5cbi8vIFJlbmRlcmVycyB0aGF0IGRvbid0IHN1cHBvcnQgcGVyc2lzdGVuY2Vcbi8vIGNhbiByZS1leHBvcnQgZXZlcnl0aGluZyBmcm9tIHRoaXMgbW9kdWxlLlxuXG5mdW5jdGlvbiBzaGltKCkge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgXCJUaGUgY3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHBlcnNpc3RlbmNlLiBcIiArXG4gICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gXCIgK1xuICAgICAgXCJQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICApO1xufVxuXG4vLyBQZXJzaXN0ZW5jZSAod2hlbiB1bnN1cHBvcnRlZClcbnZhciBzdXBwb3J0c1BlcnNpc3RlbmNlID0gZmFsc2U7XG52YXIgY2xvbmVJbnN0YW5jZSA9IHNoaW07XG52YXIgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBzaGltO1xudmFyIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHNoaW07XG52YXIgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHNoaW07XG52YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gc2hpbTtcblxuLy8gUmVuZGVyZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBoeWRyYXRpb25cbi8vIGNhbiByZS1leHBvcnQgZXZlcnl0aGluZyBmcm9tIHRoaXMgbW9kdWxlLlxuXG5mdW5jdGlvbiBzaGltJDEoKSB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICBcIlRoZSBjdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgaHlyYXRpb24uIFwiICtcbiAgICAgIFwiVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBcIiArXG4gICAgICBcIlBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICk7XG59XG5cbi8vIEh5ZHJhdGlvbiAod2hlbiB1bnN1cHBvcnRlZClcbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IHNoaW0kMTtcbnZhciBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gc2hpbSQxO1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IHNoaW0kMTtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IHNoaW0kMTtcbnZhciBoeWRyYXRlSW5zdGFuY2UgPSBzaGltJDE7XG52YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IHNoaW0kMTtcbnZhciBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gc2hpbSQxO1xudmFyIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UgPSBzaGltJDE7XG52YXIgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gc2hpbSQxO1xudmFyIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IHNoaW0kMTtcbnZhciBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gc2hpbSQxO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gc2hpbSQxO1xudmFyIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBzaGltJDE7XG52YXIgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBzaGltJDE7XG5cbi8vIE1vZHVsZXMgcHJvdmlkZWQgYnkgUk46XG4vLyBVbnVzZWRcblxudmFyIFVQREFURV9TSUdOQUwgPSB7fTtcbntcbiAgT2JqZWN0LmZyZWV6ZShVUERBVEVfU0lHTkFMKTtcbn1cblxuLy8gQ291bnRlciBmb3IgdW5pcXVlbHkgaWRlbnRpZnlpbmcgdmlld3MuXG4vLyAlIDEwID09PSAxIG1lYW5zIGl0IGlzIGEgcm9vdFRhZy5cbi8vICUgMiA9PT0gMCBtZWFucyBpdCBpcyBhIEZhYnJpYyB0YWcuXG52YXIgbmV4dFJlYWN0VGFnID0gMztcbmZ1bmN0aW9uIGFsbG9jYXRlVGFnKCkge1xuICB2YXIgdGFnID0gbmV4dFJlYWN0VGFnO1xuICBpZiAodGFnICUgMTAgPT09IDEpIHtcbiAgICB0YWcgKz0gMjtcbiAgfVxuICBuZXh0UmVhY3RUYWcgPSB0YWcgKyAyO1xuICByZXR1cm4gdGFnO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVVuY2FjaGVGaWJlck5vZGUobm9kZSkge1xuICBpZiAodHlwZW9mIG5vZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAvLyBMZWFmIG5vZGUgKGVnIHRleHQpXG4gICAgdW5jYWNoZUZpYmVyTm9kZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICB1bmNhY2hlRmliZXJOb2RlKG5vZGUuX25hdGl2ZVRhZyk7XG5cbiAgICBub2RlLl9jaGlsZHJlbi5mb3JFYWNoKHJlY3Vyc2l2ZWx5VW5jYWNoZUZpYmVyTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKFxuICB0eXBlLFxuICBwcm9wcyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICBob3N0Q29udGV4dCxcbiAgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZVxuKSB7XG4gIHZhciB0YWcgPSBhbGxvY2F0ZVRhZygpO1xuICB2YXIgdmlld0NvbmZpZyA9IFJlYWN0TmF0aXZlVmlld0NvbmZpZ1JlZ2lzdHJ5LmdldCh0eXBlKTtcblxuICB7XG4gICAgZm9yICh2YXIga2V5IGluIHZpZXdDb25maWcudmFsaWRBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBkZWVwRnJlZXplQW5kVGhyb3dPbk11dGF0aW9uSW5EZXYocHJvcHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW52YXJpYW50KFxuICAgIHR5cGUgIT09IFwiUkNUVmlld1wiIHx8ICFob3N0Q29udGV4dC5pc0luQVBhcmVudFRleHQsXG4gICAgXCJOZXN0aW5nIG9mIDxWaWV3PiB3aXRoaW4gPFRleHQ+IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLlwiXG4gICk7XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBjcmVhdGUocHJvcHMsIHZpZXdDb25maWcudmFsaWRBdHRyaWJ1dGVzKTtcblxuICBVSU1hbmFnZXIuY3JlYXRlVmlldyhcbiAgICB0YWcsIC8vIHJlYWN0VGFnXG4gICAgdmlld0NvbmZpZy51aVZpZXdDbGFzc05hbWUsIC8vIHZpZXdOYW1lXG4gICAgcm9vdENvbnRhaW5lckluc3RhbmNlLCAvLyByb290VGFnXG4gICAgdXBkYXRlUGF5bG9hZCAvLyBwcm9wc1xuICApO1xuXG4gIHZhciBjb21wb25lbnQgPSBuZXcgUmVhY3ROYXRpdmVGaWJlckhvc3RDb21wb25lbnQodGFnLCB2aWV3Q29uZmlnKTtcblxuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0YWcpO1xuICB1cGRhdGVGaWJlclByb3BzKHRhZywgcHJvcHMpO1xuXG4gIC8vIE5vdCBzdXJlIGhvdyB0byBhdm9pZCB0aGlzIGNhc3QuIEZsb3cgaXMgb2theSBpZiB0aGUgY29tcG9uZW50IGlzIGRlZmluZWRcbiAgLy8gaW4gdGhlIHNhbWUgZmlsZSBidXQgaWYgaXQncyBleHRlcm5hbCBpdCBjYW4ndCBzZWUgdGhlIHR5cGVzLlxuICByZXR1cm4gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gIHRleHQsXG4gIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgaG9zdENvbnRleHQsXG4gIGludGVybmFsSW5zdGFuY2VIYW5kbGVcbikge1xuICBpbnZhcmlhbnQoXG4gICAgaG9zdENvbnRleHQuaXNJbkFQYXJlbnRUZXh0LFxuICAgIFwiVGV4dCBzdHJpbmdzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgPFRleHQ+IGNvbXBvbmVudC5cIlxuICApO1xuXG4gIHZhciB0YWcgPSBhbGxvY2F0ZVRhZygpO1xuXG4gIFVJTWFuYWdlci5jcmVhdGVWaWV3KFxuICAgIHRhZywgLy8gcmVhY3RUYWdcbiAgICBcIlJDVFJhd1RleHRcIiwgLy8gdmlld05hbWVcbiAgICByb290Q29udGFpbmVySW5zdGFuY2UsIC8vIHJvb3RUYWdcbiAgICB7IHRleHQ6IHRleHQgfSAvLyBwcm9wc1xuICApO1xuXG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRhZyk7XG5cbiAgcmV0dXJuIHRhZztcbn1cblxuZnVuY3Rpb24gZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oXG4gIHBhcmVudEluc3RhbmNlLFxuICB0eXBlLFxuICBwcm9wcyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICBob3N0Q29udGV4dFxuKSB7XG4gIC8vIERvbid0IHNlbmQgYSBuby1vcCBtZXNzYWdlIG92ZXIgdGhlIGJyaWRnZS5cbiAgaWYgKHBhcmVudEluc3RhbmNlLl9jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNYXAgZnJvbSBjaGlsZCBvYmplY3RzIHRvIG5hdGl2ZSB0YWdzLlxuICAvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcGFzcyBhIGNvcHkgb2YgdGhlIEFycmF5IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBmcm96ZW4uXG4gIHZhciBuYXRpdmVUYWdzID0gcGFyZW50SW5zdGFuY2UuX2NoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCJcbiAgICAgID8gY2hpbGQgLy8gTGVhZiBub2RlIChlZyB0ZXh0KVxuICAgICAgOiBjaGlsZC5fbmF0aXZlVGFnO1xuICB9KTtcblxuICBVSU1hbmFnZXIuc2V0Q2hpbGRyZW4oXG4gICAgcGFyZW50SW5zdGFuY2UuX25hdGl2ZVRhZywgLy8gY29udGFpbmVyVGFnXG4gICAgbmF0aXZlVGFncyAvLyByZWFjdFRhZ3NcbiAgKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgcmV0dXJuIHsgaXNJbkFQYXJlbnRUZXh0OiBmYWxzZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHByZXZJc0luQVBhcmVudFRleHQgPSBwYXJlbnRIb3N0Q29udGV4dC5pc0luQVBhcmVudFRleHQ7XG4gIHZhciBpc0luQVBhcmVudFRleHQgPVxuICAgIHR5cGUgPT09IFwiQW5kcm9pZFRleHRJbnB1dFwiIHx8IC8vIEFuZHJvaWRcbiAgICB0eXBlID09PSBcIlJDVE11bHRpbGluZVRleHRJbnB1dFZpZXdcIiB8fCAvLyBpT1NcbiAgICB0eXBlID09PSBcIlJDVFNpbmdsZWxpbmVUZXh0SW5wdXRWaWV3XCIgfHwgLy8gaU9TXG4gICAgdHlwZSA9PT0gXCJSQ1RUZXh0XCIgfHxcbiAgICB0eXBlID09PSBcIlJDVFZpcnR1YWxUZXh0XCI7XG5cbiAgaWYgKHByZXZJc0luQVBhcmVudFRleHQgIT09IGlzSW5BUGFyZW50VGV4dCkge1xuICAgIHJldHVybiB7IGlzSW5BUGFyZW50VGV4dDogaXNJbkFQYXJlbnRUZXh0IH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcmVudEhvc3RDb250ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIC8vIE5vb3Bcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShcbiAgaW5zdGFuY2UsXG4gIHR5cGUsXG4gIG9sZFByb3BzLFxuICBuZXdQcm9wcyxcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICBob3N0Q29udGV4dFxuKSB7XG4gIHJldHVybiBVUERBVEVfU0lHTkFMO1xufVxuXG5mdW5jdGlvbiByZXNldEFmdGVyQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgLy8gTm9vcFxufVxuXG52YXIgbm93ID0gbm93JDE7XG52YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSB0cnVlO1xudmFyIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayQxO1xudmFyIGNhbmNlbERlZmVycmVkQ2FsbGJhY2sgPSBjYW5jZWxEZWZlcnJlZENhbGxiYWNrJDE7XG5cbnZhciBzY2hlZHVsZVRpbWVvdXQgPSBzZXRUaW1lb3V0O1xudmFyIGNhbmNlbFRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG52YXIgbm9UaW1lb3V0ID0gLTE7XG5cbmZ1bmN0aW9uIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICAvLyBUT0RPIChidmF1Z2huKSBSZXZpc2l0IHRoaXMgZGVjaXNpb24uXG4gIC8vIEFsd2F5cyByZXR1cm5pbmcgZmFsc2Ugc2ltcGxpZmllcyB0aGUgY3JlYXRlSW5zdGFuY2UoKSBpbXBsZW1lbnRhdGlvbixcbiAgLy8gQnV0IGNyZWF0ZXMgYW4gYWRkaXRpb25hbCBjaGlsZCBGaWJlciBmb3IgcmF3IHRleHQgY2hpbGRyZW4uXG4gIC8vIE5vIGFkZGl0aW9uYWwgbmF0aXZlIHZpZXdzIGFyZSBjcmVhdGVkIHRob3VnaC5cbiAgLy8gSXQncyBub3QgY2xlYXIgdG8gbWUgd2hpY2ggaXMgYmV0dGVyIHNvIEknbSBkZWZlcnJpbmcgZm9yIG5vdy5cbiAgLy8gTW9yZSBjb250ZXh0IEAgZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzg1NjAjZGlzY3Vzc2lvbl9yOTIxMTEzMDNcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgTXV0YXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzTXV0YXRpb24gPSB0cnVlO1xuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgdmFyIGNoaWxkVGFnID0gdHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiID8gY2hpbGQgOiBjaGlsZC5fbmF0aXZlVGFnO1xuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRJbnN0YW5jZS5fY2hpbGRyZW47XG4gIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gIGlmIChpbmRleCA+PSAwKSB7XG4gICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgIFVJTWFuYWdlci5tYW5hZ2VDaGlsZHJlbihcbiAgICAgIHBhcmVudEluc3RhbmNlLl9uYXRpdmVUYWcsIC8vIGNvbnRhaW5lclRhZ1xuICAgICAgW2luZGV4XSwgLy8gbW92ZUZyb21JbmRpY2VzXG4gICAgICBbY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIC8vIG1vdmVUb0luZGljZXNcbiAgICAgIFtdLCAvLyBhZGRDaGlsZFJlYWN0VGFnc1xuICAgICAgW10sIC8vIGFkZEF0SW5kaWNlc1xuICAgICAgW10gLy8gcmVtb3ZlQXRJbmRpY2VzXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgIFVJTWFuYWdlci5tYW5hZ2VDaGlsZHJlbihcbiAgICAgIHBhcmVudEluc3RhbmNlLl9uYXRpdmVUYWcsIC8vIGNvbnRhaW5lclRhZ1xuICAgICAgW10sIC8vIG1vdmVGcm9tSW5kaWNlc1xuICAgICAgW10sIC8vIG1vdmVUb0luZGljZXNcbiAgICAgIFtjaGlsZFRhZ10sIC8vIGFkZENoaWxkUmVhY3RUYWdzXG4gICAgICBbY2hpbGRyZW4ubGVuZ3RoIC0gMV0sIC8vIGFkZEF0SW5kaWNlc1xuICAgICAgW10gLy8gcmVtb3ZlQXRJbmRpY2VzXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICB2YXIgY2hpbGRUYWcgPSB0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCIgPyBjaGlsZCA6IGNoaWxkLl9uYXRpdmVUYWc7XG4gIFVJTWFuYWdlci5zZXRDaGlsZHJlbihcbiAgICBwYXJlbnRJbnN0YW5jZSwgLy8gY29udGFpbmVyVGFnXG4gICAgW2NoaWxkVGFnXSAvLyByZWFjdFRhZ3NcbiAgKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgVUlNYW5hZ2VyLnVwZGF0ZVZpZXcoXG4gICAgdGV4dEluc3RhbmNlLCAvLyByZWFjdFRhZ1xuICAgIFwiUkNUUmF3VGV4dFwiLCAvLyB2aWV3TmFtZVxuICAgIHsgdGV4dDogbmV3VGV4dCB9IC8vIHByb3BzXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShcbiAgaW5zdGFuY2UsXG4gIHVwZGF0ZVBheWxvYWRUT0RPLFxuICB0eXBlLFxuICBvbGRQcm9wcyxcbiAgbmV3UHJvcHMsXG4gIGludGVybmFsSW5zdGFuY2VIYW5kbGVcbikge1xuICB2YXIgdmlld0NvbmZpZyA9IGluc3RhbmNlLnZpZXdDb25maWc7XG5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZS5fbmF0aXZlVGFnLCBuZXdQcm9wcyk7XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBkaWZmKG9sZFByb3BzLCBuZXdQcm9wcywgdmlld0NvbmZpZy52YWxpZEF0dHJpYnV0ZXMpO1xuXG4gIC8vIEF2b2lkIHRoZSBvdmVyaGVhZCBvZiBicmlkZ2UgY2FsbHMgaWYgdGhlcmUncyBubyB1cGRhdGUuXG4gIC8vIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG5vLW9wIGZvciBBbmRyb2lkLCBhbmQgY2F1c2VzIGFuIHVubmVjZXNzYXJ5XG4gIC8vIHZpZXcgaW52YWxpZGF0aW9uIGZvciBjZXJ0YWluIGNvbXBvbmVudHMgKGVnIFJDVFRleHRJbnB1dCkgb24gaU9TLlxuICBpZiAodXBkYXRlUGF5bG9hZCAhPSBudWxsKSB7XG4gICAgVUlNYW5hZ2VyLnVwZGF0ZVZpZXcoXG4gICAgICBpbnN0YW5jZS5fbmF0aXZlVGFnLCAvLyByZWFjdFRhZ1xuICAgICAgdmlld0NvbmZpZy51aVZpZXdDbGFzc05hbWUsIC8vIHZpZXdOYW1lXG4gICAgICB1cGRhdGVQYXlsb2FkIC8vIHByb3BzXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRJbnN0YW5jZS5fY2hpbGRyZW47XG4gIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gIC8vIE1vdmUgZXhpc3RpbmcgY2hpbGQgb3IgYWRkIG5ldyBjaGlsZD9cbiAgaWYgKGluZGV4ID49IDApIHtcbiAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHZhciBiZWZvcmVDaGlsZEluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gICAgY2hpbGRyZW4uc3BsaWNlKGJlZm9yZUNoaWxkSW5kZXgsIDAsIGNoaWxkKTtcblxuICAgIFVJTWFuYWdlci5tYW5hZ2VDaGlsZHJlbihcbiAgICAgIHBhcmVudEluc3RhbmNlLl9uYXRpdmVUYWcsIC8vIGNvbnRhaW5lcklEXG4gICAgICBbaW5kZXhdLCAvLyBtb3ZlRnJvbUluZGljZXNcbiAgICAgIFtiZWZvcmVDaGlsZEluZGV4XSwgLy8gbW92ZVRvSW5kaWNlc1xuICAgICAgW10sIC8vIGFkZENoaWxkUmVhY3RUYWdzXG4gICAgICBbXSwgLy8gYWRkQXRJbmRpY2VzXG4gICAgICBbXSAvLyByZW1vdmVBdEluZGljZXNcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHZhciBfYmVmb3JlQ2hpbGRJbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoYmVmb3JlQ2hpbGQpO1xuICAgIGNoaWxkcmVuLnNwbGljZShfYmVmb3JlQ2hpbGRJbmRleCwgMCwgY2hpbGQpO1xuXG4gICAgdmFyIGNoaWxkVGFnID0gdHlwZW9mIGNoaWxkID09PSBcIm51bWJlclwiID8gY2hpbGQgOiBjaGlsZC5fbmF0aXZlVGFnO1xuXG4gICAgVUlNYW5hZ2VyLm1hbmFnZUNoaWxkcmVuKFxuICAgICAgcGFyZW50SW5zdGFuY2UuX25hdGl2ZVRhZywgLy8gY29udGFpbmVySURcbiAgICAgIFtdLCAvLyBtb3ZlRnJvbUluZGljZXNcbiAgICAgIFtdLCAvLyBtb3ZlVG9JbmRpY2VzXG4gICAgICBbY2hpbGRUYWddLCAvLyBhZGRDaGlsZFJlYWN0VGFnc1xuICAgICAgW19iZWZvcmVDaGlsZEluZGV4XSwgLy8gYWRkQXRJbmRpY2VzXG4gICAgICBbXSAvLyByZW1vdmVBdEluZGljZXNcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgLy8gVE9ETyAoYnZhdWdobik6IFJlbW92ZSB0aGlzIGNoZWNrIHdoZW4uLi5cbiAgLy8gV2UgY3JlYXRlIGEgd3JhcHBlciBvYmplY3QgZm9yIHRoZSBjb250YWluZXIgaW4gUmVhY3ROYXRpdmUgcmVuZGVyKClcbiAgLy8gT3Igd2UgcmVmYWN0b3IgdG8gcmVtb3ZlIHdyYXBwZXIgb2JqZWN0cyBlbnRpcmVseS5cbiAgLy8gRm9yIG1vcmUgaW5mbyBvbiBwcm9zL2NvbnMgc2VlIFBSICM4NTYwIGRlc2NyaXB0aW9uLlxuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIHBhcmVudEluc3RhbmNlICE9PSBcIm51bWJlclwiLFxuICAgIFwiQ29udGFpbmVyIGRvZXMgbm90IHN1cHBvcnQgaW5zZXJ0QmVmb3JlIG9wZXJhdGlvblwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICByZWN1cnNpdmVseVVuY2FjaGVGaWJlck5vZGUoY2hpbGQpO1xuICB2YXIgY2hpbGRyZW4gPSBwYXJlbnRJbnN0YW5jZS5fY2hpbGRyZW47XG4gIHZhciBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuXG4gIGNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG5cbiAgVUlNYW5hZ2VyLm1hbmFnZUNoaWxkcmVuKFxuICAgIHBhcmVudEluc3RhbmNlLl9uYXRpdmVUYWcsIC8vIGNvbnRhaW5lcklEXG4gICAgW10sIC8vIG1vdmVGcm9tSW5kaWNlc1xuICAgIFtdLCAvLyBtb3ZlVG9JbmRpY2VzXG4gICAgW10sIC8vIGFkZENoaWxkUmVhY3RUYWdzXG4gICAgW10sIC8vIGFkZEF0SW5kaWNlc1xuICAgIFtpbmRleF0gLy8gcmVtb3ZlQXRJbmRpY2VzXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcmVjdXJzaXZlbHlVbmNhY2hlRmliZXJOb2RlKGNoaWxkKTtcbiAgVUlNYW5hZ2VyLm1hbmFnZUNoaWxkcmVuKFxuICAgIHBhcmVudEluc3RhbmNlLCAvLyBjb250YWluZXJJRFxuICAgIFtdLCAvLyBtb3ZlRnJvbUluZGljZXNcbiAgICBbXSwgLy8gbW92ZVRvSW5kaWNlc1xuICAgIFtdLCAvLyBhZGRDaGlsZFJlYWN0VGFnc1xuICAgIFtdLCAvLyBhZGRBdEluZGljZXNcbiAgICBbMF0gLy8gcmVtb3ZlQXRJbmRpY2VzXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoaW5zdGFuY2UpIHtcbiAgLy8gTm9vcFxufVxuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbihuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9IFwiXCI7XG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgcGF0aCA9IHNvdXJjZS5maWxlTmFtZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCBcIlwiKTtcbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBwYXRoQmVmb3JlU2xhc2ggPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgXCJcIik7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGZvbGRlck5hbWUgKyBcIi9cIiArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VJbmZvID0gXCIgKGF0IFwiICsgZmlsZU5hbWUgKyBcIjpcIiArIHNvdXJjZS5saW5lTnVtYmVyICsgXCIpXCI7XG4gIH0gZWxzZSBpZiAob3duZXJOYW1lKSB7XG4gICAgc291cmNlSW5mbyA9IFwiIChjcmVhdGVkIGJ5IFwiICsgb3duZXJOYW1lICsgXCIpXCI7XG4gIH1cbiAgcmV0dXJuIFwiXFxuICAgIGluIFwiICsgKG5hbWUgfHwgXCJVbmtub3duXCIpICsgc291cmNlSW5mbztcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnRMYXp5OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9IFwiXCI7XG4gIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG4gIGRvIHtcbiAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGluZm87XG59XG5cbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBwaGFzZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICBjdXJyZW50ID0gbnVsbDtcbiAgICBwaGFzZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIHBoYXNlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UobGlmZUN5Y2xlUGhhc2UpIHtcbiAge1xuICAgIHBoYXNlID0gbGlmZUN5Y2xlUGhhc2U7XG4gIH1cbn1cblxudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyA9IGZhbHNlO1xudmFyIGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgPSBmYWxzZTtcbnZhciBlbmFibGVTdXNwZW5zZSA9IGZhbHNlO1xudmFyIGVuYWJsZVVzZXJUaW1pbmdBUEkgPSB0cnVlO1xudmFyIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrID0gdHJ1ZTtcbnZhciB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGVyVGltZXIgPSB0cnVlO1xudmFyIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgPSB0cnVlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLy8gUHJlZml4IG1lYXN1cmVtZW50cyBzbyB0aGF0IGl0J3MgcG9zc2libGUgdG8gZmlsdGVyIHRoZW0uXG4vLyBMb25nZXIgcHJlZml4ZXMgYXJlIGhhcmQgdG8gcmVhZCBpbiBEZXZUb29scy5cbnZhciByZWFjdEVtb2ppID0gXCJcXHUyNjlCXCI7XG52YXIgd2FybmluZ0Vtb2ppID0gXCJcXHUyNkQ0XCI7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID1cbiAgdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09IFwiZnVuY3Rpb25cIiAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gXCJmdW5jdGlvblwiICYmXG4gIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbihtYXJrTmFtZSkge1xuICByZXR1cm4gcmVhY3RFbW9qaSArIFwiIFwiICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbihsYWJlbCwgd2FybmluZykge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyA/IHdhcm5pbmdFbW9qaSArIFwiIFwiIDogcmVhY3RFbW9qaSArIFwiIFwiO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyA/IFwiIFdhcm5pbmc6IFwiICsgd2FybmluZyA6IFwiXCI7XG4gIHJldHVybiBcIlwiICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24obWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBlbmRNYXJrID0gZnVuY3Rpb24obGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmcpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24obGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgXCIgKCNcIiArIGRlYnVnSUQgKyBcIilcIjtcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24oY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArIFwiIFtcIiArIChpc01vdW50ZWQgPyBcInVwZGF0ZVwiIDogXCJtb3VudFwiKSArIFwiXVwiO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArIFwiLlwiICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgXCJVbmtub3duXCI7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbihmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8IFwiVW5rbm93blwiO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbihmaWJlciwgcGhhc2UsIHdhcm5pbmcpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8IFwiVW5rbm93blwiO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmcpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24oZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uKCkge1xuICAvLyBTdG9wcyBhbGwgY3VycmVudGx5IGFjdGl2ZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXN1bWVkXG4gIC8vIGlmIHdlIGNvbnRpbnVlIGluIGEgbGF0ZXIgZGVmZXJyZWQgbG9vcCBmcm9tIHRoZSBzYW1lIHVuaXQgb2Ygd29yay5cbiAgdmFyIGZpYmVyID0gY3VycmVudEZpYmVyO1xuICB3aGlsZSAoZmliZXIpIHtcbiAgICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59O1xuXG52YXIgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkgPSBmdW5jdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIucmV0dXJuICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXIucmV0dXJuKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbigpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBjdXJyZW50UGhhc2UgIT09IG51bGwgJiZcbiAgICAgIGN1cnJlbnRQaGFzZSAhPT0gXCJjb21wb25lbnRXaWxsTW91bnRcIiAmJlxuICAgICAgY3VycmVudFBoYXNlICE9PSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIlxuICAgICkge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcgJiYgIWlzV2FpdGluZ0ZvckNhbGxiYWNrKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IHRydWU7XG4gICAgICBiZWdpbk1hcmsoXCIoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pXCIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlLCBleHBpcmF0aW9uVGltZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4gICAgICB2YXIgd2FybmluZyA9IGRpZEV4cGlyZSA/IFwiUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWRcIiA6IG51bGw7XG4gICAgICBlbmRNYXJrKFxuICAgICAgICBcIihXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiB3aWxsIGZvcmNlIGZsdXNoIGluIFwiICtcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSArXG4gICAgICAgICAgXCIgbXMpXCIsXG4gICAgICAgIFwiKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKVwiLFxuICAgICAgICB3YXJuaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmcgPSBcIkFuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnlcIjtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmcgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZVxuICAgICAgICA/IFwiU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZVwiXG4gICAgICAgIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyayhcIihSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKVwiKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSwgZGlkQ29tcGxldGVSb290KSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhcm5pbmcgPSBudWxsO1xuICAgIGlmIChpbnRlcnJ1cHRlZEJ5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaW50ZXJydXB0ZWRCeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHdhcm5pbmcgPSBcIkEgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeS50eXBlKSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgd2FybmluZyA9XG4gICAgICAgICAgXCJBbiB1cGRhdGUgdG8gXCIgKyBjb21wb25lbnROYW1lICsgXCIgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlclwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDEpIHtcbiAgICAgIHdhcm5pbmcgPSBcIlRoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXNcIjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgdmFyIGxhYmVsID0gZGlkQ29tcGxldGVSb290XG4gICAgICA/IFwiKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IENvbXBsZXRlZCBSb290KVwiXG4gICAgICA6IFwiKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IFlpZWxkZWQpXCI7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyayhsYWJlbCwgXCIoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbilcIiwgd2FybmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyayhcIihDb21taXR0aW5nIENoYW5nZXMpXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nID0gbnVsbDtcbiAgICBpZiAoaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0KSB7XG4gICAgICB3YXJuaW5nID0gXCJMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlXCI7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyA9IFwiQ2F1c2VkIGJ5IGEgY2FzY2FkaW5nIHVwZGF0ZSBpbiBlYXJsaWVyIGNvbW1pdFwiO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKFwiKENvbW1pdHRpbmcgQ2hhbmdlcylcIiwgXCIoQ29tbWl0dGluZyBDaGFuZ2VzKVwiLCB3YXJuaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFNuYXBzaG90RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoXCIoQ29tbWl0dGluZyBTbmFwc2hvdCBFZmZlY3RzKVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoXG4gICAgICBcIihDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHM6IFwiICsgY291bnQgKyBcIiBUb3RhbClcIixcbiAgICAgIFwiKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0cylcIixcbiAgICAgIG51bGxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKFwiKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyayhcbiAgICAgIFwiKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiBcIiArIGNvdW50ICsgXCIgVG90YWwpXCIsXG4gICAgICBcIihDb21taXR0aW5nIEhvc3QgRWZmZWN0cylcIixcbiAgICAgIG51bGxcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoXCIoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcylcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyayhcbiAgICAgIFwiKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHM6IFwiICsgY291bnQgKyBcIiBUb3RhbClcIixcbiAgICAgIFwiKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpXCIsXG4gICAgICBudWxsXG4gICAgKTtcbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG52YXIgZmliZXJTdGFjayA9IHZvaWQgMDtcblxue1xuICBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwiVW5leHBlY3RlZCBwb3AuXCIpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcIlVuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuXG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja1RoYXRTdGFja0lzRW1wdHkoKSB7XG4gIHtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkV4cGVjdGVkIGFuIGVtcHR5IHN0YWNrLiBTb21ldGhpbmcgd2FzIG5vdCByZXNldCBwcm9wZXJseS5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRTdGFja0FmdGVyRmF0YWxFcnJvckluRGV2KCkge1xuICB7XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YWx1ZVN0YWNrLmxlbmd0aCA9IDA7XG4gICAgZmliZXJTdGFjay5sZW5ndGggPSAwO1xuICB9XG59XG5cbnZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufVxuXG4vLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihlbXB0eUNvbnRleHRPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dChcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyXG4pIHtcbiAgaWYgKGRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciAmJiBpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChcbiAgICBpbnN0YW5jZSAmJlxuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dFxuICApIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8IFwiVW5rbm93blwiO1xuICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgY29udGV4dFR5cGVzLFxuICAgICAgY29udGV4dCxcbiAgICAgIFwiY29udGV4dFwiLFxuICAgICAgbmFtZSxcbiAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXZcbiAgICApO1xuICB9XG5cbiAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG4gIHJldHVybiBjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gIGludmFyaWFudChcbiAgICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgIFwiVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBcIiArXG4gICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCB0eXBlLCBwYXJlbnRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcblxuICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgXCJVbmtub3duXCI7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kIFwiICtcbiAgICAgICAgICAgIFwib24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlIFwiICtcbiAgICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgc2V0Q3VycmVudFBoYXNlKFwiZ2V0Q2hpbGRDb250ZXh0XCIpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgXCJnZXRDaGlsZENvbnRleHRcIik7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgaW52YXJpYW50KFxuICAgICAgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLFxuICAgICAgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCBcIlVua25vd25cIixcbiAgICAgIGNvbnRleHRLZXlcbiAgICApO1xuICB9XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgXCJVbmtub3duXCI7XG4gICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICBjaGlsZENvbnRleHRUeXBlcyxcbiAgICAgIGNoaWxkQ29udGV4dCxcbiAgICAgIFwiY2hpbGQgY29udGV4dFwiLFxuICAgICAgbmFtZSxcbiAgICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgICAvLyBzb21lYm9keSBjYWxscyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGFuZCB3ZSBwcm9jZXNzXG4gICAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAgIC8vIGJlZW4gc2V0LiBUaGlzIGlzIHJhcmUgYW5kIGRvZXNuJ3QgbWF0dGVyLiBXZSdsbCBhbHNvIHJlbW92ZSB0aGF0IEFQSS5cbiAgICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXZcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9XG4gICAgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0KSB8fFxuICAgIGVtcHR5Q29udGV4dE9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goXG4gICAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvcixcbiAgICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3NcbiAgKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW52YXJpYW50KFxuICAgIGluc3RhbmNlLFxuICAgIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBcIiArXG4gICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICB0eXBlLFxuICAgICAgcHJldmlvdXNDb250ZXh0XG4gICAgKTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgaW52YXJpYW50KFxuICAgIGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJlxuICAgICAgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenkpLFxuICAgIFwiRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gXCIgK1xuICAgICAgXCJUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICk7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gbm9kZS50eXBlO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OiB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUobm9kZS50eXBlKTtcbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH0gd2hpbGUgKG5vZGUgIT09IG51bGwpO1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgXCJGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBcIiArXG4gICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcbn1cblxudmFyIG9uQ29tbWl0RmliZXJSb290ID0gbnVsbDtcbnZhciBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IG51bGw7XG52YXIgaGFzTG9nZ2VkRXJyb3IgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2F0Y2hFcnJvcnMoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIlJlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgIGVyclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgXCIgK1xuICAgICAgICAgIFwid2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiBcIiArXG4gICAgICAgICAgXCJodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgIC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG4gICAgb25Db21taXRGaWJlclJvb3QgPSBjYXRjaEVycm9ycyhmdW5jdGlvbihyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLlwiLFxuICAgICAgICBlcnJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIERldlRvb2xzIGV4aXN0c1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyUm9vdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgfVxufVxuXG4vLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzO1xuXG52YXIgTm9Xb3JrID0gMDtcbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IG1heFNpZ25lZDMxQml0SW50O1xuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAoKG1zIC8gVU5JVF9TSVpFKSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKCgobnVtIC8gcHJlY2lzaW9uKSB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiAoXG4gICAgTUFHSUNfTlVNQkVSX09GRlNFVCArXG4gICAgY2VpbGluZyhcbiAgICAgIGN1cnJlbnRUaW1lIC0gTUFHSUNfTlVNQkVSX09GRlNFVCArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLFxuICAgICAgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFXG4gICAgKVxuICApO1xufVxuXG52YXIgTE9XX1BSSU9SSVRZX0VYUElSQVRJT04gPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9CQVRDSF9TSVpFID0gMjUwO1xuXG5mdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChcbiAgICBjdXJyZW50VGltZSxcbiAgICBMT1dfUFJJT1JJVFlfRVhQSVJBVElPTixcbiAgICBMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRVxuICApO1xufVxuXG4vLyBXZSBpbnRlbnRpb25hbGx5IHNldCBhIGhpZ2hlciBleHBpcmF0aW9uIHRpbWUgZm9yIGludGVyYWN0aXZlIHVwZGF0ZXMgaW5cbi8vIGRldiB0aGFuIGluIHByb2R1Y3Rpb24uXG4vL1xuLy8gSWYgdGhlIG1haW4gdGhyZWFkIGlzIGJlaW5nIGJsb2NrZWQgc28gbG9uZyB0aGF0IHlvdSBoaXQgdGhlIGV4cGlyYXRpb24sXG4vLyBpdCdzIGEgcHJvYmxlbSB0aGF0IGNvdWxkIGJlIHNvbHZlZCB3aXRoIGJldHRlciBzY2hlZHVsaW5nLlxuLy9cbi8vIFBlb3BsZSB3aWxsIGJlIG1vcmUgbGlrZWx5IHRvIG5vdGljZSB0aGlzIGFuZCBmaXggaXQgd2l0aCB0aGUgbG9uZ1xuLy8gZXhwaXJhdGlvbiB0aW1lIGluIGRldmVsb3BtZW50LlxuLy9cbi8vIEluIHByb2R1Y3Rpb24gd2Ugb3B0IGZvciBiZXR0ZXIgVVggYXQgdGhlIHJpc2sgb2YgbWFza2luZyBzY2hlZHVsaW5nXG4vLyBwcm9ibGVtcywgYnkgZXhwaXJpbmcgZmFzdC5cbnZhciBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04gPSA1MDA7XG52YXIgSElHSF9QUklPUklUWV9CQVRDSF9TSVpFID0gMTAwO1xuXG5mdW5jdGlvbiBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChcbiAgICBjdXJyZW50VGltZSxcbiAgICBISUdIX1BSSU9SSVRZX0VYUElSQVRJT04sXG4gICAgSElHSF9QUklPUklUWV9CQVRDSF9TSVpFXG4gICk7XG59XG5cbnZhciBOb0NvbnRleHQgPSAwO1xudmFyIENvbmN1cnJlbnRNb2RlID0gMTtcbnZhciBTdHJpY3RNb2RlID0gMjtcbnZhciBQcm9maWxlTW9kZSA9IDQ7XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IHZvaWQgMDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICB2YXIgdGVzdE1hcCA9IG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIHZhciB0ZXN0U2V0ID0gbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBSb2xsdXAgdG8gbm90IGNvbnNpZGVyIHRoZXNlIHVudXNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTc3MVxuICAgIC8vIFRPRE86IHdlIGNhbiByZW1vdmUgdGhlc2UgaWYgUm9sbHVwIGZpeGVzIHRoZSBidWcuXG4gICAgdGVzdE1hcC5zZXQoMCwgMCk7XG4gICAgdGVzdFNldC5hZGQoMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cbnZhciBkZWJ1Z0NvdW50ZXIgPSB2b2lkIDA7XG5cbntcbiAgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5maXJzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcblxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB0aGlzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbih0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhmaWJlciwgQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudClcbiAgICAgID8gQ2xhc3NDb21wb25lbnRMYXp5XG4gICAgICA6IEZ1bmN0aW9uQ29tcG9uZW50TGF6eTtcbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZkxhenk7XG4gICAgfVxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfUFVSRV9UWVBFKSB7XG4gICAgICByZXR1cm4gUHVyZUNvbXBvbmVudExhenk7XG4gICAgfVxuICB9XG4gIHJldHVybiBJbmRldGVybWluYXRlQ29tcG9uZW50O1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihcbiAgICAgIGN1cnJlbnQudGFnLFxuICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgY3VycmVudC5rZXksXG4gICAgICBjdXJyZW50Lm1vZGVcbiAgICApO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEID0gY3VycmVudC5fZGVidWdJRDtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG5cbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuXG4gICAgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gY3VycmVudC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50LmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0NvbmN1cnJlbnQpIHtcbiAgdmFyIG1vZGUgPSBpc0NvbmN1cnJlbnQgPyBDb25jdXJyZW50TW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gIHZhciBmaWJlclRhZyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaWJlclRhZyA9IHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IENsYXNzQ29tcG9uZW50IDogSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgcGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAga2V5XG4gICAgICAgICk7XG4gICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gQ29uY3VycmVudE1vZGUgfCBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdE1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfUExBQ0VIT0xERVJfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBQbGFjZWhvbGRlckNvbXBvbmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcbiAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QVVJFX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gUHVyZUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICB0eXBlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGluZm8gKz1cbiAgICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgXCIgK1xuICAgICAgICAgICAgICBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgK1xuICAgICAgICAgICAgICBcIm5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkgOiBudWxsO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lck5hbWUgKyBcImAuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIFwiICtcbiAgICAgICAgICAgIFwiY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBcIiArXG4gICAgICAgICAgICBcImJ1dCBnb3Q6ICVzLiVzXCIsXG4gICAgICAgICAgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLFxuICAgICAgICAgIGluZm9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLnR5cGUgPSB0eXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgdHlwZW9mIHBlbmRpbmdQcm9wcy5vblJlbmRlciAhPT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBzdHJpbmcgYW5kIFwib25SZW5kZXJcIiBmdW5jdGlvbiBhcyBwcm9wcydcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpO1xuICBmaWJlci50eXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb0NvbnRleHQpO1xuICBmaWJlci50eXBlID0gXCJERUxFVEVEXCI7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG4vLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vQ29udGV4dCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IHNvdXJjZS5maXJzdENvbnRleHREZXBlbmRlbmN5O1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZWZmZWN0VGFnID0gc291cmNlLmVmZmVjdFRhZztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQuZXhwaXJhdGlvblRpbWUgPSBzb3VyY2UuZXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5jaGlsZEV4cGlyYXRpb25UaW1lID0gc291cmNlLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHRhcmdldC50cmVlQmFzZUR1cmF0aW9uID0gc291cmNlLnRyZWVCYXNlRHVyYXRpb247XG4gIH1cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBzb3VyY2UuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmc7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIFRPRE86IFRoaXMgc2hvdWxkIGJlIGxpZnRlZCBpbnRvIHRoZSByZW5kZXJlci5cblxuLy8gVGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzIGFyZSBvbmx5IHVzZWQgYnkgaW50ZXJhY3Rpb24gdHJhY2luZyBidWlsZHMuXG4vLyBUaGV5IGVuYWJsZSBpbnRlcmFjdGlvbnMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIGFzeW5jIHdvcmssXG4vLyBBbmQgZXhwb3NlIGludGVyYWN0aW9uIG1ldGFkYXRhIHRvIHRoZSBSZWFjdCBEZXZUb29scyBQcm9maWxlciBwbHVnaW4uXG4vLyBOb3RlIHRoYXQgdGhlc2UgYXR0cmlidXRlcyBhcmUgb25seSBkZWZpbmVkIHdoZW4gdGhlIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgZmxhZyBpcyBlbmFibGVkLlxuXG4vLyBFeHBvcnRlZCBGaWJlclJvb3QgdHlwZSBpbmNsdWRlcyBhbGwgcHJvcGVydGllcyxcbi8vIFRvIGF2b2lkIHJlcXVpcmluZyBwb3RlbnRpYWxseSBlcnJvci1wcm9uZSA6YW55IGNhc3RzIHRocm91Z2hvdXQgdGhlIHByb2plY3QuXG4vLyBQcm9maWxpbmcgcHJvcGVydGllcyBhcmUgb25seSBzYWZlIHRvIGFjY2VzcyBpbiBwcm9maWxpbmcgYnVpbGRzICh3aGVuIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgaXMgdHJ1ZSkuXG4vLyBUaGUgdHlwZXMgYXJlIGRlZmluZWQgc2VwYXJhdGVseSB3aXRoaW4gdGhpcyBmaWxlIHRvIGVuc3VyZSB0aGV5IHN0YXkgaW4gc3luYy5cbi8vIChXZSBkb24ndCBoYXZlIHRvIHVzZSBhbiBpbmxpbmUgOmFueSBjYXN0IHdoZW4gZW5hYmxlU2NoZWR1bGVyVHJhY2luZyBpcyBkaXNhYmxlZC4pXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBpc0NvbmN1cnJlbnQsIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKGlzQ29uY3VycmVudCk7XG5cbiAgdmFyIHJvb3QgPSB2b2lkIDA7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgcm9vdCA9IHtcbiAgICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG5cbiAgICAgIGVhcmxpZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFBlbmRpbmdUaW1lOiBOb1dvcmssXG4gICAgICBlYXJsaWVzdFN1c3BlbmRlZFRpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFN1c3BlbmRlZFRpbWU6IE5vV29yayxcbiAgICAgIGxhdGVzdFBpbmdlZFRpbWU6IE5vV29yayxcblxuICAgICAgZGlkRXJyb3I6IGZhbHNlLFxuXG4gICAgICBwZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICAgIHRpbWVvdXRIYW5kbGU6IG5vVGltZW91dCxcbiAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICBwZW5kaW5nQ29udGV4dDogbnVsbCxcbiAgICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjogTm9Xb3JrLFxuICAgICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICAgIGZpcnN0QmF0Y2g6IG51bGwsXG4gICAgICBuZXh0U2NoZWR1bGVkUm9vdDogbnVsbCxcblxuICAgICAgaW50ZXJhY3Rpb25UaHJlYWRJRDogdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpLFxuICAgICAgbWVtb2l6ZWRJbnRlcmFjdGlvbnM6IG5ldyBTZXQoKSxcbiAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcDogbmV3IE1hcCgpXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0ge1xuICAgICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBkaWRFcnJvcjogZmFsc2UsXG5cbiAgICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbm9UaW1lb3V0LFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uOiBOb1dvcmssXG4gICAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmlyc3RCYXRjaDogbnVsbCxcbiAgICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIC8vIFRoZSByZWFzb24gZm9yIHRoZSB3YXkgdGhlIEZsb3cgdHlwZXMgYXJlIHN0cnVjdHVyZWQgaW4gdGhpcyBmaWxlLFxuICAvLyBJcyB0byBhdm9pZCBuZWVkaW5nIDphbnkgY2FzdHMgZXZlcnl3aGVyZSBpbnRlcmFjdGlvbiB0cmFjaW5nIGZpZWxkcyBhcmUgdXNlZC5cbiAgLy8gVW5mb3J0dW5hdGVseSB0aGF0IHJlcXVpcmVzIGFuIDphbnkgY2FzdCBmb3Igbm9uLWludGVyYWN0aW9uIHRyYWNpbmcgY2FwYWJsZSBidWlsZHMuXG4gIC8vICRGbG93Rml4TWUgUmVtb3ZlIHRoaXMgOmFueSBjYXN0IGFuZCByZXBsYWNlIGl0IHdpdGggc29tZXRoaW5nIGJldHRlci5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbihmb3JtYXQpIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICBfa2V5ID0gMTtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID1cbiAgICAgIFwiV2FybmluZzogXCIgK1xuICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyBcIiArXG4gICAgICAgICAgXCJtZXNzYWdlIGFyZ3VtZW50XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSxcbiAgICAgICAgICBfa2V5MiA9IDI7XG4gICAgICAgIF9rZXkyIDwgX2xlbjI7XG4gICAgICAgIF9rZXkyKytcbiAgICAgICkge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gIGRpc2NhcmRQZW5kaW5nV2FybmluZ3M6IGZ1bmN0aW9uKCkge30sXG4gIGZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3M6IGZ1bmN0aW9uKCkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbigpIHt9LFxuICByZWNvcmREZXByZWNhdGlvbldhcm5pbmdzOiBmdW5jdGlvbihmaWJlciwgaW5zdGFuY2UpIHt9LFxuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24oZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uKCkge31cbn07XG5cbntcbiAgdmFyIExJRkVDWUNMRV9TVUdHRVNUSU9OUyA9IHtcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFwic3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1wiLFxuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiBcImNvbXBvbmVudERpZFVwZGF0ZVwiXG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG4gIHZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uKHNldCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oXCIsIFwiKTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oXG4gICAgICBsaWZlY3ljbGVXYXJuaW5nc01hcCxcbiAgICAgIHN0cmljdFJvb3RcbiAgICApIHtcbiAgICAgIHZhciBsaWZlY3ljbGVzV2FybmluZ01lc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24obGlmZWN5Y2xlKSB7XG4gICAgICAgIHZhciBsaWZlY3ljbGVXYXJuaW5ncyA9IGxpZmVjeWNsZVdhcm5pbmdzTWFwW2xpZmVjeWNsZV07XG4gICAgICAgIGlmIChsaWZlY3ljbGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGxpZmVjeWNsZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8IFwiQ29tcG9uZW50XCIpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gbGlmZWN5Y2xlLnJlcGxhY2UoXCJVTlNBRkVfXCIsIFwiXCIpO1xuICAgICAgICAgIHZhciBzdWdnZXN0aW9uID0gTElGRUNZQ0xFX1NVR0dFU1RJT05TW2xpZmVjeWNsZV07XG4gICAgICAgICAgdmFyIHNvcnRlZENvbXBvbmVudE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50TmFtZXMpO1xuXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLnB1c2goXG4gICAgICAgICAgICBmb3JtYXR0ZWQgK1xuICAgICAgICAgICAgICBcIjogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlIFwiICtcbiAgICAgICAgICAgICAgKHN1Z2dlc3Rpb24gKyBcIiBpbnN0ZWFkOiBcIiArIHNvcnRlZENvbXBvbmVudE5hbWVzKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzdHJpY3RSb290KTtcblxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJVbnNhZmUgbGlmZWN5Y2xlIG1ldGhvZHMgd2VyZSBmb3VuZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlOiVzXCIgK1xuICAgICAgICAgICAgXCJcXG5cXG4lc1wiICtcbiAgICAgICAgICAgIFwiXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcIiArXG4gICAgICAgICAgICBcIlxcbmh0dHBzOi8vZmIubWUvcmVhY3Qtc3RyaWN0LW1vZGUtd2FybmluZ3NcIixcbiAgICAgICAgICBzdHJpY3RSb290Q29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgbGlmZWN5Y2xlc1dhcm5pbmdNZXNhZ2VzLmpvaW4oXCJcXG5cXG5cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbihmaWJlcikge1xuICAgIHZhciBtYXliZVN0cmljdFJvb3QgPSBudWxsO1xuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgbWF5YmVTdHJpY3RSb290ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8IFwiQ29tcG9uZW50XCIpO1xuICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBcIiArXG4gICAgICAgICAgXCJVc2UgY29tcG9uZW50RGlkTW91bnQgaW5zdGVhZC4gQXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCwgXCIgK1xuICAgICAgICAgIFwieW91IGNhbiByZW5hbWUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudC5cIiArXG4gICAgICAgICAgXCJcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIiArXG4gICAgICAgICAgXCJcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlwiICtcbiAgICAgICAgICBcIlxcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rc1wiLFxuICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF91bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbihmaWJlcikge1xuICAgICAgICBfdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoX3VuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uIFwiICtcbiAgICAgICAgICBcIlVzZSBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGluc3RlYWQuXCIgK1xuICAgICAgICAgIFwiXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIgK1xuICAgICAgICAgIFwiXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcIiArXG4gICAgICAgICAgXCJcXG5odHRwczovL2ZiLm1lL3JlYWN0LWFzeW5jLWNvbXBvbmVudC1saWZlY3ljbGUtaG9va3NcIixcbiAgICAgICAgX3NvcnRlZE5hbWVzXG4gICAgICApO1xuXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF91bmlxdWVOYW1lczIgPSBuZXcgU2V0KCk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24oZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzMi5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCBcIkNvbXBvbmVudFwiKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoX3VuaXF1ZU5hbWVzMik7XG5cbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJjb21wb25lbnRXaWxsVXBkYXRlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLiBcIiArXG4gICAgICAgICAgXCJVc2UgY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuIEFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQsIFwiICtcbiAgICAgICAgICBcInlvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlLlwiICtcbiAgICAgICAgICBcIlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlc1wiICtcbiAgICAgICAgICBcIlxcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XCIgK1xuICAgICAgICAgIFwiXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzXCIsXG4gICAgICAgIF9zb3J0ZWROYW1lczJcbiAgICAgICk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uKFxuICAgIGZpYmVyLFxuICAgIGluc3RhbmNlXG4gICkge1xuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZVxuICAgICkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZVxuICAgICkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbihcbiAgICBmaWJlcixcbiAgICBpbnN0YW5jZVxuICApIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcbiAgICBpZiAoc3RyaWN0Um9vdCA9PT0gbnVsbCkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiBcIiArXG4gICAgICAgICAgXCJUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICAvLyBUaGlzIGlzIGRpZmZpY3VsdCB0byB0cmFjayBhbnkgb3RoZXIgd2F5IHNpbmNlIGNvbXBvbmVudCBuYW1lc1xuICAgIC8vIGFyZSBvZnRlbiB2YWd1ZSBhbmQgYXJlIGxpa2VseSB0byBjb2xsaWRlIGJldHdlZW4gM3JkIHBhcnR5IGxpYnJhcmllcy5cbiAgICAvLyBBbiBleHBhbmQgcHJvcGVydHkgaXMgcHJvYmFibHkgb2theSB0byB1c2UgaGVyZSBzaW5jZSBpdCdzIERFVi1vbmx5LFxuICAgIC8vIGFuZCB3aWxsIG9ubHkgYmUgc2V0IGluIHRoZSBldmVudCBvZiBzZXJpb3VzIHdhcm5pbmdzLlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSB2b2lkIDA7XG4gICAgaWYgKCFwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuaGFzKHN0cmljdFJvb3QpKSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6IFtdLFxuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlOiBbXVxuICAgICAgfTtcblxuICAgICAgcGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MuZ2V0KHN0cmljdFJvb3QpO1xuICAgIH1cblxuICAgIHZhciB1bnNhZmVMaWZlY3ljbGVzID0gW107XG4gICAgaWYgKFxuICAgICAgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkgfHxcbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaChcIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT1cbiAgICAgICAgICB0cnVlKSB8fFxuICAgICAgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgIHVuc2FmZUxpZmVjeWNsZXMucHVzaChcIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgfVxuXG4gICAgaWYgKHVuc2FmZUxpZmVjeWNsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpZmVjeWNsZSkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3RbbGlmZWN5Y2xlXS5wdXNoKGZpYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uKFxuICAgIGZpYmVyLFxuICAgIGluc3RhbmNlXG4gICkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuIFwiICtcbiAgICAgICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKFxuICAgICAgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fFxuICAgICAgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8XG4gICAgICAoaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKVxuICAgICkge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbigpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbihmaWJlckFycmF5LCBzdHJpY3RSb290KSB7XG4gICAgICB2YXIgdW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICBmaWJlckFycmF5LmZvckVhY2goZnVuY3Rpb24oZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgXCJDb21wb25lbnRcIik7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcbiAgICAgIHZhciBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc3RyaWN0Um9vdCk7XG5cbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWU6ICVzXCIgK1xuICAgICAgICAgIFwiXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIgK1xuICAgICAgICAgIFwiXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcIiArXG4gICAgICAgICAgXCJcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXdhcm5pbmdzXCIsXG4gICAgICAgIHN0cmljdFJvb3RDb21wb25lbnRTdGFjayxcbiAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIFRoaXMgbGV0cyB1cyBob29rIGludG8gRmliZXIgdG8gZGVidWcgd2hhdCBpdCdzIGRvaW5nLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzgwMzMuXG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLCBub3QgZXZlbiBmb3IgUmVhY3QgRGV2VG9vbHMuXG4vLyBZb3UgbWF5IG9ubHkgaW5qZWN0IGEgZGVidWdUb29sIGlmIHlvdSB3b3JrIG9uIFJlYWN0IEZpYmVyIGl0c2VsZi5cbnZhciBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uID0ge1xuICBkZWJ1Z1Rvb2w6IG51bGxcbn07XG5cbnZhciBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEgPSBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uO1xuXG4vLyBUT0RPOiBPZmZzY3JlZW4gdXBkYXRlcyBzaG91bGQgbmV2ZXIgc3VzcGVuZC4gSG93ZXZlciwgYSBwcm9taXNlIHRoYXRcbi8vIHN1c3BlbmRlZCBpbnNpZGUgYW4gb2Zmc2NyZWVuIHN1YnRyZWUgc2hvdWxkIGJlIGFibGUgdG8gcGluZyBhdCB0aGUgcHJpb3JpdHlcbi8vIG9mIHRoZSBvdXRlciByZW5kZXIuXG5cbmZ1bmN0aW9uIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBJZiB0aGVyZSdzIGEgZ2FwIGJldHdlZW4gY29tcGxldGluZyBhIGZhaWxlZCByb290IGFuZCByZXRyeWluZyBpdCxcbiAgLy8gYWRkaXRpb25hbCB1cGRhdGVzIG1heSBiZSBzY2hlZHVsZWQuIENsZWFyIGBkaWRFcnJvcmAsIGluIGNhc2UgdGhlIHVwZGF0ZVxuICAvLyBpcyBzdWZmaWNpZW50IHRvIGZpeCB0aGUgZXJyb3IuXG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcblxuICAvLyBVcGRhdGUgdGhlIGxhdGVzdCBhbmQgZWFybGllc3QgcGVuZGluZyB0aW1lc1xuICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPT09IE5vV29yaykge1xuICAgIC8vIE5vIG90aGVyIHBlbmRpbmcgdXBkYXRlcy5cbiAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZWFybGllc3QgcGVuZGluZyB1cGRhdGUuXG4gICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhdGVzdCBwZW5kaW5nIHVwZGF0ZVxuICAgICAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihleHBpcmF0aW9uVGltZSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXR0ZWRQcmlvcml0eUxldmVscyhyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgIC8vIEZhc3QgcGF0aC4gVGhlcmUncyBubyByZW1haW5pbmcgd29yay4gQ2xlYXIgZXZlcnl0aGluZy5cbiAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICAgIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIExldCdzIHNlZSBpZiB0aGUgcHJldmlvdXMgbGF0ZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwgd2FzIGp1c3QgZmx1c2hlZC5cbiAgdmFyIGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmspIHtcbiAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgIC8vIFdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBrbm93biBwZW5kaW5nIGxldmVscy5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICAgICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgICAgLy8gV2UndmUgZmx1c2hlZCB0aGUgZWFybGllc3Qga25vd24gcGVuZGluZyBsZXZlbC4gU2V0IHRoaXMgdG8gdGhlXG4gICAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIHRpbWUuXG4gICAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IGxldCdzIGhhbmRsZSB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGluIHRoZSB3aG9sZSB0cmVlLiBXZSBuZWVkIHRvXG4gIC8vIGRlY2lkZSB3aGV0aGVyIHRvIHRyZWF0IGl0IGFzIGEgcGVuZGluZyBsZXZlbCBvciBhcyBzdXNwZW5kZWQuIENoZWNrXG4gIC8vIGl0IGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkIGxldmVscy5cblxuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuIFRyZWF0IHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgYXMgYVxuICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPiBsYXRlc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpcyBsYXRlciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuIFRoYXRcbiAgICAvLyBtZWFucyB3ZSd2ZSBmbHVzaGVkIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuXG4gICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcblxuICAgIC8vIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuIFRyZWF0IHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgYXMgYVxuICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA8IGVhcmxpZXN0U3VzcGVuZGVkVGltZSkge1xuICAgIC8vIFRoZSBlYXJsaWVzdCByZW1haW5pbmcgdGltZSBpcyBlYXJsaWVyIHRoYW4gYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICAvLyBUcmVhdCBpdCBhcyBhIHBlbmRpbmcgdXBkYXRlLlxuICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpO1xuICAgIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSBlYXJsaWVzdCByZW1haW5pbmcgdGltZSBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZFxuICAvLyBsZXZlbHMuIFdlIHNob3VsZCB0cmVhdCB0aGlzIGFzIHN1c3BlbmRlZCB3b3JrLlxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbn1cblxuZnVuY3Rpb24gaGFzTG93ZXJQcmlvcml0eVdvcmsocm9vdCwgZXJyb3JlZEV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgcmV0dXJuIChcbiAgICAobGF0ZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yayAmJlxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWUgPiBlcnJvcmVkRXhwaXJhdGlvblRpbWUpIHx8XG4gICAgKGxhdGVzdFN1c3BlbmRlZFRpbWUgIT09IE5vV29yayAmJlxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZSA+IGVycm9yZWRFeHBpcmF0aW9uVGltZSkgfHxcbiAgICAobGF0ZXN0UGluZ2VkVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFBpbmdlZFRpbWUgPiBlcnJvcmVkRXhwaXJhdGlvblRpbWUpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzUHJpb3JpdHlMZXZlbFN1c3BlbmRlZChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICByZXR1cm4gKFxuICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgZXhwaXJhdGlvblRpbWUgPj0gZWFybGllc3RTdXNwZW5kZWRUaW1lICYmXG4gICAgZXhwaXJhdGlvblRpbWUgPD0gbGF0ZXN0U3VzcGVuZGVkVGltZVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBzdXNwZW5kZWRUaW1lKSB7XG4gIHJvb3QuZGlkRXJyb3IgPSBmYWxzZTtcbiAgY2xlYXJQaW5nKHJvb3QsIHN1c3BlbmRlZFRpbWUpO1xuXG4gIC8vIEZpcnN0LCBjaGVjayB0aGUga25vd24gcGVuZGluZyBsZXZlbHMgYW5kIHVwZGF0ZSB0aGVtIGlmIG5lZWRlZC5cbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBCb3RoIGtub3duIHBlbmRpbmcgbGV2ZWxzIHdlcmUgc3VzcGVuZGVkLiBDbGVhciB0aGVtLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGVhcmxpZXN0IHBlbmRpbmcgbGV2ZWwgd2FzIHN1c3BlbmRlZC4gQ2xlYXIgYnkgc2V0dGluZyBpdCB0byB0aGVcbiAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIGxldmVsLlxuICAgICAgcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lID0gbGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGxhdGVzdCBwZW5kaW5nIGxldmVsIHdhcyBzdXNwZW5kZWQuIENsZWFyIGJ5IHNldHRpbmcgaXQgdG8gdGhlXG4gICAgLy8gbGF0ZXN0IHBlbmRpbmcgbGV2ZWwuXG4gICAgcm9vdC5sYXRlc3RQZW5kaW5nVGltZSA9IGVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIH1cblxuICAvLyBGaW5hbGx5LCB1cGRhdGUgdGhlIGtub3duIHN1c3BlbmRlZCBsZXZlbHMuXG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgIC8vIE5vIG90aGVyIHN1c3BlbmRlZCBsZXZlbHMuXG4gICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICB9IGVsc2Uge1xuICAgIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPiBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCBzdXNwZW5kZWQgbGV2ZWwuXG4gICAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gICAgfSBlbHNlIGlmIChsYXRlc3RTdXNwZW5kZWRUaW1lIDwgc3VzcGVuZGVkVGltZSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHN1c3BlbmRlZCBsZXZlbFxuICAgICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9XG4gIH1cblxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oc3VzcGVuZGVkVGltZSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIG1hcmtQaW5nZWRQcmlvcml0eUxldmVsKHJvb3QsIHBpbmdlZFRpbWUpIHtcbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IFdoZW4gd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBwcm9ncmVzc2VkIHdvcmtcbiAgLy8gaXMgdGhyb3duIG91dCBhbmQgbm90IHJldXNlZCBkdXJpbmcgdGhlIHJlc3RhcnRlZCByZW5kZXIuIE9uZSB3YXkgdG9cbiAgLy8gaW52YWxpZGF0ZSB0aGUgcHJvZ3Jlc3NlZCB3b3JrIGlzIHRvIHJlc3RhcnQgYXQgZXhwaXJhdGlvblRpbWUgKyAxLlxuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgaWYgKGxhdGVzdFBpbmdlZFRpbWUgPT09IE5vV29yayB8fCBsYXRlc3RQaW5nZWRUaW1lIDwgcGluZ2VkVGltZSkge1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IHBpbmdlZFRpbWU7XG4gIH1cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKHBpbmdlZFRpbWUsIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjbGVhclBpbmcocm9vdCwgY29tcGxldGVkVGltZSkge1xuICAvLyBUT0RPOiBUcmFjayB3aGV0aGVyIHRoZSByb290IHdhcyBwaW5nZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHNvLFxuICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBsb3NlIHRyYWNrIG9mIGl0LlxuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgaWYgKGxhdGVzdFBpbmdlZFRpbWUgIT09IE5vV29yayAmJiBsYXRlc3RQaW5nZWRUaW1lIDw9IGNvbXBsZXRlZFRpbWUpIHtcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEVhcmxpZXN0T3V0c3RhbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG5cbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKFxuICAgIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgIChlYXJsaWVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgIGVhcmxpZXN0UGVuZGluZ1RpbWUgPCBlYXJsaWVzdEV4cGlyYXRpb25UaW1lKVxuICApIHtcbiAgICBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgfVxuICBpZiAoXG4gICAgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgICBlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPCBlYXJsaWVzdEV4cGlyYXRpb25UaW1lKVxuICApIHtcbiAgICBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB9XG4gIHJldHVybiBlYXJsaWVzdEV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGN1cnJlbnRUaW1lID49IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlIHJvb3QgaGFzIGV4cGlyZWQuIEZsdXNoIGFsbCB3b3JrIHVwIHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGN1cnJlbnRUaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSwgcm9vdCkge1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgdmFyIGxhdGVzdFBpbmdlZFRpbWUgPSByb290LmxhdGVzdFBpbmdlZFRpbWU7XG5cbiAgLy8gV29yayBvbiB0aGUgZWFybGllc3QgcGVuZGluZyB0aW1lLiBGYWlsaW5nIHRoYXQsIHdvcmsgb24gdGhlIGxhdGVzdFxuICAvLyBwaW5nZWQgdGltZS5cbiAgdmFyIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID1cbiAgICBlYXJsaWVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmsgPyBlYXJsaWVzdFBlbmRpbmdUaW1lIDogbGF0ZXN0UGluZ2VkVGltZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyBwZW5kaW5nIG9yIHBpbmdlZCB3b3JrLCBjaGVjayBpZiB0aGVyZSdzIHN1c3BlbmRlZCB3b3JrXG4gIC8vIHRoYXQncyBsb3dlciBwcmlvcml0eSB0aGFuIHdoYXQgd2UganVzdCBjb21wbGV0ZWQuXG4gIGlmIChcbiAgICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9PT0gTm9Xb3JrICYmXG4gICAgKGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICAgIGxhdGVzdFN1c3BlbmRlZFRpbWUgPiBjb21wbGV0ZWRFeHBpcmF0aW9uVGltZSlcbiAgKSB7XG4gICAgLy8gVGhlIGxvd2VzdCBwcmlvcml0eSBzdXNwZW5kZWQgd29yayBpcyB0aGUgd29yayBtb3N0IGxpa2VseSB0byBiZVxuICAgIC8vIGNvbW1pdHRlZCBuZXh0LiBMZXQncyBzdGFydCByZW5kZXJpbmcgaXQgYWdhaW4sIHNvIHRoYXQgaWYgaXQgdGltZXMgb3V0LFxuICAgIC8vIGl0J3MgcmVhZHkgdG8gY29tbWl0LlxuICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gbGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uO1xuICBpZiAoXG4gICAgZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJlxuICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgZWFybGllc3RTdXNwZW5kZWRUaW1lIDwgZXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gRXhwaXJlIHVzaW5nIHRoZSBlYXJsaWVzdCBrbm93biBleHBpcmF0aW9uIHRpbWUuXG4gICAgZXhwaXJhdGlvblRpbWUgPSBlYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIH1cblxuICByb290Lm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT247XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbn1cblxuLy8gVXBkYXRlUXVldWUgaXMgYSBsaW5rZWQgbGlzdCBvZiBwcmlvcml0aXplZCB1cGRhdGVzLlxuLy9cbi8vIExpa2UgZmliZXJzLCB1cGRhdGUgcXVldWVzIGNvbWUgaW4gcGFpcnM6IGEgY3VycmVudCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuLy8gdGhlIHZpc2libGUgc3RhdGUgb2YgdGhlIHNjcmVlbiwgYW5kIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgd2hpY2ggaXNcbi8vIGNhbiBiZSBtdXRhdGVkIGFuZCBwcm9jZXNzZWQgYXN5bmNocm9ub3VzbHkgYmVmb3JlIGl0IGlzIGNvbW1pdHRlZCDigJQgYSBmb3JtXG4vLyBvZiBkb3VibGUgYnVmZmVyaW5nLiBJZiBhIHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyIGlzIGRpc2NhcmRlZCBiZWZvcmVcbi8vIGZpbmlzaGluZywgd2UgY3JlYXRlIGEgbmV3IHdvcmstaW4tcHJvZ3Jlc3MgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBCb3RoIHF1ZXVlcyBzaGFyZSBhIHBlcnNpc3RlbnQsIHNpbmdseS1saW5rZWQgbGlzdCBzdHJ1Y3R1cmUuIFRvIHNjaGVkdWxlIGFuXG4vLyB1cGRhdGUsIHdlIGFwcGVuZCBpdCB0byB0aGUgZW5kIG9mIGJvdGggcXVldWVzLiBFYWNoIHF1ZXVlIG1haW50YWlucyBhXG4vLyBwb2ludGVyIHRvIGZpcnN0IHVwZGF0ZSBpbiB0aGUgcGVyc2lzdGVudCBsaXN0IHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkLlxuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlciBhbHdheXMgaGFzIGEgcG9zaXRpb24gZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXG4vLyB0aGUgY3VycmVudCBxdWV1ZSwgc2luY2Ugd2UgYWx3YXlzIHdvcmsgb24gdGhhdCBvbmUuIFRoZSBjdXJyZW50IHF1ZXVlJ3Ncbi8vIHBvaW50ZXIgaXMgb25seSB1cGRhdGVkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3aGVuIHdlIHN3YXAgaW4gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgQ3VycmVudCBwb2ludGVyOiAgICAgICAgICAgQSAtIEIgLSBDIC0gRCAtIEUgLSBGXG4vLyAgIFdvcmstaW4tcHJvZ3Jlc3MgcG9pbnRlcjogICAgICAgICAgICAgIEQgLSBFIC0gRlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGhhc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgbW9yZSB1cGRhdGVzIHRoYW4gY3VycmVudC5cbi8vXG4vLyBUaGUgcmVhc29uIHdlIGFwcGVuZCB0byBib3RoIHF1ZXVlcyBpcyBiZWNhdXNlIG90aGVyd2lzZSB3ZSBtaWdodCBkcm9wXG4vLyB1cGRhdGVzIHdpdGhvdXQgZXZlciBwcm9jZXNzaW5nIHRoZW0uIEZvciBleGFtcGxlLCBpZiB3ZSBvbmx5IGFkZCB1cGRhdGVzIHRvXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgc29tZSB1cGRhdGVzIGNvdWxkIGJlIGxvc3Qgd2hlbmV2ZXIgYSB3b3JrLWluXG4vLyAtcHJvZ3Jlc3MgcmVuZGVyIHJlc3RhcnRzIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LiBTaW1pbGFybHksIGlmIHdlIG9ubHkgYWRkXG4vLyB1cGRhdGVzIHRvIHRoZSBjdXJyZW50IHF1ZXVlLCB0aGUgdXBkYXRlcyB3aWxsIGJlIGxvc3Qgd2hlbmV2ZXIgYW4gYWxyZWFkeVxuLy8gaW4tcHJvZ3Jlc3MgcXVldWUgY29tbWl0cyBhbmQgc3dhcHMgd2l0aCB0aGUgY3VycmVudCBxdWV1ZS4gSG93ZXZlciwgYnlcbi8vIGFkZGluZyB0byBib3RoIHF1ZXVlcywgd2UgZ3VhcmFudGVlIHRoYXQgdGhlIHVwZGF0ZSB3aWxsIGJlIHBhcnQgb2YgdGhlIG5leHRcbi8vIHdvcmstaW4tcHJvZ3Jlc3MuIChBbmQgYmVjYXVzZSB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBiZWNvbWVzIHRoZVxuLy8gY3VycmVudCBxdWV1ZSBvbmNlIGl0IGNvbW1pdHMsIHRoZXJlJ3Mgbm8gZGFuZ2VyIG9mIGFwcGx5aW5nIHRoZSBzYW1lXG4vLyB1cGRhdGUgdHdpY2UuKVxuLy9cbi8vIFByaW9yaXRpemF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLVxuLy9cbi8vIFVwZGF0ZXMgYXJlIG5vdCBzb3J0ZWQgYnkgcHJpb3JpdHksIGJ1dCBieSBpbnNlcnRpb247IG5ldyB1cGRhdGVzIGFyZSBhbHdheXNcbi8vIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4vL1xuLy8gVGhlIHByaW9yaXR5IGlzIHN0aWxsIGltcG9ydGFudCwgdGhvdWdoLiBXaGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZVxuLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIG9ubHkgdGhlIHVwZGF0ZXMgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5IGFyZVxuLy8gaW5jbHVkZWQgaW4gdGhlIHJlc3VsdC4gSWYgd2Ugc2tpcCBhbiB1cGRhdGUgYmVjYXVzZSBpdCBoYXMgaW5zdWZmaWNpZW50XG4vLyBwcmlvcml0eSwgaXQgcmVtYWlucyBpbiB0aGUgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGxhdGVyLCBkdXJpbmcgYSBsb3dlclxuLy8gcHJpb3JpdHkgcmVuZGVyLiBDcnVjaWFsbHksIGFsbCB1cGRhdGVzIHN1YnNlcXVlbnQgdG8gYSBza2lwcGVkIHVwZGF0ZSBhbHNvXG4vLyByZW1haW4gaW4gdGhlIHF1ZXVlICpyZWdhcmRsZXNzIG9mIHRoZWlyIHByaW9yaXR5Ki4gVGhhdCBtZWFucyBoaWdoIHByaW9yaXR5XG4vLyB1cGRhdGVzIGFyZSBzb21ldGltZXMgcHJvY2Vzc2VkIHR3aWNlLCBhdCB0d28gc2VwYXJhdGUgcHJpb3JpdGllcy4gV2UgYWxzb1xuLy8ga2VlcCB0cmFjayBvZiBhIGJhc2Ugc3RhdGUsIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhdGUgYmVmb3JlIHRoZSBmaXJzdFxuLy8gdXBkYXRlIGluIHRoZSBxdWV1ZSBpcyBhcHBsaWVkLlxuLy9cbi8vIEZvciBleGFtcGxlOlxuLy9cbi8vICAgR2l2ZW4gYSBiYXNlIHN0YXRlIG9mICcnLCBhbmQgdGhlIGZvbGxvd2luZyBxdWV1ZSBvZiB1cGRhdGVzXG4vL1xuLy8gICAgIEExIC0gQjIgLSBDMSAtIEQyXG4vL1xuLy8gICB3aGVyZSB0aGUgbnVtYmVyIGluZGljYXRlcyB0aGUgcHJpb3JpdHksIGFuZCB0aGUgdXBkYXRlIGlzIGFwcGxpZWQgdG8gdGhlXG4vLyAgIHByZXZpb3VzIHN0YXRlIGJ5IGFwcGVuZGluZyBhIGxldHRlciwgUmVhY3Qgd2lsbCBwcm9jZXNzIHRoZXNlIHVwZGF0ZXMgYXNcbi8vICAgdHdvIHNlcGFyYXRlIHJlbmRlcnMsIG9uZSBwZXIgZGlzdGluY3QgcHJpb3JpdHkgbGV2ZWw6XG4vL1xuLy8gICBGaXJzdCByZW5kZXIsIGF0IHByaW9yaXR5IDE6XG4vLyAgICAgQmFzZSBzdGF0ZTogJydcbi8vICAgICBVcGRhdGVzOiBbQTEsIEMxXVxuLy8gICAgIFJlc3VsdCBzdGF0ZTogJ0FDJ1xuLy9cbi8vICAgU2Vjb25kIHJlbmRlciwgYXQgcHJpb3JpdHkgMjpcbi8vICAgICBCYXNlIHN0YXRlOiAnQScgICAgICAgICAgICA8LSAgVGhlIGJhc2Ugc3RhdGUgZG9lcyBub3QgaW5jbHVkZSBDMSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVjYXVzZSBCMiB3YXMgc2tpcHBlZC5cbi8vICAgICBVcGRhdGVzOiBbQjIsIEMxLCBEMl0gICAgICA8LSAgQzEgd2FzIHJlYmFzZWQgb24gdG9wIG9mIEIyXG4vLyAgICAgUmVzdWx0IHN0YXRlOiAnQUJDRCdcbi8vXG4vLyBCZWNhdXNlIHdlIHByb2Nlc3MgdXBkYXRlcyBpbiBpbnNlcnRpb24gb3JkZXIsIGFuZCByZWJhc2UgaGlnaCBwcmlvcml0eVxuLy8gdXBkYXRlcyB3aGVuIHByZWNlZGluZyB1cGRhdGVzIGFyZSBza2lwcGVkLCB0aGUgZmluYWwgcmVzdWx0IGlzIGRldGVybWluaXN0aWNcbi8vIHJlZ2FyZGxlc3Mgb2YgcHJpb3JpdHkuIEludGVybWVkaWF0ZSBzdGF0ZSBtYXkgdmFyeSBhY2NvcmRpbmcgdG8gc3lzdGVtXG4vLyByZXNvdXJjZXMsIGJ1dCB0aGUgZmluYWwgc3RhdGUgaXMgYWx3YXlzIHRoZSBzYW1lLlxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzO1xuXG4vLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxudmFyIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdm9pZCAwO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbnZhciByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHZvaWQgMDtcbntcbiAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xuICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZmlyc3RVcGRhdGU6IG51bGwsXG4gICAgbGFzdFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGxhc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50UXVldWUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICBmaXJzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmZpcnN0VXBkYXRlLFxuICAgIGxhc3RVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0VXBkYXRlLFxuXG4gICAgLy8gVE9ETzogV2l0aCByZXN1bWluZywgaWYgd2UgYmFpbCBvdXQgYW5kIHJlc3VzZSB0aGUgY2hpbGQgdHJlZSwgd2Ugc2hvdWxkXG4gICAgLy8ga2VlcCB0aGVzZSBlZmZlY3RzLlxuICAgIGZpcnN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuXG4gICAgZmlyc3RFZmZlY3Q6IG51bGwsXG4gICAgbGFzdEVmZmVjdDogbnVsbCxcblxuICAgIGZpcnN0Q2FwdHVyZWRFZmZlY3Q6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkRWZmZWN0OiBudWxsXG4gIH07XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiB7XG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuXG4gICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICBwYXlsb2FkOiBudWxsLFxuICAgIGNhbGxiYWNrOiBudWxsLFxuXG4gICAgbmV4dDogbnVsbCxcbiAgICBuZXh0RWZmZWN0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUsIHVwZGF0ZSkge1xuICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICBpZiAocXVldWUubGFzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFF1ZXVlIGlzIGVtcHR5XG4gICAgcXVldWUuZmlyc3RVcGRhdGUgPSBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBVcGRhdGUgcXVldWVzIGFyZSBjcmVhdGVkIGxhemlseS5cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgdmFyIHF1ZXVlMSA9IHZvaWQgMDtcbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBvbmUgZmliZXIuXG4gICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIG93bmVycy5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBOZWl0aGVyIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENyZWF0ZSBuZXcgb25lcy5cbiAgICAgICAgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShmaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgcXVldWUyID0gYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoXG4gICAgICAgICAgYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9ubHkgb25lIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENsb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY2xvbmVVcGRhdGVRdWV1ZShxdWV1ZTIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICAgIC8vIE9ubHkgb25lIGZpYmVyIGhhcyBhbiB1cGRhdGUgcXVldWUuIENsb25lIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgIHF1ZXVlMiA9IGFsdGVybmF0ZS51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJvdGggb3duZXJzIGhhdmUgYW4gdXBkYXRlIHF1ZXVlLlxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocXVldWUyID09PSBudWxsIHx8IHF1ZXVlMSA9PT0gcXVldWUyKSB7XG4gICAgLy8gVGhlcmUncyBvbmx5IGEgc2luZ2xlIHF1ZXVlLlxuICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gcXVldWVzLiBXZSBuZWVkIHRvIGFwcGVuZCB0aGUgdXBkYXRlIHRvIGJvdGggcXVldWVzLFxuICAgIC8vIHdoaWxlIGFjY291bnRpbmcgZm9yIHRoZSBwZXJzaXN0ZW50IHN0cnVjdHVyZSBvZiB0aGUgbGlzdCDigJQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRoZSBzYW1lIHVwZGF0ZSB0byBiZSBhZGRlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAocXVldWUxLmxhc3RVcGRhdGUgPT09IG51bGwgfHwgcXVldWUyLmxhc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIE9uZSBvZiB0aGUgcXVldWVzIGlzIG5vdCBlbXB0eS4gV2UgbXVzdCBhZGQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggcXVldWVzIGFyZSBub24tZW1wdHkuIFRoZSBsYXN0IHVwZGF0ZSBpcyB0aGUgc2FtZSBpbiBib3RoIGxpc3RzLFxuICAgICAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCBvbmx5IGFwcGVuZCB0byBvbmUgb2YgdGhlIGxpc3RzLlxuICAgICAgYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgICAvLyBCdXQgd2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgdGhlIGBsYXN0VXBkYXRlYCBwb2ludGVyIG9mIHF1ZXVlMi5cbiAgICAgIHF1ZXVlMi5sYXN0VXBkYXRlID0gdXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoXG4gICAgICAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50TGF6eSkgJiZcbiAgICAgIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHF1ZXVlMSB8fFxuICAgICAgICAocXVldWUyICE9PSBudWxsICYmIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUyKSkgJiZcbiAgICAgICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlXG4gICAgKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkFuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgXCIgK1xuICAgICAgICAgIFwiZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCBcIiArXG4gICAgICAgICAgXCJ3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSBcIiArXG4gICAgICAgICAgXCJjYWxsYmFjay5cIlxuICAgICAgKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGdvIGludG8gYSBzZXBhcmF0ZSBsaXN0LCBhbmQgb25seSBvbiB0aGUgd29yay1pbi1cbiAgLy8gcHJvZ3Jlc3MgcXVldWUuXG4gIHZhciB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBJIHB1dCB0aGlzIGhlcmUgcmF0aGVyIHRoYW4gY3JlYXRlV29ya0luUHJvZ3Jlc3Mgc28gdGhhdCB3ZSBkb24ndFxuICAgIC8vIGNsb25lIHRoZSBxdWV1ZSB1bm5lY2Vzc2FyaWx5LiBUaGVyZSdzIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0b1xuICAgIC8vIHN0cnVjdHVyZSB0aGlzLlxuICAgIHdvcmtJblByb2dyZXNzUXVldWUgPSBlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHdvcmtJblByb2dyZXNzUXVldWVcbiAgICApO1xuICB9XG5cbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuICAgIHdvcmtJblByb2dyZXNzUXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSB1cGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSkge1xuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBxdWV1ZSxcbiAgICAvLyB3ZSBuZWVkIHRvIGNsb25lIGl0IGZpcnN0LlxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudC51cGRhdGVRdWV1ZSkge1xuICAgICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZShcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHF1ZXVlLFxuICB1cGRhdGUsXG4gIHByZXZTdGF0ZSxcbiAgbmV4dFByb3BzLFxuICBpbnN0YW5jZVxuKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOiB7XG4gICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHxcbiAgICAgICAgICAgIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgfVxuICAgICAgLy8gU3RhdGUgb2JqZWN0XG4gICAgICByZXR1cm4gX3BheWxvYWQ7XG4gICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZToge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID1cbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlKSB8IERpZENhcHR1cmU7XG4gICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZToge1xuICAgICAgdmFyIF9wYXlsb2FkMiA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAgICAgICAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIF9wYXlsb2FkMi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkMi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDI7XG4gICAgICB9XG4gICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE51bGwgYW5kIHVuZGVmaW5lZCBhcmUgdHJlYXRlZCBhcyBuby1vcHMuXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICB9XG4gICAgY2FzZSBGb3JjZVVwZGF0ZToge1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcXVldWUsXG4gIHByb3BzLFxuICBpbnN0YW5jZSxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHF1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCBxdWV1ZSk7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlO1xuICB9XG5cbiAgLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG4gIHZhciBuZXdCYXNlU3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIHZhciBuZXdGaXJzdFVwZGF0ZSA9IG51bGw7XG4gIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdFVwZGF0ZTtcbiAgdmFyIHJlc3VsdFN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgc2tpcHBlZCB1cGRhdGUuIEl0IHdpbGwgYmUgdGhlIGZpcnN0IHVwZGF0ZSBpblxuICAgICAgICAvLyB0aGUgbmV3IGxpc3QuXG4gICAgICAgIG5ld0ZpcnN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0XG4gICAgICAgIC8vIGlzIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB0aGlzIHVwZGF0ZSB3aWxsIHJlbWFpbiBpbiB0aGUgbGlzdCwgdXBkYXRlIHRoZSByZW1haW5pbmdcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgICBuZXdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lXG4gICAgICApIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcXVldWUsXG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgcmVzdWx0U3RhdGUsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBpbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdEVmZmVjdCA9IHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgLy8gU2VwYXJhdGVseSwgaXRlcmF0ZSB0aG91Z2ggdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgdmFyIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB1cGRhdGUgPSBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIF91cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoX3VwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgY2FwdHVyZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0IGlzXG4gICAgICAgIC8vIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKFxuICAgICAgICBuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID4gX3VwZGF0ZUV4cGlyYXRpb25UaW1lXG4gICAgICApIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBfdXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBQcm9jZXNzIGl0IGFuZCBjb21wdXRlXG4gICAgICAvLyBhIG5ldyByZXN1bHQuXG4gICAgICByZXN1bHRTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICB1cGRhdGUsXG4gICAgICAgIHJlc3VsdFN0YXRlLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgICB2YXIgX2NhbGxiYWNrMiA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAgIGlmIChfY2FsbGJhY2syICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0Lm5leHRFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgfVxuICBpZiAobmV3Rmlyc3RVcGRhdGUgPT09IG51bGwgJiYgbmV3Rmlyc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHByb2Nlc3NlZCBldmVyeSB1cGRhdGUsIHdpdGhvdXQgc2tpcHBpbmcuIFRoYXQgbWVhbnMgdGhlIG5ldyBiYXNlXG4gICAgLy8gc3RhdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHJlc3VsdCBzdGF0ZS5cbiAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgcXVldWUuZmlyc3RVcGRhdGUgPSBuZXdGaXJzdFVwZGF0ZTtcbiAgcXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSA9IG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGU7XG5cbiAgLy8gU2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHdoYXRldmVyIGlzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUuXG4gIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAvLyBleHBpcmF0aW9uIHRpbWUgYXJlIHByb3BzIGFuZCBjb250ZXh0LiBXZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgdGhlXG4gIC8vIGJlZ2luIHBoYXNlIGJ5IHRoZSB0aW1lIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLCBzbyB3ZSd2ZSBhbHJlYWR5XG4gIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gIC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB0cmlja3k7IGJ1dCB3ZSdsbCBoYXZlIHRvIGFjY291bnQgZm9yXG4gIC8vIHRoYXQgcmVnYXJkbGVzcy5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHJlc3VsdFN0YXRlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpbnZhcmlhbnQoXG4gICAgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIsXG4gICAgXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCBcIiArXG4gICAgICBcInJlY2VpdmVkOiAlc1wiLFxuICAgIGNhbGxiYWNrXG4gICk7XG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKFxuICBmaW5pc2hlZFdvcmssXG4gIGZpbmlzaGVkUXVldWUsXG4gIGluc3RhbmNlLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZVxuKSB7XG4gIC8vIElmIHRoZSBmaW5pc2hlZCByZW5kZXIgaW5jbHVkZWQgY2FwdHVyZWQgdXBkYXRlcywgYW5kIHRoZXJlIGFyZSBzdGlsbFxuICAvLyBsb3dlciBwcmlvcml0eSB1cGRhdGVzIGxlZnQgb3Zlciwgd2UgbmVlZCB0byBrZWVwIHRoZSBjYXB0dXJlZCB1cGRhdGVzXG4gIC8vIGluIHRoZSBxdWV1ZSBzbyB0aGF0IHRoZXkgYXJlIHJlYmFzZWQgYW5kIG5vdCBkcm9wcGVkIG9uY2Ugd2UgcHJvY2VzcyB0aGVcbiAgLy8gcXVldWUgYWdhaW4gYXQgdGhlIGxvd2VyIHByaW9yaXR5LlxuICBpZiAoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSm9pbiB0aGUgY2FwdHVyZWQgdXBkYXRlIGxpc3QgdG8gdGhlIGVuZCBvZiB0aGUgbm9ybWFsIGxpc3QuXG4gICAgaWYgKGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlLm5leHQgPSBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgICBmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgY29tbWl0VXBkYXRlRWZmZWN0cyhmaW5pc2hlZFF1ZXVlLmZpcnN0RWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0LCBpbnN0YW5jZSk7XG4gIGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCA9IGZpbmlzaGVkUXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0VXBkYXRlRWZmZWN0cyhlZmZlY3QsIGluc3RhbmNlKSB7XG4gIHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2NhbGxiYWNrMyA9IGVmZmVjdC5jYWxsYmFjaztcbiAgICBpZiAoX2NhbGxiYWNrMyAhPT0gbnVsbCkge1xuICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGNhbGxDYWxsYmFjayhfY2FsbGJhY2szLCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZSkge1xuICAvLyBJZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IsIGNhbGwgdGhpcyBmdW5jdGlvbiBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyB0aHJvd25cbiAgLy8gc28gdGhlIHN0YWNrIGlzIGFjY3VyYXRlLlxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrJDE7XG5cbntcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG5cbiAgICBmb3IgKFxuICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLFxuICAgICAgICBfa2V5ID0gMjtcbiAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgX2tleSsrXG4gICAgKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEuYXBwbHkoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBbZmFsc2UsIGZvcm1hdCArIFwiJXNcIl0uY29uY2F0KGFyZ3MsIFtzdGFja10pXG4gICAgKTtcbiAgfTtcbn1cblxudmFyIHdhcm5pbmckMSA9IHdhcm5pbmc7XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcblxudmFyIHJlbmRlcmVyU2lnaWwgPSB2b2lkIDA7XG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNlcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBuZXh0VmFsdWUpIHtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcbiAgICB7XG4gICAgICAhKFxuICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHxcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSByZW5kZXJlclNpZ2lsXG4gICAgICApXG4gICAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBcIiArXG4gICAgICAgICAgICAgIFwic2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIlxuICAgICAgICAgIClcbiAgICAgICAgOiB2b2lkIDA7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG4gICAge1xuICAgICAgIShcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPT09IG51bGwgfHxcbiAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9PT0gcmVuZGVyZXJTaWdpbFxuICAgICAgKVxuICAgICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgXCIgK1xuICAgICAgICAgICAgICBcInNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogdm9pZCAwO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBjdXJyZW50VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIC8vIFVzZSBPYmplY3QuaXMgdG8gY29tcGFyZSB0aGUgbmV3IGNvbnRleHQgdmFsdWUgdG8gdGhlIG9sZCB2YWx1ZS4gSW5saW5lZFxuICAvLyBPYmplY3QuaXMgcG9seWZpbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICBpZiAoXG4gICAgKG9sZFZhbHVlID09PSBuZXdWYWx1ZSAmJlxuICAgICAgKG9sZFZhbHVlICE9PSAwIHx8IDEgLyBvbGRWYWx1ZSA9PT0gMSAvIG5ld1ZhbHVlKSkgfHxcbiAgICAob2xkVmFsdWUgIT09IG9sZFZhbHVlICYmIG5ld1ZhbHVlICE9PSBuZXdWYWx1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgKSB7XG4gICAgLy8gTm8gY2hhbmdlXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID1cbiAgICAgIHR5cGVvZiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKVxuICAgICAgICA6IG1heFNpZ25lZDMxQml0SW50O1xuXG4gICAge1xuICAgICAgISgoY2hhbmdlZEJpdHMgJiBtYXhTaWduZWQzMUJpdEludCkgPT09IGNoYW5nZWRCaXRzKVxuICAgICAgICA/IHdhcm5pbmckMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhIFwiICtcbiAgICAgICAgICAgICAgXCIzMS1iaXQgaW50ZWdlci4gSW5zdGVhZCByZWNlaXZlZDogJXNcIixcbiAgICAgICAgICAgIGNoYW5nZWRCaXRzXG4gICAgICAgICAgKVxuICAgICAgICA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRCaXRzIHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY29udGV4dCxcbiAgY2hhbmdlZEJpdHMsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7XG5cbiAgICAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuICAgIHZhciBkZXBlbmRlbmN5ID0gZmliZXIuZmlyc3RDb250ZXh0RGVwZW5kZW5jeTtcbiAgICBpZiAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgZG8ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmXG4gICAgICAgICAgKGRlcGVuZGVuY3kub2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHxcbiAgICAgICAgICAgIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUocmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgICAgICBmaWJlci5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWJlci5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgICAgICAgIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2hpbGQgZXhwaXJhdGlvbiB0aW1lIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmdcbiAgICAgICAgICAvLyB0aGUgYWx0ZXJuYXRlcy5cbiAgICAgICAgICB2YXIgbm9kZSA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgICAgICAgIG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgbm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgIChhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgICAvLyBhbmNlc3RvciBwYXRoIGFscmVhZHkgaGFzIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH0gd2hpbGUgKGRlcGVuZGVuY3kgIT09IG51bGwpO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDb250ZXh0UHJvdmlkZXIpIHtcbiAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgbmV4dEZpYmVyID0gZmliZXIudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MudHlwZSA/IG51bGwgOiBmaWJlci5jaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cblxuICAgIGlmIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbW9yZSBzaWJsaW5ncy4gVHJhdmVyc2UgdXAuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICBpZiAobGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID09PSBjb250ZXh0KSB7XG4gICAgLy8gTm90aGluZyB0byBkby4gV2UgYWxyZWFkeSBvYnNlcnZlIGV2ZXJ5dGhpbmcgaW4gdGhpcyBjb250ZXh0LlxuICB9IGVsc2UgaWYgKG9ic2VydmVkQml0cyA9PT0gZmFsc2UgfHwgb2JzZXJ2ZWRCaXRzID09PSAwKSB7XG4gICAgLy8gRG8gbm90IG9ic2VydmUgYW55IHVwZGF0ZXMuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gdm9pZCAwOyAvLyBBdm9pZCBkZW9wdGluZyBvbiBvYnNlcnZhYmxlIGFyZ3VtZW50cyBvciBoZXRlcm9nZW5lb3VzIHR5cGVzLlxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvYnNlcnZlZEJpdHMgIT09IFwibnVtYmVyXCIgfHxcbiAgICAgIG9ic2VydmVkQml0cyA9PT0gbWF4U2lnbmVkMzFCaXRJbnRcbiAgICApIHtcbiAgICAgIC8vIE9ic2VydmUgYWxsIHVwZGF0ZXMuXG4gICAgICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBjb250ZXh0O1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBtYXhTaWduZWQzMUJpdEludDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHM7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG9ic2VydmVkQml0czogcmVzb2x2ZWRPYnNlcnZlZEJpdHMsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgIT09IG51bGwsXG4gICAgICAgIFwiQ29udGV4dC51bnN0YWJsZV9yZWFkKCk6IENvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyBcIiArXG4gICAgICAgICAgXCJyZW5kZXJpbmcsIGUuZy4gaW5zaWRlIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIlxuICAgICAgKTtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRlcGVuZGVuY3kgaW4gdGhlIGxpc3RcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG4gIHJldHVybiBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IkMSA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgaW52YXJpYW50KFxuICAgIGMgIT09IE5PX0NPTlRFWFQsXG4gICAgXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBcIiArXG4gICAgICBcImluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICApO1xuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG4gIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gIC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcbiAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yJDEuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxudmFyIGNvbW1pdFRpbWUgPSAwO1xudmFyIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG5cbmZ1bmN0aW9uIGdldENvbW1pdFRpbWUoKSB7XG4gIHJldHVybiBjb21taXRUaW1lO1xufVxuXG5mdW5jdGlvbiByZWNvcmRDb21taXRUaW1lKCkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tbWl0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyKSB7XG4gIGlmICghZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG4gIGlmICghZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9maWxlclN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICB9XG59XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlb2Ygb2JqQSAhPT0gXCJvYmplY3RcIiB8fFxuICAgIG9iakEgPT09IG51bGwgfHxcbiAgICB0eXBlb2Ygb2JqQiAhPT0gXCJvYmplY3RcIiB8fFxuICAgIG9iakIgPT09IG51bGxcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHxcbiAgICAgICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG52YXIgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuXG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24oY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyBcIl9cIiArIGNhbGxiYWNrO1xuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIiVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSBcIiArXG4gICAgICAgICAgXCJmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgIGNhbGxlck5hbWUsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbih0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gXCIgK1xuICAgICAgICAgICAgXCJZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsIFwiX3Byb2Nlc3NDaGlsZENvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IFwiICtcbiAgICAgICAgICBcIm1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBcIiArXG4gICAgICAgICAgXCJhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyBcIiArXG4gICAgICAgICAgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgK1xuICAgICAgICAgIFwidG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggXCIgK1xuICAgICAgICAgIFwidG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjdG9yLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gIG5leHRQcm9wc1xuKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoXG4gICAgICBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHxcbiAgICAgIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKVxuICAgICkge1xuICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuICB9XG4gIC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG4gIHZhciBtZW1vaXplZFN0YXRlID1cbiAgICBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWRcbiAgICAgID8gcHJldlN0YXRlXG4gICAgICA6IE9iamVjdC5hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG5cbiAgLy8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4gIC8vIGJhc2Ugc3RhdGUuXG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24oaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQkMShpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24oaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQkMShpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgXCJyZXBsYWNlU3RhdGVcIik7XG4gICAgICB9XG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0JDEoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCBcImZvcmNlVXBkYXRlXCIpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjdG9yLFxuICBvbGRQcm9wcyxcbiAgbmV3UHJvcHMsXG4gIG9sZFN0YXRlLFxuICBuZXdTdGF0ZSxcbiAgbmV4dENvbnRleHRcbikge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsIFwic2hvdWxkQ29tcG9uZW50VXBkYXRlXCIpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG5ld1N0YXRlLFxuICAgICAgbmV4dENvbnRleHRcbiAgICApO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICB7XG4gICAgICAhKHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCIlcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSBcIiArXG4gICAgICAgICAgICAgIFwiYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiB0eXBlb2YgY3Rvci5wcm90b3R5cGUucmVuZGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgXCJpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj9cIixcbiAgICAgICAgICBuYW1lXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICBcImluc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC5cIixcbiAgICAgICAgICBuYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPVxuICAgICAgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSB8fFxuICAgICAgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8XG4gICAgICBpbnN0YW5jZS5zdGF0ZTtcbiAgICAhbm9HZXRJbml0aWFsU3RhdGVPbkVTNlxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gXCIgK1xuICAgICAgICAgICAgXCJUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIFwiICtcbiAgICAgICAgICAgIFwiRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/XCIsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICA6IHZvaWQgMDtcbiAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9XG4gICAgICAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8XG4gICAgICBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgIW5vR2V0RGVmYXVsdFByb3BzT25FUzZcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuIFwiICtcbiAgICAgICAgICAgIFwiVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBcIiArXG4gICAgICAgICAgICBcIlVzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuXCIsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZVByb3BUeXBlcyA9ICFpbnN0YW5jZS5wcm9wVHlwZXM7XG4gICAgIW5vSW5zdGFuY2VQcm9wVHlwZXNcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgXCIgK1xuICAgICAgICAgICAgXCJwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuXCIsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlID0gIWluc3RhbmNlLmNvbnRleHRUeXBlO1xuICAgICFub0luc3RhbmNlQ29udGV4dFR5cGVcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyBcIiArXG4gICAgICAgICAgICBcInByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICFub0luc3RhbmNlQ29udGV4dFR5cGVzXG4gICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcImNvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIFwiICtcbiAgICAgICAgICAgIFwicHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG5cbiAgICBpZiAoXG4gICAgICBjdG9yLmNvbnRleHRUeXBlICYmXG4gICAgICBjdG9yLmNvbnRleHRUeXBlcyAmJlxuICAgICAgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCIlcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuIFwiICtcbiAgICAgICAgICBcIlRoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gXCJmdW5jdGlvblwiO1xuICAgICFub0NvbXBvbmVudFNob3VsZFVwZGF0ZVxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFwiICtcbiAgICAgICAgICAgIFwiY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gXCIgK1xuICAgICAgICAgICAgXCJUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgXCIgK1xuICAgICAgICAgICAgXCJleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS5cIixcbiAgICAgICAgICBuYW1lXG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICAgIGlmIChcbiAgICAgIGN0b3IucHJvdG90eXBlICYmXG4gICAgICBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJlxuICAgICAgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBcIiArXG4gICAgICAgICAgXCJzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFwiICtcbiAgICAgICAgICBcIlBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8IFwiQSBwdXJlIGNvbXBvbmVudFwiXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID1cbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSBcImZ1bmN0aW9uXCI7XG4gICAgIW5vQ29tcG9uZW50RGlkVW5tb3VudFxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFwiICtcbiAgICAgICAgICAgIFwiY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBcIiArXG4gICAgICAgICAgICBcIkRpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpP1wiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID1cbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgIT09IFwiZnVuY3Rpb25cIjtcbiAgICAhbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHNcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBcIiArXG4gICAgICAgICAgICBcImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCBcIiArXG4gICAgICAgICAgICBcInVzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yIFwiICtcbiAgICAgICAgICAgIFwicnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuXCIsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApXG4gICAgICA6IHZvaWQgMDtcbiAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID1cbiAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSBcImZ1bmN0aW9uXCI7XG4gICAgIW5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wc1xuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIFwiICtcbiAgICAgICAgICAgIFwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpP1wiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIG5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09IFwiZnVuY3Rpb25cIjtcbiAgICAhbm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzXG4gICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgXCIgK1xuICAgICAgICAgICAgXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICBuYW1lXG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG4gICAgIShpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMpXG4gICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzIFwiICtcbiAgICAgICAgICAgIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICAgIHZhciBub0luc3RhbmNlRGVmYXVsdFByb3BzID0gIWluc3RhbmNlLmRlZmF1bHRQcm9wcztcbiAgICAhbm9JbnN0YW5jZURlZmF1bHRQcm9wc1xuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuXCIgK1xuICAgICAgICAgICAgXCIgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy5cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKVxuICAgICkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gXCIgK1xuICAgICAgICAgIFwiVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuXCIsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUoY3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gXCJmdW5jdGlvblwiO1xuICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBcIiArXG4gICAgICAgICAgICBcImFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPVxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gXCJmdW5jdGlvblwiO1xuICAgICFub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoXG4gICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCBcIiArXG4gICAgICAgICAgICBcImFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLlwiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIG5vU3RhdGljR2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPVxuICAgICAgdHlwZW9mIGN0b3IuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09IFwiZnVuY3Rpb25cIjtcbiAgICAhbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBpcyBkZWZpbmVkIGFzIGEgc3RhdGljIG1ldGhvZCBcIiArXG4gICAgICAgICAgICBcImFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGlmIChfc3RhdGUgJiYgKHR5cGVvZiBfc3RhdGUgIT09IFwib2JqZWN0XCIgfHwgaXNBcnJheSQxKF9zdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIiVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbFwiLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAhKHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSBcIm9iamVjdFwiKVxuICAgICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCIlcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIFwiICtcbiAgICAgICAgICAgICAgXCJ1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgKVxuICAgICAgICA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY3RvcixcbiAgcHJvcHMsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgdmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0ID0gbnVsbDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gXCJvYmplY3RcIiAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGNvbnRleHRUeXBlLnVuc3RhYmxlX3JlYWQgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKVxuICAgICAgKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gXCIgK1xuICAgICAgICAgICAgXCJjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4gXCIgK1xuICAgICAgICAgICAgXCJEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/XCIsXG4gICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNvbnRleHRUeXBlLnVuc3RhYmxlX3JlYWQoKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9XG4gICAgICBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gICAgY29udGV4dCA9IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyXG4gICAgICA/IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dClcbiAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICB7XG4gICAgaWYgKFxuICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSlcbiAgICApIHtcbiAgICAgIG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gIHZhciBzdGF0ZSA9ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGluc3RhbmNlLnN0YXRlXG4gICAgICA6IG51bGwpO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gXCJmdW5jdGlvblwiICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzIFwiICtcbiAgICAgICAgICAgIFwiJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgXCIgK1xuICAgICAgICAgICAgXCJhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gXCIgK1xuICAgICAgICAgICAgXCJUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICAgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICAgICkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSBcImNvbXBvbmVudFdpbGxNb3VudFwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFwiO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZVxuICAgICAgKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBcImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICApIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWVcbiAgICAgICkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBcIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlXCI7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fFxuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICAgIHZhciBuZXdBcGlOYW1lID1cbiAgICAgICAgICB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBcImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpXCJcbiAgICAgICAgICAgIDogXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpXCI7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIFwiJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcblwiICtcbiAgICAgICAgICAgICAgXCJUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG5cIiArXG4gICAgICAgICAgICAgIFwiaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzXCIsXG4gICAgICAgICAgICBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIG5ld0FwaU5hbWUsXG4gICAgICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiBcIlwiLFxuICAgICAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbFxuICAgICAgICAgICAgICA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWVcbiAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiBcIlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsIFwiY29tcG9uZW50V2lsbE1vdW50XCIpO1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIiVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBcIiArXG4gICAgICAgICAgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgK1xuICAgICAgICAgIFwiY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICApO1xuICAgIH1cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgaW5zdGFuY2UsXG4gIG5ld1Byb3BzLFxuICBuZXh0Q29udGV4dFxuKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsIFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKTtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byBcIiArXG4gICAgICAgICAgICBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICtcbiAgICAgICAgICAgIFwiY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn1cblxuLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY3RvcixcbiAgbmV3UHJvcHMsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSBlbXB0eVJlZnNPYmplY3Q7XG5cbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gXCJvYmplY3RcIiAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBjb250ZXh0VHlwZS51bnN0YWJsZV9yZWFkKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIiVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlIFwiICtcbiAgICAgICAgICAgIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgK1xuICAgICAgICAgICAgXCJJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LlwiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG5cbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmREZXByZWNhdGlvbldhcm5pbmdzKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgaW5zdGFuY2VcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgdXBkYXRlUXVldWUsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIGluc3RhbmNlLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV3UHJvcHNcbiAgICApO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICBpZiAoXG4gICAgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpXG4gICkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgdXBkYXRlUXVldWUsXG4gICAgICAgIG5ld1Byb3BzLFxuICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2UoXG4gIHdvcmtJblByb2dyZXNzLFxuICBjdG9yLFxuICBuZXdQcm9wcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gXCJvYmplY3RcIiAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gY29udGV4dFR5cGUudW5zdGFibGVfcmVhZCgpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPVxuICAgIHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKFxuICAgICFoYXNOZXdMaWZlY3ljbGVzICYmXG4gICAgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiKVxuICApIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSAoaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZSk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cbiAgaWYgKFxuICAgIG9sZFByb3BzID09PSBuZXdQcm9wcyAmJlxuICAgIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJlxuICAgICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmXG4gICAgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKVxuICApIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV3UHJvcHNcbiAgICApO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPVxuICAgIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fFxuICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG9sZFN0YXRlLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBuZXh0Q29udGV4dFxuICAgICk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKFxuICAgICAgIWhhc05ld0xpZmVjeWNsZXMgJiZcbiAgICAgICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09IFwiZnVuY3Rpb25cIilcbiAgICApIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgXCJjb21wb25lbnRXaWxsTW91bnRcIik7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY3RvcixcbiAgbmV3UHJvcHMsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG5cbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09IFwib2JqZWN0XCIgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IGNvbnRleHRUeXBlLnVuc3RhYmxlX3JlYWQoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dFVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPVxuICAgIHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKFxuICAgICFoYXNOZXdMaWZlY3ljbGVzICYmXG4gICAgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gXCJmdW5jdGlvblwiKVxuICApIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcblxuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSAoaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZSk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgbmV3UHJvcHMsXG4gICAgICBpbnN0YW5jZSxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAoXG4gICAgb2xkUHJvcHMgPT09IG5ld1Byb3BzICYmXG4gICAgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmXG4gICAgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiZcbiAgICAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpXG4gICkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKFxuICAgICAgICBvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgb2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICApIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICBuZXdQcm9wc1xuICAgICk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9XG4gICAgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8XG4gICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoXG4gICAgICAhaGFzTmV3TGlmZWN5Y2xlcyAmJlxuICAgICAgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsIFwiY29tcG9uZW50V2lsbFVwZGF0ZVwiKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKFxuICAgICAgICBvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgIG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZSA9IHZvaWQgMDtcbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24oY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUgPSB7fTtcblxuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIHR5cGVvZiBjaGlsZC5fc3RvcmUgPT09IFwib2JqZWN0XCIsXG4gICAgICBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gXCIgK1xuICAgICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICApO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPVxuICAgICAgXCJFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwiICtcbiAgICAgICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArXG4gICAgICBcIm1vcmUgaW5mb3JtYXRpb24uXCIgK1xuICAgICAgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpO1xuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAgIHdhcm5pbmckMShcbiAgICAgIGZhbHNlLFxuICAgICAgXCJFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwiICtcbiAgICAgICAgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICtcbiAgICAgICAgXCJtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgKTtcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChcbiAgICBtaXhlZFJlZiAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBtaXhlZFJlZiAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgdHlwZW9mIG1peGVkUmVmICE9PSBcIm9iamVjdFwiXG4gICkge1xuICAgIHtcbiAgICAgIGlmIChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArXG4gICAgICAgICAgICAgIFwiU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gXCIgK1xuICAgICAgICAgICAgICBcIldlIHJlY29tbWVuZCB1c2luZyBjcmVhdGVSZWYoKSBpbnN0ZWFkLlwiICtcbiAgICAgICAgICAgICAgXCJcXG4lc1wiICtcbiAgICAgICAgICAgICAgXCJcXG5cXG5MZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6XCIgK1xuICAgICAgICAgICAgICBcIlxcbmh0dHBzOi8vZmIubWUvcmVhY3Qtc3RyaWN0LW1vZGUtc3RyaW5nLXJlZlwiLFxuICAgICAgICAgICAgbWl4ZWRSZWYsXG4gICAgICAgICAgICBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QocmV0dXJuRmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgIGludmFyaWFudChcbiAgICAgICAgICBvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHxcbiAgICAgICAgICAgIG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudExhenksXG4gICAgICAgICAgXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuXCJcbiAgICAgICAgKTtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KFxuICAgICAgICBpbnN0LFxuICAgICAgICBcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIFwiICtcbiAgICAgICAgICBcImJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgIG1peGVkUmVmXG4gICAgICApO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9IFwiXCIgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKFxuICAgICAgICBjdXJyZW50JCQxICE9PSBudWxsICYmXG4gICAgICAgIGN1cnJlbnQkJDEucmVmICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjdXJyZW50JCQxLnJlZiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGN1cnJlbnQkJDEucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50JCQxLnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcbiAgICAgICAgaWYgKHJlZnMgPT09IGVtcHR5UmVmc09iamVjdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXp5IHBvb2xlZCBmcm96ZW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUuXG4gICAgICAgICAgcmVmcyA9IGluc3QucmVmcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIG1peGVkUmVmID09PSBcInN0cmluZ1wiLFxuICAgICAgICBcIkV4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLlwiXG4gICAgICApO1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBlbGVtZW50Ll9vd25lcixcbiAgICAgICAgXCJFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2ZcIiArXG4gICAgICAgICAgXCIgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcblwiICtcbiAgICAgICAgICBcIjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuXCIgK1xuICAgICAgICAgIFwiMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcblwiICtcbiAgICAgICAgICBcIjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5cIiArXG4gICAgICAgICAgXCJTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lciBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIixcbiAgICAgICAgbWl4ZWRSZWZcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gXCJ0ZXh0YXJlYVwiKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gXCJcIjtcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9XG4gICAgICAgIFwiIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgXCIgK1xuICAgICAgICBcImluc3RlYWQuXCIgK1xuICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lc1wiLFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIlxuICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgOiBuZXdDaGlsZCxcbiAgICAgIGFkZGVuZHVtXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICBcIkZ1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiBcIiArXG4gICAgXCJ5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gXCIgK1xuICAgIFwiT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCIgK1xuICAgIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKTtcblxuICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgd2FybmluZyQxKFxuICAgIGZhbHNlLFxuICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIFwiICtcbiAgICAgIFwieW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuIFwiICtcbiAgICAgIFwiT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXCJcbiAgKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCQkMSA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudCQkMS5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50JCQxLFxuICAgIHRleHRDb250ZW50LFxuICAgIGV4cGlyYXRpb25UaW1lXG4gICkge1xuICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsIHx8IGN1cnJlbnQkJDEudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50JCQxLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCAmJiBjdXJyZW50JCQxLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBlbGVtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoXG4gICAgICBjdXJyZW50JCQxID09PSBudWxsIHx8XG4gICAgICBjdXJyZW50JCQxLnRhZyAhPT0gSG9zdFBvcnRhbCB8fFxuICAgICAgY3VycmVudCQkMS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgIGN1cnJlbnQkJDEuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICApIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgIHBvcnRhbCxcbiAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50JCQxLFxuICAgIGZyYWdtZW50LFxuICAgIGV4cGlyYXRpb25UaW1lLFxuICAgIGtleVxuICApIHtcbiAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgZnJhZ21lbnQsXG4gICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBrZXlcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwib2JqZWN0XCIgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6IHtcbiAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY3JlYXRlZDIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcIm9iamVjdFwiICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOiB7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKFxuICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgcmV0dXJuRmliZXIsXG4gICAgbmV3SWR4LFxuICAgIG5ld0NoaWxkLFxuICAgIGV4cGlyYXRpb25UaW1lXG4gICkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG5ld0NoaWxkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBtYXRjaGVkRmliZXIsXG4gICAgICAgIFwiXCIgKyBuZXdDaGlsZCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID1cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICBuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICkgfHwgbnVsbDtcbiAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgX21hdGNoZWRGaWJlcixcbiAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBfbWF0Y2hlZEZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRToge1xuICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9XG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmdldChcbiAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICApIHx8IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgX21hdGNoZWRGaWJlcjIsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgX21hdGNoZWRGaWJlcjMsXG4gICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09IFwib2JqZWN0XCIgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nJDEoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwiRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiBcIiArXG4gICAgICAgICAgICAgIFwiS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBcIiArXG4gICAgICAgICAgICAgIFwiYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgXCIgK1xuICAgICAgICAgICAgICBcImR1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICBcImNvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiLFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgcmV0dXJuRmliZXIsXG4gICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgbmV3Q2hpbGRyZW4sXG4gICAgZXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aHMgZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cblxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cblxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgICApO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKFxuICAgICAgICAgICAgICBfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoXG4gICAgcmV0dXJuRmliZXIsXG4gICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgbmV3Q2hpbGRyZW5JdGVyYWJsZSxcbiAgICBleHBpcmF0aW9uVGltZVxuICApIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgaW52YXJpYW50KFxuICAgICAgdHlwZW9mIGl0ZXJhdG9yRm4gPT09IFwiZnVuY3Rpb25cIixcbiAgICAgIFwiQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICtcbiAgICAgICAgXCJSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICApO1xuXG4gICAge1xuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgICAgIG5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJHZW5lcmF0b3JcIlxuICAgICAgKSB7XG4gICAgICAgICFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzXG4gICAgICAgICAgPyB3YXJuaW5nJDEoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICBcIlVzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkIFwiICtcbiAgICAgICAgICAgICAgICBcInVuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuIFwiICtcbiAgICAgICAgICAgICAgICBcIllvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgXCJgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCBcIiArXG4gICAgICAgICAgICAgICAgXCJ5b3UgbWlnaHQgbmVlZCB0byBwb2x5ZmlsbCB0aGVzZSBmZWF0dXJlcyBmb3Igb2xkZXIgYnJvd3NlcnMuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAhZGlkV2FybkFib3V0TWFwc1xuICAgICAgICAgID8gd2FybmluZyQxKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgXCJVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCBcIiArXG4gICAgICAgICAgICAgICAgXCJ1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCBcIiArXG4gICAgICAgICAgICAgICAgXCJSZWFjdEVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICBpbnZhcmlhbnQobmV3Q2hpbGRyZW4gIT0gbnVsbCwgXCJBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuXCIpO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yIChcbiAgICAgIDtcbiAgICAgIG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7XG4gICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4sXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBuZXdJZHgsXG4gICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShcbiAgICAgICAgICAgICAgX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICB0ZXh0Q29udGVudCxcbiAgICBleHBpcmF0aW9uVGltZVxuICApIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgdGV4dENvbnRlbnQsXG4gICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICApO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KFxuICAgIHJldHVybkZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgIGVsZW1lbnQsXG4gICAgZXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaGlsZC50YWcgPT09IEZyYWdtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgOiBjaGlsZC50eXBlID09PSBlbGVtZW50LnR5cGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKFxuICAgICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgICBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEVcbiAgICAgICAgICAgICAgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgIDogZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICBleHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKFxuICAgIHJldHVybkZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgIHBvcnRhbCxcbiAgICBleHBpcmF0aW9uVGltZVxuICApIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmXG4gICAgICAgICAgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmXG4gICAgICAgICAgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgIHBvcnRhbCxcbiAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICBleHBpcmF0aW9uVGltZVxuICAgICk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgcmV0dXJuRmliZXIsXG4gICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgbmV3Q2hpbGQsXG4gICAgZXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICB2YXIgaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCA9XG4gICAgICB0eXBlb2YgbmV3Q2hpbGQgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIG5ld0NoaWxkICE9PSBudWxsICYmXG4gICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmXG4gICAgICBuZXdDaGlsZC5rZXkgPT09IG51bGw7XG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gXCJvYmplY3RcIiAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChcbiAgICAgICAgICAgIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChcbiAgICAgICAgICAgIHJlY29uY2lsZVNpbmdsZVBvcnRhbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG5ld0NoaWxkID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChcbiAgICAgICAgcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICAgIGV4cGlyYXRpb25UaW1lXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09IFwidW5kZWZpbmVkXCIgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6IHtcbiAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwiJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIFwiICtcbiAgICAgICAgICAgICAgXCJyZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgXCIgK1xuICAgICAgICAgICAgICBcInJldHVybiBudWxsLlwiLFxuICAgICAgICAgICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKSB7XG4gIGludmFyaWFudChcbiAgICBjdXJyZW50JCQxID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50JCQxLmNoaWxkLFxuICAgIFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiXG4gICk7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhcbiAgICBjdXJyZW50Q2hpbGQsXG4gICAgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyxcbiAgICBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWVcbiAgKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgICBjdXJyZW50Q2hpbGQsXG4gICAgICBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLFxuICAgICAgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lXG4gICAgKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxuLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxudmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbnZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShcbiAgICAgICAgICByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKFxuICAgICAgICAgIHJldHVybkZpYmVyLnR5cGUsXG4gICAgICAgICAgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICByZXR1cm5GaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuXG4gIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gIC8vIHJlY3JlYXRlZC5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OiB7XG4gICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShcbiAgICAgICAgICAgICAgcGFyZW50VHlwZSxcbiAgICAgICAgICAgICAgcGFyZW50UHJvcHMsXG4gICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLFxuICAgICAgICAgICAgICBfdHlwZSxcbiAgICAgICAgICAgICAgX3Byb3BzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgICBwYXJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgIF90ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDoge1xuICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcbiAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgIC8vIG1pZ2h0IGJlIGZsYXdlZCBvciB1bm5lY2Vzc2FyeS5cbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgIC8vIHN1cGVyZmx1b3VzIGFuZCB3ZSdsbCBkZWxldGUgaXQuIFNpbmNlIHdlIGNhbid0IGVhZ2VybHkgZGVsZXRlIGl0XG4gICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKFxuICBmaWJlcixcbiAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICBob3N0Q29udGV4dFxuKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gXCIgK1xuICAgICAgICBcIlRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShcbiAgICBpbnN0YW5jZSxcbiAgICBmaWJlci50eXBlLFxuICAgIGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgIGhvc3RDb250ZXh0LFxuICAgIGZpYmVyXG4gICk7XG4gIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFwiICtcbiAgICAgICAgXCJUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgIHBhcmVudENvbnRhaW5lcixcbiAgICAgICAgICAgICAgdGV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICB0ZXh0Q29udGVudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgICBwYXJlbnRQcm9wcyxcbiAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgIHRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAoXG4gICAgcGFyZW50ICE9PSBudWxsICYmXG4gICAgcGFyZW50LnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJlxuICAgIHBhcmVudC50YWcgIT09IEhvc3RSb290XG4gICkge1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gIC8vIHNpZGUgb2YgdGhlbS5cbiAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgaWYgKFxuICAgIGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fFxuICAgICh0eXBlICE9PSBcImhlYWRcIiAmJlxuICAgICAgdHlwZSAhPT0gXCJib2R5XCIgJiZcbiAgICAgICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSlcbiAgKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSlcbiAgICA6IG51bGw7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVhZExhenlDb21wb25lbnRUeXBlKHRoZW5hYmxlKSB7XG4gIHZhciBzdGF0dXMgPSB0aGVuYWJsZS5fcmVhY3RTdGF0dXM7XG4gIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgY2FzZSBSZXNvbHZlZDpcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGVuYWJsZS5fcmVhY3RSZXN1bHQ7XG4gICAgICByZXR1cm4gQ29tcG9uZW50O1xuICAgIGNhc2UgUmVqZWN0ZWQ6XG4gICAgICB0aHJvdyB0aGVuYWJsZS5fcmVhY3RSZXN1bHQ7XG4gICAgY2FzZSBQZW5kaW5nOlxuICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhlbmFibGUuX3JlYWN0U3RhdHVzID0gUGVuZGluZztcbiAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKHJlc29sdmVkVmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhlbmFibGUuX3JlYWN0U3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5fcmVhY3RTdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiByZXNvbHZlZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBgZGVmYXVsdGAgcHJvcGVydHkgaXMgbm90IGVtcHR5LCBhc3N1bWUgaXQncyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgIC8vIG9mIGFuIGFzeW5jIGltcG9ydCgpIGFuZCB1c2UgdGhhdC4gT3RoZXJ3aXNlLCB1c2UgdGhlXG4gICAgICAgICAgICAgIC8vIHJlc29sdmVkIHZhbHVlIGl0c2VsZi5cbiAgICAgICAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSByZXNvbHZlZFZhbHVlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPVxuICAgICAgICAgICAgICAgIGRlZmF1bHRFeHBvcnQgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0RXhwb3J0ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICA/IGRlZmF1bHRFeHBvcnRcbiAgICAgICAgICAgICAgICAgIDogcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmVkVmFsdWUgPSByZXNvbHZlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlbmFibGUuX3JlYWN0UmVzdWx0ID0gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoZW5hYmxlLl9yZWFjdFN0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAgICAgdGhlbmFibGUuX3JlYWN0U3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgICAgICB0aGVuYWJsZS5fcmVhY3RSZXN1bHQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aHJvdyB0aGVuYWJsZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDMgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcblxudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBuZXh0Q2hpbGRyZW4sXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBudWxsLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgLy8gd2UgaGF2ZW4ndCB5ZXQgc3RhcnRlZCBhbnkgd29yayBvbiB0aGVzZSBjaGlsZHJlbi4gVGhlcmVmb3JlLCB3ZSB1c2VcbiAgICAvLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY3VycmVudCQkMS5jaGlsZCxcbiAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKFxuICBjdXJyZW50JCQxLFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgbmV4dENoaWxkcmVuLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZVxuKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4gIC8vIHdhbnQgdG8gcmVjb25jaWxlIHdpdGhvdXQgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZXhpc3Rpbmcgc2V0LiBUaGlzIGhhcyB0aGVcbiAgLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4gIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4gIC8vXG4gIC8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4gIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbiAgLy8gcGFzc2luZyBudWxsLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIGN1cnJlbnQkJDEuY2hpbGQsXG4gICAgbnVsbCxcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyIHRoZWlyXG4gIC8vIGlkZW50aXR5IG1hdGNoZXMuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgbnVsbCxcbiAgICBuZXh0Q2hpbGRyZW4sXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihcbiAgY3VycmVudCQkMSxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHR5cGUsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICB2YXIgcmVuZGVyID0gdHlwZS5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLnJlZiA6IG51bGw7XG4gICAgaWYgKHJlZiA9PT0gY3VycmVudFJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0Q3VycmVudFBoYXNlKFwicmVuZGVyXCIpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcihuZXh0UHJvcHMsIHJlZik7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgY3VycmVudCQkMSxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBuZXh0Q2hpbGRyZW4sXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVB1cmVDb21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgdXBkYXRlRXhwaXJhdGlvblRpbWUsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG5cbiAgaWYgKFxuICAgIGN1cnJlbnQkJDEgIT09IG51bGwgJiZcbiAgICAodXBkYXRlRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgdXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSlcbiAgKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgICAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuICAgIGlmIChjb21wYXJlKHByZXZQcm9wcywgbmV4dFByb3BzKSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZShcInJlbmRlclwiKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXIobmV4dFByb3BzKTtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgIGN1cnJlbnQkJDEsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgbmV4dENoaWxkcmVuLFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICk7XG4gIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBpZiAoXG4gICAgKGN1cnJlbnQkJDEgPT09IG51bGwgJiYgcmVmICE9PSBudWxsKSB8fFxuICAgIChjdXJyZW50JCQxICE9PSBudWxsICYmIGN1cnJlbnQkJDEucmVmICE9PSByZWYpXG4gICkge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldEN1cnJlbnRQaGFzZShcInJlbmRlclwiKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSBDb21wb25lbnQobmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cblxuICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgdmFyIGhhc0NvbnRleHQgPSB2b2lkIDA7XG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBtb3VudENsYXNzSW5zdGFuY2UoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShcbiAgICAgIGN1cnJlbnQkJDEsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoXG4gICAgY3VycmVudCQkMSxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICBDb21wb25lbnQsXG4gICAgc2hvdWxkVXBkYXRlLFxuICAgIGhhc0NvbnRleHQsXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIHNob3VsZFVwZGF0ZSxcbiAgaGFzQ29udGV4dCxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcblxuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpICE9PSBOb0VmZmVjdDtcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgY3VycmVudCQkMSxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIC8vIFJlcmVuZGVyXG4gIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICBpZiAoXG4gICAgZGlkQ2FwdHVyZUVycm9yICYmXG4gICAgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09IFwiZnVuY3Rpb25cIlxuICApIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb20gY2F0Y2ggaXMgbm90IGRlZmluZWQsXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG4gICAgLy8gdGhlIG5ldyBBUEkuXG4gICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50UGhhc2UoXCJyZW5kZXJcIik7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChcbiAgICAgICAgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8XG4gICAgICAgIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpXG4gICAgICApIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBzZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwgJiYgZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgd2l0aG91dCByZXVzaW5nIGFueSBvZlxuICAgIC8vIHRoZSBleGlzdGluZyBjaGlsZHJlbi4gQ29uY2VwdHVhbGx5LCB0aGUgbm9ybWFsIGNoaWxkcmVuIGFuZCB0aGUgY2hpbGRyZW5cbiAgICAvLyB0aGF0IGFyZSBzaG93biBvbiBlcnJvciBhcmUgdHdvIGRpZmZlcmVudCBzZXRzLCBzbyB3ZSBzaG91bGRuJ3QgcmV1c2VcbiAgICAvLyBub3JtYWwgY2hpbGRyZW4gZXZlbiBpZiB0aGVpciBpZGVudGl0aWVzIG1hdGNoLlxuICAgIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoXG4gICAgICBjdXJyZW50JCQxLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICBjdXJyZW50JCQxLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gIH1cblxuICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG4gIGlmIChoYXNDb250ZXh0KSB7XG4gICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByb290LnBlbmRpbmdDb250ZXh0LFxuICAgICAgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpbnZhcmlhbnQoXG4gICAgdXBkYXRlUXVldWUgIT09IG51bGwsXG4gICAgXCJJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IFwiICtcbiAgICAgIFwiYmFpbGVkIG91dC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgXCIgK1xuICAgICAgXCJmaWxlIGFuIGlzc3VlLlwiXG4gICk7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmVsZW1lbnQgOiBudWxsO1xuICBwcm9jZXNzVXBkYXRlUXVldWUoXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgdXBkYXRlUXVldWUsXG4gICAgbmV4dFByb3BzLFxuICAgIG51bGwsXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgY3VycmVudCQkMSxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICB9XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAoXG4gICAgKGN1cnJlbnQkJDEgPT09IG51bGwgfHwgY3VycmVudCQkMS5jaGlsZCA9PT0gbnVsbCkgJiZcbiAgICByb290Lmh5ZHJhdGUgJiZcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICApIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgIC8vIG5vZGVzIHRoYXQgd2lsbCBiZSBoeWRyYXRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgIC8vIHJvb3QuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICBjdXJyZW50JCQxLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBudWxsO1xuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG4gICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGF2ZSBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcblxuICAvLyBDaGVjayB0aGUgaG9zdCBjb25maWcgdG8gc2VlIGlmIHRoZSBjaGlsZHJlbiBhcmUgb2Zmc2NyZWVuL2hpZGRlbi5cbiAgaWYgKFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJlxuICAgIHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSAmJlxuICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUodHlwZSwgbmV4dFByb3BzKVxuICApIHtcbiAgICAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5leHRDaGlsZHJlbixcbiAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApO1xuICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICByZXR1cm4gYmFzZVByb3BzO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIHVwZGF0ZUV4cGlyYXRpb25UaW1lLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZVxuKSB7XG4gIGludmFyaWFudChcbiAgICBjdXJyZW50JCQxID09PSBudWxsLFxuICAgIFwiQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBcIiArXG4gICAgICBcImxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICk7XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBpZiAoXG4gICAgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJlxuICAgIENvbXBvbmVudCAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiBDb21wb25lbnQudGhlbiA9PT0gXCJmdW5jdGlvblwiXG4gICkge1xuICAgIENvbXBvbmVudCA9IHJlYWRMYXp5Q29tcG9uZW50VHlwZShDb21wb25lbnQpO1xuICAgIHZhciByZXNvbHZlZFRhZyA9ICh3b3JrSW5Qcm9ncmVzcy50YWcgPSByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50XG4gICAgKSk7XG4gICAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICAgIHZhciBjaGlsZCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHJlc29sdmVkVGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50TGF6eToge1xuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgIHJlc29sdmVkUHJvcHMsXG4gICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIEZvcndhcmRSZWZMYXp5OiB7XG4gICAgICAgIGNoaWxkID0gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICByZXNvbHZlZFByb3BzLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBQdXJlQ29tcG9uZW50TGF6eToge1xuICAgICAgICBjaGlsZCA9IHVwZGF0ZVB1cmVDb21wb25lbnQoXG4gICAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgcmVzb2x2ZWRQcm9wcyxcbiAgICAgICAgICB1cGRhdGVFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZXRpb24gRm9yd2FyZFJlZiBvciBQdXJlQ29tcG9uZW50XG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbC5cbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiAlcy4gXCIgK1xuICAgICAgICAgICAgXCJQcm9taXNlIGVsZW1lbnRzIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLlwiLFxuICAgICAgICAgIENvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gcHJvcHM7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gIHZhciB2YWx1ZSA9IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKFxuICAgICAgQ29tcG9uZW50LnByb3RvdHlwZSAmJlxuICAgICAgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICtcbiAgICAgICAgICAgIFwiVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpO1xuICB9XG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZFxuICApIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgdmFsdWUuc3RhdGUgIT09IG51bGwgJiYgdmFsdWUuc3RhdGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnN0YXRlIDogbnVsbDtcblxuICAgIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICAgIHByb3BzXG4gICAgICApO1xuICAgIH1cblxuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChcbiAgICAgIGN1cnJlbnQkJDEsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHRydWUsXG4gICAgICBoYXNDb250ZXh0LFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG4gICAge1xuICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAhIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlc1xuICAgICAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgXCIlcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cIixcbiAgICAgICAgICAgICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluZm8gPSBcIlwiO1xuICAgICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcbiAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgIGluZm8gKz0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lck5hbWUgKyBcImAuXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCBcIlwiO1xuICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgIHdhcm5pbmdLZXkgPSBkZWJ1Z1NvdXJjZS5maWxlTmFtZSArIFwiOlwiICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgd2FybmluZyQxKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIkZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuIFwiICtcbiAgICAgICAgICAgICAgXCJBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiVzXCIsXG4gICAgICAgICAgICBpbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCI7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCIlczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuXCIsXG4gICAgICAgICAgICBfY29tcG9uZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICBfY29tcG9uZW50TmFtZTJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIHByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJDb21wb25lbnQoXG4gIGN1cnJlbnQkJDEsXG4gIHdvcmtJblByb2dyZXNzLFxuICByZW5kZXJFeHBpcmF0aW9uVGltZVxuKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byByZW5kZXIgdGhlIG5vcm1hbCBzdGF0ZS4gSWYgd2UgZGlkLFxuICAgIC8vIGFuZCB3ZSB0aW1lZCBvdXQsIHJlbmRlciB0aGUgcGxhY2Vob2xkZXIgc3RhdGUuXG4gICAgdmFyIGFscmVhZHlDYXB0dXJlZCA9ICh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3Q7XG5cbiAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIG91dHNpZGUgc3RyaWN0IG1vZGUuIFNvbWV0aGluZyBpbnNpZGUgdGhpcyBQbGFjZWhvbGRlciBib3VuZGFyeVxuICAgICAgLy8gc3VzcGVuZGVkIGR1cmluZyB0aGUgbGFzdCBjb21taXQuIFN3aXRjaCB0byB0aGUgcGxhY2hvbGRlci5cbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgIG5leHREaWRUaW1lb3V0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dERpZFRpbWVvdXQgPSAhYWxyZWFkeUNhcHR1cmVkO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpICE9PSBOb0VmZmVjdCkge1xuICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgIC8vIElmIHRoZSB0aW1lZC1vdXQgdmlldyBjb21taXRzLCBzY2hlZHVsZSBhbiB1cGRhdGUgZWZmZWN0IHRvIHJlY29yZFxuICAgICAgICAvLyB0aGUgY29tbWl0dGVkIHRpbWUuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgc3RhdGUgbm9kZSBwb2ludHMgdG8gdGhlIHRpbWUgYXQgd2hpY2ggcGxhY2Vob2xkZXIgdGltZWQgb3V0LlxuICAgICAgICAvLyBXZSBjYW4gY2xlYXIgaXQgb25jZSB3ZSBzd2l0Y2ggYmFjayB0byB0aGUgbm9ybWFsIGNoaWxkcmVuLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBgY2hpbGRyZW5gIHByb3AgaXMgYSBmdW5jdGlvbiwgdHJlYXQgaXQgbGlrZSBhIHJlbmRlciBwcm9wLlxuICAgIC8vIFRPRE86IFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIGZpbmFsaXplIGEgbG93ZXIgbGV2ZWwgQVBJLlxuICAgIHZhciBjaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgbmV4dENoaWxkcmVuID0gY2hpbGRyZW4obmV4dERpZFRpbWVvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBuZXh0RGlkVGltZW91dCA/IG5leHRQcm9wcy5mYWxsYmFjayA6IGNoaWxkcmVuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGN1cnJlbnQkJDEgIT09IG51bGwgJiZcbiAgICAgIG5leHREaWRUaW1lb3V0ICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgKSB7XG4gICAgICAvLyBXZSdyZSBhYm91dCB0byBzd2l0Y2ggZnJvbSB0aGUgcGxhY2Vob2xkZXIgY2hpbGRyZW4gdG8gdGhlIG5vcm1hbFxuICAgICAgLy8gY2hpbGRyZW4sIG9yIHZpY2UgdmVyc2EuIFRoZXNlIGFyZSB0d28gZGlmZmVyZW50IGNvbmNlcHR1YWwgc2V0cyB0aGF0XG4gICAgICAvLyBoYXBwZW4gdG8gYmUgc3RvcmVkIGluIHRoZSBzYW1lIHNldC4gQ2FsbCB0aGlzIHNwZWNpYWwgZnVuY3Rpb24gdG9cbiAgICAgIC8vIGZvcmNlIHRoZSBuZXcgc2V0IG5vdCB0byBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHNldC5cbiAgICAgIC8vIFRPRE86IFRoZSBwcm9wZXIgd2F5IHRvIG1vZGVsIHRoaXMgaXMgYnkgc3RvcmluZyBlYWNoIHNldCBzZXBhcmF0ZWx5LlxuICAgICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dERpZFRpbWVvdXQ7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChcbiAgY3VycmVudCQkMSxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIG51bGwsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCQkMSxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihcbiAgY3VycmVudCQkMSxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgdmFyIHByb3ZpZGVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJUeXBlLl9jb250ZXh0O1xuXG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuXG4gIHtcbiAgICB2YXIgcHJvdmlkZXJQcm9wVHlwZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChwcm92aWRlclByb3BUeXBlcykge1xuICAgICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgIHByb3ZpZGVyUHJvcFR5cGVzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgXCJwcm9wXCIsXG4gICAgICAgIFwiQ29udGV4dC5Qcm92aWRlclwiLFxuICAgICAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuXG4gIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hhbmdlZEJpdHMsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICBjdXJyZW50JCQxLFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIG5ld0NoaWxkcmVuLFxuICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKFxuICBjdXJyZW50JCQxLFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbikge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJlbmRlciA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICAhKHR5cGVvZiByZW5kZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkIFwiICtcbiAgICAgICAgICAgIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArXG4gICAgICAgICAgICBcInRoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSBcIiArXG4gICAgICAgICAgICBcImlzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuXCJcbiAgICAgICAgKVxuICAgICAgOiB2b2lkIDA7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRDdXJyZW50UGhhc2UoXCJyZW5kZXJcIik7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgIGN1cnJlbnQkJDEsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgbmV3Q2hpbGRyZW4sXG4gICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbi8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgY3VycmVudCQkMSxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGNvbnRleHQgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50JCQxLmZpcnN0Q29udGV4dERlcGVuZGVuY3k7XG4gIH1cblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG4gIHZhciBjaGlsZEV4cGlyYXRpb25UaW1lID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgaWYgKFxuICAgIGNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgIGNoaWxkRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZVxuICApIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4gICAgLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbiAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG4vLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbmZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWU7XG5cbiAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChcbiAgICAgIG9sZFByb3BzID09PSBuZXdQcm9wcyAmJlxuICAgICAgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiZcbiAgICAgICh1cGRhdGVFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgIHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRvZXMgbm90IGhhdmUgYW55IHBlbmRpbmcgd29yay4gQmFpbG91dCB3aXRob3V0IGVudGVyaW5nXG4gICAgICAvLyB0aGUgYmVnaW4gcGhhc2UuIFRoZXJlJ3Mgc3RpbGwgc29tZSBib29ra2VlcGluZyB3ZSB0aGF0IG5lZWRzIHRvIGJlIGRvbmVcbiAgICAgIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OiB7XG4gICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgICAgIHZhciB0aGVuYWJsZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgdmFyIF9Db21wb25lbnQgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOiB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IHtcbiAgICAgIHZhciBfQ29tcG9uZW50MiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgX0NvbXBvbmVudDIsXG4gICAgICAgIHVwZGF0ZUV4cGlyYXRpb25UaW1lLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDoge1xuICAgICAgdmFyIF9Db21wb25lbnQzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBfQ29tcG9uZW50MyxcbiAgICAgICAgdW5yZXNvbHZlZFByb3BzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICB9XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudExhenk6IHtcbiAgICAgIHZhciBfdGhlbmFibGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgdmFyIF9Db21wb25lbnQ0ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUoX3RoZW5hYmxlKTtcbiAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgdmFyIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBfQ29tcG9uZW50NCxcbiAgICAgICAgcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50NCwgX3VucmVzb2x2ZWRQcm9wcyksXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IF91bnJlc29sdmVkUHJvcHM7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIHZhciBfQ29tcG9uZW50NSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBfQ29tcG9uZW50NSxcbiAgICAgICAgX3VucmVzb2x2ZWRQcm9wczIsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgdmFyIF90aGVuYWJsZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgdmFyIF9Db21wb25lbnQ2ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUoX3RoZW5hYmxlMik7XG4gICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB2YXIgX2NoaWxkID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBfQ29tcG9uZW50NixcbiAgICAgICAgcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50NiwgX3VucmVzb2x2ZWRQcm9wczMpLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBfdW5yZXNvbHZlZFByb3BzMztcbiAgICAgIHJldHVybiBfY2hpbGQ7XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlUGxhY2Vob2xkZXJDb21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgY2FzZSBGb3J3YXJkUmVmOiB7XG4gICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuICAgIGNhc2UgRm9yd2FyZFJlZkxhenk6IHtcbiAgICAgIHZhciBfdGhlbmFibGUzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIHZhciBfQ29tcG9uZW50NyA9IGdldFJlc3VsdEZyb21SZXNvbHZlZFRoZW5hYmxlKF90aGVuYWJsZTMpO1xuICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgdmFyIF9jaGlsZDIgPSB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgX0NvbXBvbmVudDcsXG4gICAgICAgIHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDcsIF91bnJlc29sdmVkUHJvcHM0KSxcbiAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gX3VucmVzb2x2ZWRQcm9wczQ7XG4gICAgICByZXR1cm4gX2NoaWxkMjtcbiAgICB9XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIGNhc2UgUHVyZUNvbXBvbmVudDoge1xuICAgICAgdmFyIF90eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIHJldHVybiB1cGRhdGVQdXJlQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50JCQxLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgX3R5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgdXBkYXRlRXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgIH1cbiAgICBjYXNlIFB1cmVDb21wb25lbnRMYXp5OiB7XG4gICAgICB2YXIgX3RoZW5hYmxlNCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB2YXIgX0NvbXBvbmVudDggPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShfdGhlbmFibGU0KTtcbiAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNSA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHZhciBfY2hpbGQzID0gdXBkYXRlUHVyZUNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIF9Db21wb25lbnQ4LFxuICAgICAgICByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQ4LCBfdW5yZXNvbHZlZFByb3BzNSksXG4gICAgICAgIHVwZGF0ZUV4cGlyYXRpb25UaW1lLFxuICAgICAgICByZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICAgKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBfdW5yZXNvbHZlZFByb3BzNTtcbiAgICAgIHJldHVybiBfY2hpbGQzO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArXG4gICAgICAgICAgXCJSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmJDEod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0VGV4dCQxID0gdm9pZCAwO1xuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbih3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24oXG4gICAgY3VycmVudCxcbiAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICB0eXBlLFxuICAgIG5ld1Byb3BzLFxuICAgIHJvb3RDb250YWluZXJJbnN0YW5jZVxuICApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4gICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgIC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAvLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuICAgIC8vIHJlbGF0ZWQgdG8gYGhpZGRlbmAuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKFxuICAgICAgaW5zdGFuY2UsXG4gICAgICB0eXBlLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGN1cnJlbnRIb3N0Q29udGV4dFxuICAgICk7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuXG4gIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uKFxuICAgIGNvbnRhaW5lckNoaWxkU2V0LFxuICAgIHdvcmtJblByb2dyZXNzXG4gICkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXIpO1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uKFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgdHlwZSxcbiAgICBuZXdQcm9wcyxcbiAgICByb290Q29udGFpbmVySW5zdGFuY2VcbiAgKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKFxuICAgICAgICByZWN5Y2xhYmxlSW5zdGFuY2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICBjdXJyZW50SG9zdENvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShcbiAgICAgIGN1cnJlbnRJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgICB0eXBlLFxuICAgICAgb2xkUHJvcHMsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgY2hpbGRyZW5VbmNoYW5nZWQsXG4gICAgICByZWN5Y2xhYmxlSW5zdGFuY2VcbiAgICApO1xuICAgIGlmIChcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICBuZXdJbnN0YW5jZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgY3VycmVudEhvc3RDb250ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgZWZmZWN0cyBpbiB0aGlzIHRyZWUsIHdlIG5lZWQgdG8gZmxhZyB0aGlzIG5vZGUgYXMgaGF2aW5nIG9uZS5cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgIG5ld1RleHQsXG4gICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgY3VycmVudEhvc3RDb250ZXh0LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgKTtcbiAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24od29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uKFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgdHlwZSxcbiAgICBuZXdQcm9wcyxcbiAgICByb290Q29udGFpbmVySW5zdGFuY2VcbiAgKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBOb29wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50TGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6IHtcbiAgICAgIHZhciBfQ29tcG9uZW50ID0gZ2V0UmVzdWx0RnJvbVJlc29sdmVkVGhlbmFibGUod29ya0luUHJvZ3Jlc3MudHlwZSk7XG4gICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDoge1xuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCxcbiAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgXCIgK1xuICAgICAgICAgICAgICBcImNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcm9vdENvbnRhaW5lckluc3RhbmNlLFxuICAgICAgICAgICAgICBjdXJyZW50SG9zdENvbnRleHRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGNoYW5nZXMgdG8gdGhlIGh5ZHJhdGVkIG5vZGUgbmVlZHMgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZShcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgIHJvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICByb290Q29udGFpbmVySW5zdGFuY2UsXG4gICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RUZXh0OiB7XG4gICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsLFxuICAgICAgICAgICAgXCJXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBcIiArXG4gICAgICAgICAgICAgIFwiY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICBuZXdUZXh0LFxuICAgICAgICAgICAgX3Jvb3RDb250YWluZXJJbnN0YW5jZSxcbiAgICAgICAgICAgIF9jdXJyZW50SG9zdENvbnRleHQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBGb3J3YXJkUmVmTGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUGxhY2Vob2xkZXJDb21wb25lbnQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIC8vIFBvcCBwcm92aWRlciBmaWJlclxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFB1cmVDb21wb25lbnQ6XG4gICAgY2FzZSBQdXJlQ29tcG9uZW50TGF6eTpcbiAgICAgIGJyZWFrO1xuICAgIC8vIEVycm9yIGNhc2VzXG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgaGF2ZSBiZWNvbWUgZGV0ZXJtaW5hdGUgYmVmb3JlIFwiICtcbiAgICAgICAgICBcImNvbXBsZXRpbmcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIFwiICtcbiAgICAgICAgICBcImZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgZGVmYXVsdDpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgK1xuICAgICAgICAgIFwiUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE1vZHVsZSBwcm92aWRlZCBieSBSTjpcbi8qKlxuICogSW50ZXJjZXB0IGxpZmVjeWNsZSBlcnJvcnMgYW5kIGVuc3VyZSB0aGV5IGFyZSBzaG93biB3aXRoIHRoZSBjb3JyZWN0IHN0YWNrXG4gKiB0cmFjZSB3aXRoaW4gdGhlIG5hdGl2ZSByZWRib3ggY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcikge1xuICB2YXIgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcblxuICB2YXIgZXJyb3JUb0hhbmRsZSA9IHZvaWQgMDtcblxuICAvLyBUeXBpY2FsbHkgRXJyb3JzIGFyZSB0aHJvd24gYnV0IGVnIHN0cmluZ3Mgb3IgbnVsbCBjYW4gYmUgdGhyb3duIGFzIHdlbGwuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlLFxuICAgICAgbmFtZSA9IGVycm9yLm5hbWU7XG5cbiAgICB2YXIgc3VtbWFyeSA9IG1lc3NhZ2UgPyBuYW1lICsgXCI6IFwiICsgbWVzc2FnZSA6IG5hbWU7XG5cbiAgICBlcnJvclRvSGFuZGxlID0gZXJyb3I7XG5cbiAgICB0cnkge1xuICAgICAgZXJyb3JUb0hhbmRsZS5tZXNzYWdlID1cbiAgICAgICAgc3VtbWFyeSArIFwiXFxuXFxuVGhpcyBlcnJvciBpcyBsb2NhdGVkIGF0OlwiICsgY29tcG9uZW50U3RhY2s7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXJyb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlcnJvclRvSGFuZGxlID0gbmV3IEVycm9yKFxuICAgICAgZXJyb3IgKyBcIlxcblxcblRoaXMgZXJyb3IgaXMgbG9jYXRlZCBhdDpcIiArIGNvbXBvbmVudFN0YWNrXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvclRvSGFuZGxlID0gbmV3IEVycm9yKFwiVW5zcGVjaWZpZWQgZXJyb3IgYXQ6XCIgKyBjb21wb25lbnRTdGFjayk7XG4gIH1cblxuICBFeGNlcHRpb25zTWFuYWdlci5oYW5kbGVFeGNlcHRpb24oZXJyb3JUb0hhbmRsZSwgZmFsc2UpO1xuXG4gIC8vIFJldHVybiBmYWxzZSBoZXJlIHRvIHByZXZlbnQgUmVhY3RGaWJlckVycm9yTG9nZ2VyIGRlZmF1bHQgYmVoYXZpb3Igb2ZcbiAgLy8gbG9nZ2luZyBlcnJvciBkZXRhaWxzIHRvIGNvbnNvbGUuZXJyb3IuIENhbGxzIHRvIGNvbnNvbGUuZXJyb3IgYXJlXG4gIC8vIGF1dG9tYXRpY2FsbHkgcm91dGVkIHRvIHRoZSBuYXRpdmUgcmVkYm94IGNvbnRyb2xsZXIsIHdoaWNoIHdlJ3ZlIGFscmVhZHlcbiAgLy8gZG9uZSBhYm92ZSBieSBjYWxsaW5nIEV4Y2VwdGlvbnNNYW5hZ2VyLlxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuICAgIC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiBlcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIHdpbGxSZXRyeSkge1xuICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicm93c2VyIHdvdWxkIGhhdmUgc2lsZW5jZWQgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZVxuICAgICAgPyBcIlRoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQ6XCJcbiAgICAgIDogXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czpcIjtcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPVxuICAgICAgICAgIFwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggXCIgK1xuICAgICAgICAgIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9XG4gICAgICAgICAgXCJUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgXCIgK1xuICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lICtcbiAgICAgICAgICBcIi5cXG5cIiArXG4gICAgICAgICAgXCJSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9XG4gICAgICAgIFwiQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuXCIgK1xuICAgICAgICBcIlZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuXCI7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPVxuICAgICAgXCJcIiArXG4gICAgICBjb21wb25lbnROYW1lTWVzc2FnZSArXG4gICAgICBjb21wb25lbnRTdGFjayArXG4gICAgICBcIlxcblxcblwiICtcbiAgICAgIChcIlwiICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBlbXB0eU9iamVjdCQxID0ge307XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsLFxuICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogXCJcIixcbiAgICBlcnJvcjogZXJyb3JJbmZvLnZhbHVlLFxuICAgIGVycm9yQm91bmRhcnk6IG51bGwsXG4gICAgZXJyb3JCb3VuZGFyeU5hbWU6IG51bGwsXG4gICAgZXJyb3JCb3VuZGFyeUZvdW5kOiBmYWxzZSxcbiAgICB3aWxsUmV0cnk6IGZhbHNlXG4gIH07XG5cbiAgaWYgKGJvdW5kYXJ5ICE9PSBudWxsICYmIGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnkgPSBib3VuZGFyeS5zdGF0ZU5vZGU7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWUoYm91bmRhcnkudHlwZSk7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgIGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5ID0gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uKGN1cnJlbnQkJDEsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50JCQxLCBcImNvbXBvbmVudFdpbGxVbm1vdW50XCIpO1xuICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50JCQxLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG59O1xuXG4vLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQkJDEsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2soXG4gICAgICBudWxsLFxuICAgICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLFxuICAgICAgbnVsbCxcbiAgICAgIGN1cnJlbnQkJDEsXG4gICAgICBpbnN0YW5jZVxuICAgICk7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50JCQxLCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCQkMSkge1xuICB2YXIgcmVmID0gY3VycmVudCQkMS5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50JCQxLCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCQkMSwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6IHtcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCQkMS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50JCQxLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgXCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVwiKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgc25hcHNob3QgPSBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkICYmICFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpIHtcbiAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuICAgICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgXCIlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSBcIiArXG4gICAgICAgICAgICAgICAgICBcIm11c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC5cIixcbiAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIFwiICtcbiAgICAgICAgICBcImxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKFxuICBmaW5pc2hlZFJvb3QsXG4gIGN1cnJlbnQkJDEsXG4gIGZpbmlzaGVkV29yayxcbiAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWVcbikge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OiB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCBcImNvbXBvbmVudERpZE1vdW50XCIpO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssIFwiY29tcG9uZW50RGlkVXBkYXRlXCIpO1xuICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUoXG4gICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICBjb21taXR0ZWRFeHBpcmF0aW9uVGltZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgX3VwZGF0ZVF1ZXVlLFxuICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICBjb21taXR0ZWRFeHBpcmF0aW9uVGltZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6IHtcbiAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDoge1xuICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBQcm9maWxlcjoge1xuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIG9uUmVuZGVyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgICAgICBvblJlbmRlcihcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLFxuICAgICAgICAgICAgY3VycmVudCQkMSA9PT0gbnVsbCA/IFwibW91bnRcIiA6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbixcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsXG4gICAgICAgICAgICBnZXRDb21taXRUaW1lKCksXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uUmVuZGVyKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsXG4gICAgICAgICAgICBjdXJyZW50JCQxID09PSBudWxsID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICAgIGdldENvbW1pdFRpbWUoKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBQbGFjZWhvbGRlckNvbXBvbmVudDoge1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlKSB7XG4gICAgICAgIGlmICgoZmluaXNoZWRXb3JrLm1vZGUgJiBTdHJpY3RNb2RlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAvLyBJbiBsb29zZSBtb2RlLCBhIHBsYWNlaG9sZGVyIHRpbWVzIG91dCBieSBzY2hlZHVsaW5nIGEgc3luY2hyb25vdXNcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIGNvbW1pdCBwaGFzZS4gVXNlIGB1cGRhdGVRdWV1ZWAgZmllbGQgdG8gc2lnbmFsIHRoYXRcbiAgICAgICAgICAvLyB0aGUgVGltZW91dCBuZWVkcyB0byBzd2l0Y2ggdG8gdGhlIHBsYWNlaG9sZGVyLiBXZSBkb24ndCBuZWVkIGFuXG4gICAgICAgICAgLy8gZW50aXJlIHF1ZXVlLiBBbnkgbm9uLW51bGwgdmFsdWUgd29ya3MuXG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIEludGVudGlvbmFsbHkgdXNpbmcgYSB2YWx1ZSBvdGhlciB0aGFuIGFuIFVwZGF0ZVF1ZXVlLlxuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IGVtcHR5T2JqZWN0JDE7XG4gICAgICAgICAgc2NoZWR1bGVXb3JrKGZpbmlzaGVkV29yaywgU3luYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW4gc3RyaWN0IG1vZGUsIHRoZSBVcGRhdGUgZWZmZWN0IGlzIHVzZWQgdG8gcmVjb3JkIHRoZSB0aW1lIGF0XG4gICAgICAgICAgLy8gd2hpY2ggdGhlIHBsYWNlaG9sZGVyIHRpbWVkIG91dC5cbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0geyB0aW1lZE91dEF0OiBjdXJyZW50VGltZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgXCIgK1xuICAgICAgICAgIFwibGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KFwiY3VycmVudFwiKSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiBcIiArXG4gICAgICAgICAgICAgIFwiVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJXNcIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpLFxuICAgICAgICAgICAgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGZpbmlzaGVkV29yaylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQkJDEpIHtcbiAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50JCQxLnJlZjtcbiAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCQkMSkge1xuICBvbkNvbW1pdFVubW91bnQoY3VycmVudCQkMSk7XG5cbiAgc3dpdGNoIChjdXJyZW50JCQxLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6IHtcbiAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQkJDEuc3RhdGVOb2RlO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50JCQxLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQkJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6IHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQkJDEpO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQkJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gIHZhciBub2RlID0gcm9vdDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgaWYgKFxuICAgICAgbm9kZS5jaGlsZCAhPT0gbnVsbCAmJlxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgKCFzdXBwb3J0c011dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKVxuICAgICkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCQkMSkge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICBjdXJyZW50JCQxLnJldHVybiA9IG51bGw7XG4gIGN1cnJlbnQkJDEuY2hpbGQgPSBudWxsO1xuICBpZiAoY3VycmVudCQkMS5hbHRlcm5hdGUpIHtcbiAgICBjdXJyZW50JCQxLmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgY3VycmVudCQkMS5hbHRlcm5hdGUucmV0dXJuID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50JCQxKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50JCQxLnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENvbnRhaW5lcihmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDoge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdFBvcnRhbDoge1xuICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIFwiICtcbiAgICAgICAgICBcImxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBcIiArXG4gICAgICBcImluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICApO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIChcbiAgICBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHxcbiAgICBmaWJlci50YWcgPT09IEhvc3RSb290IHx8XG4gICAgZmliZXIudGFnID09PSBIb3N0UG9ydGFsXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcblxuICAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cbiAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIFwiICtcbiAgICAgICAgICBcImluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgfVxuICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmPSB+Q29udGVudFJlc2V0O1xuICB9XG5cbiAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICB2YXIgbm9kZSA9IGN1cnJlbnQkJDE7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG5cbiAgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG4gIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUucmV0dXJuO1xuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIHBhcmVudCAhPT0gbnVsbCxcbiAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IFwiICtcbiAgICAgICAgICAgIFwiYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG4gICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCB2aXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIGFscmVhZHkgdmlzaXRlZCB0aGVtLlxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgLy8gV2Ugd2lsbCByZWFzc2lnbiBpdCBiYWNrIHdoZW4gd2UgcG9wIHRoZSBwb3J0YWwgb24gdGhlIHdheSB1cC5cbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCQkMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQkJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50JCQxKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQkJDEpO1xuICB9XG4gIGRldGFjaEZpYmVyKGN1cnJlbnQkJDEpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQkJDEsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnRMYXp5OiB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDoge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICB2YXIgb2xkUHJvcHMgPVxuICAgICAgICAgIGN1cnJlbnQkJDEgIT09IG51bGwgPyBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRVcGRhdGUoXG4gICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2xkUHJvcHMsXG4gICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDoge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsLFxuICAgICAgICBcIlRoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IFwiICtcbiAgICAgICAgICBcImNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCQkMSAhPT0gbnVsbCA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FzZSBQcm9maWxlcjoge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXNlIFBsYWNlaG9sZGVyQ29tcG9uZW50OiB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgXCIgK1xuICAgICAgICAgIFwibGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCQkMSkge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50JCQxLnN0YXRlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIE5vb3BDb21wb25lbnQoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cbiAgdXBkYXRlLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6IFwiXCJcbiAgICAgIH0pO1xuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG4gICAgICAgICAgLy8gdGhlbiBpdCBuZWVkcyB0byBjYWxsIHNldFN0YXRlIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMuXG4gICAgICAgICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuICAgICAgICAgICEoZmliZXIuZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpXG4gICAgICAgICAgICA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBcIiVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuIFwiICtcbiAgICAgICAgICAgICAgICAgIFwiSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuXCIsXG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gIHJvb3QsXG4gIHJldHVybkZpYmVyLFxuICBzb3VyY2VGaWJlcixcbiAgdmFsdWUsXG4gIHJlbmRlckV4cGlyYXRpb25UaW1lXG4pIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgLy8gSXRzIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgc291cmNlRmliZXIuZmlyc3RFZmZlY3QgPSBzb3VyY2VGaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBpZiAoXG4gICAgZW5hYmxlU3VzcGVuc2UgJiZcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCJcbiAgKSB7XG4gICAgLy8gVGhpcyBpcyBhIHRoZW5hYmxlLlxuICAgIHZhciB0aGVuYWJsZSA9IHZhbHVlO1xuXG4gICAgLy8gRmluZCB0aGUgZWFybGllc3QgdGltZW91dCB0aHJlc2hvbGQgb2YgYWxsIHRoZSBwbGFjZWhvbGRlcnMgaW4gdGhlXG4gICAgLy8gYW5jZXN0b3IgcGF0aC4gV2UgY291bGQgYXZvaWQgdGhpcyB0cmF2ZXJzYWwgYnkgc3RvcmluZyB0aGUgdGhyZXNob2xkcyBvblxuICAgIC8vIHRoZSBzdGFjaywgYnV0IHdlIGNob29zZSBub3QgdG8gYmVjYXVzZSB3ZSBvbmx5IGhpdCB0aGlzIHBhdGggaWYgd2UncmVcbiAgICAvLyBJTy1ib3VuZCAoaS5lLiBpZiBzb21ldGhpbmcgc3VzcGVuZHMpLiBXaGVyZWFzIHRoZSBzdGFjayBpcyB1c2VkIGV2ZW4gaW5cbiAgICAvLyB0aGUgbm9uLUlPLSBib3VuZCBjYXNlLlxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICB2YXIgZWFybGllc3RUaW1lb3V0TXMgPSAtMTtcbiAgICB2YXIgc3RhcnRUaW1lTXMgPSAtMTtcbiAgICBkbyB7XG4gICAgICBpZiAoX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gUGxhY2Vob2xkZXJDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBfd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFJlYWNoZWQgYSBwbGFjZWhvbGRlciB0aGF0IGFscmVhZHkgdGltZWQgb3V0LiBFYWNoIHRpbWVkIG91dFxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGFjdHMgYXMgdGhlIHJvb3Qgb2YgYSBuZXcgc3VzcGVuc2UgYm91bmRhcnkuXG5cbiAgICAgICAgICAvLyBVc2UgdGhlIHRpbWUgYXQgd2hpY2ggdGhlIHBsYWNlaG9sZGVyIHRpbWVkIG91dCBhcyB0aGUgc3RhcnQgdGltZVxuICAgICAgICAgIC8vIGZvciB0aGUgY3VycmVudCByZW5kZXIuXG4gICAgICAgICAgdmFyIHRpbWVkT3V0QXQgPSBjdXJyZW50LnN0YXRlTm9kZS50aW1lZE91dEF0O1xuICAgICAgICAgIHN0YXJ0VGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKHRpbWVkT3V0QXQpO1xuXG4gICAgICAgICAgLy8gRG8gbm90IHNlYXJjaCBhbnkgZnVydGhlci5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZW91dFByb3BNcyA9IF93b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuZGVsYXlNcztcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0UHJvcE1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHRpbWVvdXRQcm9wTXMgPD0gMCkge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBlYXJsaWVzdFRpbWVvdXRNcyA9PT0gLTEgfHxcbiAgICAgICAgICAgIHRpbWVvdXRQcm9wTXMgPCBlYXJsaWVzdFRpbWVvdXRNc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgZWFybGllc3RUaW1lb3V0TXMgPSB0aW1lb3V0UHJvcE1zO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuXG4gICAgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgUGxhY2Vob2xkZXIgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cbiAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBpZiAoX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gUGxhY2Vob2xkZXJDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGRpZFRpbWVvdXQgPSBfd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKCFkaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG5cbiAgICAgICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgbm90IGluIGNvbmN1cnJlbnQgbW9kZSwgd2Ugc2hvdWxkIG5vdCBzdXNwZW5kLCBhbmRcbiAgICAgICAgICAvLyBsaWtld2lzZSwgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgd2Ugc2hvdWxkIHBpbmcgc3luY2hyb25vdXNseS5cbiAgICAgICAgICB2YXIgcGluZ1RpbWUgPVxuICAgICAgICAgICAgKF93b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb0VmZmVjdFxuICAgICAgICAgICAgICA/IFN5bmNcbiAgICAgICAgICAgICAgOiByZW5kZXJFeHBpcmF0aW9uVGltZTtcblxuICAgICAgICAgIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlIHRvIFwicGluZ1wiIHRoZSByb290IGFuZCByZXRyeS5cbiAgICAgICAgICB2YXIgb25SZXNvbHZlT3JSZWplY3QgPSByZXRyeVN1c3BlbmRlZFJvb3QuYmluZChcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgX3dvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcGluZ1RpbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICAgICAgICBvblJlc29sdmVPclJlamVjdCA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChvblJlc29sdmVPclJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4ob25SZXNvbHZlT3JSZWplY3QsIG9uUmVzb2x2ZU9yUmVqZWN0KTtcblxuICAgICAgICAgIC8vIElmIHRoZSBib3VuZGFyeSBpcyBvdXRzaWRlIG9mIHN0cmljdCBtb2RlLCB3ZSBzaG91bGQgKm5vdCogc3VzcGVuZFxuICAgICAgICAgIC8vIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWQgbnVsbCBhbmRcbiAgICAgICAgICAvLyBrZWVwIHJlbmRlcmluZy4gSW4gdGhlIGNvbW1pdCBwaGFzZSwgd2UnbGwgc2NoZWR1bGUgYSBzdWJzZXF1ZW50XG4gICAgICAgICAgLy8gc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgUGxhY2Vob2xkZXIuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBOb3RlOiBJdCBkb2Vzbid0IG1hdHRlciB3aGV0aGVyIHRoZSBjb21wb25lbnQgdGhhdCBzdXNwZW5kZWQgd2FzXG4gICAgICAgICAgLy8gaW5zaWRlIGEgc3RyaWN0IG1vZGUgdHJlZS4gSWYgdGhlIFBsYWNlaG9sZGVyIGlzIG91dHNpZGUgb2YgaXQsIHdlXG4gICAgICAgICAgLy8gc2hvdWxkICpub3QqIHN1c3BlbmQgdGhlIGNvbW1pdC5cbiAgICAgICAgICBpZiAoKF93b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcblxuICAgICAgICAgICAgLy8gVW5tb3VudCB0aGUgc291cmNlIGZpYmVyJ3MgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICAgIG5leHRDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzb3VyY2VGaWJlci5lZmZlY3RUYWcgJj0gfkluY29tcGxldGU7XG4gICAgICAgICAgICBpZiAoc291cmNlRmliZXIudGFnID09PSBJbmRldGVybWluYXRlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIC8vIExldCdzIGp1c3QgYXNzdW1lIGl0J3MgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgZmliZXIgd2lsbFxuICAgICAgICAgICAgICAvLyBiZSB1bm1vdW50ZWQgaW4gdGhlIGltbWVkaWF0ZSBuZXh0IGNvbW1pdCwgYW55d2F5LlxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0XG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlLiBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yXG4gICAgICAgICAgICAgIC8vIGNhbGxiYWNrcy4gUmVtb3ZlIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+TGlmZWN5Y2xlRWZmZWN0TWFzaztcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGFib3V0IHRvIG1vdW50IGEgY2xhc3MgY29tcG9uZW50IHRoYXQgZG9lc24ndCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2UuIFR1cm4gdGhpcyBpbnRvIGEgZHVtbXkgZnVuY3Rpb24gY29tcG9uZW50IGluc3RlYWQsXG4gICAgICAgICAgICAgICAgLy8gdG8gcHJldmVudCB0eXBlIGVycm9ycy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgaXQncyBhbiBlZGdlXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBhbmQgd2UncmUgYWJvdXQgdG8gc3luY2hyb25vdXNseSBkZWxldGUgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCwgYW55d2F5LlxuICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnR5cGUgPSBOb29wQ29tcG9uZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4aXQgd2l0aG91dCBzdXNwZW5kaW5nLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENvbmZpcm1lZCB0aGF0IHRoZSBib3VuZGFyeSBpcyBpbiBhIHN0cmljdCBtb2RlIHRyZWUuIENvbnRpbnVlIHdpdGhcbiAgICAgICAgICAvLyB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cblxuICAgICAgICAgIHZhciBhYnNvbHV0ZVRpbWVvdXRNcyA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJZiBubyBleHBsaWNpdCB0aHJlc2hvbGQgaXMgZ2l2ZW4sIGRlZmF1bHQgdG8gYW4gYWJpdHJhcmlseSBsYXJnZVxuICAgICAgICAgICAgLy8gdmFsdWUuIFRoZSBhY3R1YWwgc2l6ZSBkb2Vzbid0IG1hdHRlciBiZWNhdXNlIHRoZSB0aHJlc2hvbGQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gd2hvbGUgdHJlZSB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgICAgIGFic29sdXRlVGltZW91dE1zID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWVNcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBzdXNwZW5kIGhhcHBlbmVkIG91dHNpZGUgb2YgYW55IGFscmVhZHkgdGltZWQtb3V0XG4gICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVycy4gV2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoZW4gdGhlIHVwZGF0ZSB3YXMgc2NoZWR1bGVkLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgY2FuIGluZmVyIGFuIGFwcHJveGltYXRlIHN0YXJ0IHRpbWUgZnJvbSB0aGUgZXhwaXJhdGlvblxuICAgICAgICAgICAgICAvLyB0aW1lLiBGaXJzdCwgZmluZCB0aGUgZWFybGllc3QgdW5jb21taXR0ZWQgZXhwaXJhdGlvbiB0aW1lIGluIHRoZVxuICAgICAgICAgICAgICAvLyB0cmVlLCBpbmNsdWRpbmcgd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlbiBzdWJ0cmFjdCB0aGUgb2Zmc2V0XG4gICAgICAgICAgICAgIC8vIHVzZWQgdG8gY29tcHV0ZSBhbiBhc3luYyB1cGRhdGUncyBleHBpcmF0aW9uIHRpbWUuIFRoaXMgd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAvLyBoaWdoIHByaW9yaXR5IChpbnRlcmFjdGl2ZSkgd29yayB0byBleHBpcmUgZWFybGllciB0aGFuIG5lY2Vzc2FyeSxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGNhbiBhY2NvdW50IGZvciB0aGlzIGJ5IGFkanVzdGluZyBmb3IgdGhlIEp1c3QgTm90aWNlYWJsZVxuICAgICAgICAgICAgICAvLyBEaWZmZXJlbmNlLlxuICAgICAgICAgICAgICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IGZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbChcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoXG4gICAgICAgICAgICAgICAgZWFybGllc3RFeHBpcmF0aW9uVGltZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBzdGFydFRpbWVNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyAtIExPV19QUklPUklUWV9FWFBJUkFUSU9OO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWJzb2x1dGVUaW1lb3V0TXMgPSBzdGFydFRpbWVNcyArIGVhcmxpZXN0VGltZW91dE1zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE1hcmsgdGhlIGVhcmxpZXN0IHRpbWVvdXQgaW4gdGhlIHN1c3BlbmRlZCBmaWJlcidzIGFuY2VzdG9yIHBhdGguXG4gICAgICAgICAgLy8gQWZ0ZXIgY29tcGxldGluZyB0aGUgcm9vdCwgd2UnbGwgdGFrZSB0aGUgbGFyZ2VzdCBvZiBhbGwgdGhlXG4gICAgICAgICAgLy8gc3VzcGVuZGVkIGZpYmVyJ3MgdGltZW91dHMgYW5kIHVzZSBpdCB0byBjb21wdXRlIGEgdGltZW91dCBmb3IgdGhlXG4gICAgICAgICAgLy8gd2hvbGUgdHJlZS5cbiAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKHJvb3QsIGFic29sdXRlVGltZW91dE1zLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgX3dvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZVxuICAgICAgICAvLyBuZXh0IGJvdW5kYXJ5LlxuICAgICAgfVxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuICAgIC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcihcbiAgICAgIFwiQW4gdXBkYXRlIHdhcyBzdXNwZW5kZWQsIGJ1dCBubyBwbGFjZWhvbGRlciBVSSB3YXMgcHJvdmlkZWQuXCJcbiAgICApO1xuICB9XG5cbiAgLy8gV2UgZGlkbid0IGZpbmQgYSBib3VuZGFyeSB0aGF0IGNvdWxkIGhhbmRsZSB0aGlzIHR5cGUgb2YgZXhjZXB0aW9uLiBTdGFydFxuICAvLyBvdmVyIGFuZCB0cmF2ZXJzZSBwYXJlbnQgcGF0aCBhZ2FpbiwgdGhpcyB0aW1lIHRyZWF0aW5nIHRoZSBleGNlcHRpb25cbiAgLy8gYXMgYW4gZXJyb3IuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIF9lcnJvckluZm8sXG4gICAgICAgICAgcmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgKTtcbiAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCB1cGRhdGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBlcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0ICYmXG4gICAgICAgICAgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgICAgICAgICAoaW5zdGFuY2UgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIGVycm9ySW5mbyxcbiAgICAgICAgICAgIHJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgfSB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xufVxuXG5mdW5jdGlvbiB1bndpbmRXb3JrKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gKGVmZmVjdFRhZyAmIH5TaG91bGRDYXB0dXJlKSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50TGF6eToge1xuICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9yZWFjdFJlc3VsdDtcbiAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBfZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgaWYgKF9lZmZlY3RUYWcgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IChfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUpIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBfZWZmZWN0VGFnMiA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgKF9lZmZlY3RUYWcyICYgRGlkQ2FwdHVyZSkgPT09IE5vRWZmZWN0LFxuICAgICAgICBcIlRoZSByb290IGZhaWxlZCB0byB1bm1vdW50IGFmdGVyIGFuIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBcIiArXG4gICAgICAgICAgXCJSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSAoX2VmZmVjdFRhZzIgJiB+U2hvdWxkQ2FwdHVyZSkgfCBEaWRDYXB0dXJlO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXNlIFBsYWNlaG9sZGVyQ29tcG9uZW50OiB7XG4gICAgICB2YXIgX2VmZmVjdFRhZzMgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICBpZiAoX2VmZmVjdFRhZzMgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IChfZWZmZWN0VGFnMyAmIH5TaG91bGRDYXB0dXJlKSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspIHtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDoge1xuICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6IHtcbiAgICAgIHZhciBfY2hpbGRDb250ZXh0VHlwZXMgPVxuICAgICAgICBpbnRlcnJ1cHRlZFdvcmsudHlwZS5fcmVhY3RSZXN1bHQuY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgICBpZiAoX2NoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIF9jaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6IHtcbiAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHRcbn07XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB2b2lkIDA7XG52YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gdm9pZCAwO1xudmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gdm9pZCAwO1xuXG5pZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLiByZWFjdC1kb21cbiAgLy8gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZiBzY2hlZHVsZS90cmFjaW5nXG4gIGludmFyaWFudChcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmICE9IG51bGwgJiZcbiAgICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCAhPSBudWxsLFxuICAgIFwiSXQgaXMgbm90IHN1cHBvcnRlZCB0byBydW4gdGhlIHByb2ZpbGluZyB2ZXJzaW9uIG9mIGEgcmVuZGVyZXIgKGZvciBleGFtcGxlLCBgcmVhY3QtZG9tL3Byb2ZpbGluZ2ApIFwiICtcbiAgICAgIFwid2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlL3RyYWNpbmdgIG1vZHVsZSB3aXRoIGBzY2hlZHVsZS90cmFjaW5nLXByb2ZpbGluZ2AuIFwiICtcbiAgICAgIFwiWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIFwiICtcbiAgICAgIFwiTGVhcm4gbW9yZSBhdCBodHRwOi8vZmIubWUvcmVhY3QtcHJvZmlsaW5nXCJcbiAgKTtcbn1cblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8IFwiUmVhY3RDbGFzc1wiO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgZmFsc2UsXG4gICAgICBcIkNhbid0IGNhbGwgc2V0U3RhdGUgKG9yIGZvcmNlVXBkYXRlKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIFwiICtcbiAgICAgICAgXCJpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gXCIgK1xuICAgICAgICBcImZpeCwgY2FuY2VsIGFsbCBzdWJzY3JpcHRpb25zIGFuZCBhc3luY2hyb25vdXMgdGFza3MgaW4gdGhlIFwiICtcbiAgICAgICAgXCJjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QuJXNcIixcbiAgICAgIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlcilcbiAgICApO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAocGhhc2UpIHtcbiAgICAgIGNhc2UgXCJnZXRDaGlsZENvbnRleHRcIjpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKVwiXG4gICAgICAgICk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlbmRlclwiOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluIFwiICtcbiAgICAgICAgICAgIFwiYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS5cIlxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG59XG5cbi8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbi8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbi8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbnZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxudmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4vLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG52YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xudmFyIG5leHRSb290ID0gbnVsbDtcbi8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbnZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG52YXIgbmV4dFJlbmRlckRpZEVycm9yID0gZmFsc2U7XG5cbi8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG52YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbnZhciBpc0NvbW1pdHRpbmckMSA9IGZhbHNlO1xuXG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuXG4vLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbnZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxudmFyIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSB2b2lkIDA7XG52YXIgcmVwbGF5VW5pdE9mV29yayA9IHZvaWQgMDtcbnZhciBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHZvaWQgMDtcbnZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbmlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBudWxsO1xuICBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gIHJlcGxheVVuaXRPZldvcmsgPSBmdW5jdGlvbihmYWlsZWRVbml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgaXNZaWVsZHkpIHtcbiAgICBpZiAoXG4gICAgICB0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHRocm93blZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICB0eXBlb2YgdGhyb3duVmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHN0cmF0ZWd5IGlmL3doZW4gd2UgYWRkXG4gICAgICAvLyBzdXBwb3J0IGZvciBjYXRjaGluZyBvdGhlciB0eXBlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIGlmIChzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIERvbid0IHRocm93IGJlY2F1c2UgdGhpcyBjb2RlIGlzIERFVi1vbmx5LlxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJDb3VsZCBub3QgcmVwbGF5IHJlbmRlcmluZyBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFwiICtcbiAgICAgICAgICBcIlBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihcbiAgICAgIGZhaWxlZFVuaXRPZldvcmssXG4gICAgICBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHN3aXRjaCAoZmFpbGVkVW5pdE9mV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6IHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IGZhaWxlZFVuaXRPZldvcmsudHlwZTtcbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6IHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShmYWlsZWRVbml0T2ZXb3JrLnR5cGUpO1xuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gdGhyb3duVmFsdWU7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc1lpZWxkeSk7XG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmIChyZXBsYXlFcnJvciAhPSBudWxsICYmIHRocm93blZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBSZWFkaW5nIHRoZSBleHBhbmRvIHByb3BlcnR5IGlzIGludGVudGlvbmFsbHlcbiAgICAgICAgICAvLyBpbnNpZGUgYHRyeWAgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGdldHRlciBvciBQcm94eS5cbiAgICAgICAgICBpZiAocmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgICAgLy8gQWxzbyBzdXBwcmVzcyBsb2dnaW5nIGZvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICB0aHJvd25WYWx1ZS5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAvLyBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gZmFpbGVkVW5pdE9mV29yaztcbiAgICB9XG4gIH07XG4gIHJldGhyb3dPcmlnaW5hbEVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgb3JpZ2luYWxSZXBsYXlFcnJvcjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdGFjaygpIHtcbiAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IG5leHRVbml0T2ZXb3JrLnJldHVybjtcbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MoKTtcbiAgICBjaGVja1RoYXRTdGFja0lzRW1wdHkoKTtcbiAgfVxuXG4gIG5leHRSb290ID0gbnVsbDtcbiAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPSAtMTtcbiAgbmV4dFJlbmRlckRpZEVycm9yID0gZmFsc2U7XG4gIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIH1cbiAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgIGlmIChlZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgdmFyIGN1cnJlbnQkJDEgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50JCQxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbik7XG4gICAgc3dpdGNoIChwcmltYXJ5RWZmZWN0VGFnKSB7XG4gICAgICBjYXNlIFBsYWNlbWVudDoge1xuICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZToge1xuICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBVcGRhdGU6IHtcbiAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBEZWxldGlvbjoge1xuICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVjeWNsZXMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcbiAgICBpZiAoZWZmZWN0VGFnICYgU25hcHNob3QpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQkJDEgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50JCQxLCBuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICAvLyBEb24ndCBjbGVhbnVwIGVmZmVjdHMgeWV0O1xuICAgIC8vIFRoaXMgd2lsbCBiZSBkb25lIGJ5IGNvbW1pdEFsbExpZmVDeWNsZXMoKVxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgdmFyIGN1cnJlbnQkJDEgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgbmV4dEVmZmVjdCxcbiAgICAgICAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICBjb21taXRBdHRhY2hSZWYobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgY2xlYW4gdGhlc2UgdXAgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkga2VlcCB0aGVtLlxuICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgIC8vIG9uZXMuIFNvIHdlIGhhdmUgdG8gY2xlYW4gZXZlcnl0aGluZyBhcyB3ZSByZXVzZSBub2RlcyBhbnl3YXkuXG4gICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAvLyB0YWdzIHRvIHJlYXNvbiBhYm91dCB0aGUgY3VycmVudCBsaWZlLWN5Y2xlLlxuICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIChcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSb290KHJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpc1dvcmtpbmcgPSB0cnVlO1xuICBpc0NvbW1pdHRpbmckMSA9IHRydWU7XG4gIHN0YXJ0Q29tbWl0VGltZXIoKTtcblxuICBpbnZhcmlhbnQoXG4gICAgcm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmssXG4gICAgXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIFwiICtcbiAgICAgIFwicmVsYXRlZCB0byB0aGUgcmV0dXJuIGZpZWxkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgXCIgK1xuICAgICAgXCJpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gIGludmFyaWFudChcbiAgICBjb21taXR0ZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrLFxuICAgIFwiQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIFwiICtcbiAgICAgIFwiYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICApO1xuICByb290LnBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgcHJpb3JpdHkgbGV2ZWxzIHRvIGFjY291bnQgZm9yIHRoZSB3b3JrIHRoYXQgd2UgYXJlXG4gIC8vIGFib3V0IHRvIGNvbW1pdC4gVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIGNhbGxpbmcgdGhlIGxpZmVjeWNsZXMsIHNpbmNlXG4gIC8vIHRoZXkgbWF5IHNjaGVkdWxlIGFkZGl0aW9uYWwgdXBkYXRlcy5cbiAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0ID0gZmluaXNoZWRXb3JrLmV4cGlyYXRpb25UaW1lO1xuICB2YXIgY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICB2YXIgZWFybGllc3RSZW1haW5pbmdUaW1lQmVmb3JlQ29tbWl0ID1cbiAgICB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9PT0gTm9Xb3JrIHx8XG4gICAgKGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgIT09IE5vV29yayAmJlxuICAgICAgY2hpbGRFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA8IHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0KVxuICAgICAgPyBjaGlsZEV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0XG4gICAgICA6IHVwZGF0ZUV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0O1xuICBtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMocm9vdCwgZWFybGllc3RSZW1haW5pbmdUaW1lQmVmb3JlQ29tbWl0KTtcblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IG51bGw7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgLy8gUmVzdG9yZSBhbnkgcGVuZGluZyBpbnRlcmFjdGlvbnMgYXQgdGhpcyBwb2ludCxcbiAgICAvLyBTbyB0aGF0IGNhc2NhZGluZyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFjY291bnRlZCBmb3IuXG4gICAgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcblxuICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gSW52b2tlIGluc3RhbmNlcyBvZiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBiZWZvcmUgbXV0YXRpb24uXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpO1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlY3ljbGVzLCBudWxsKTtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBuZXh0RWZmZWN0ICE9PSBudWxsLFxuICAgICAgICBcIlNob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgXCIgK1xuICAgICAgICAgIFwiaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgZXJyb3IpO1xuICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lcigpO1xuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gTWFyayB0aGUgY3VycmVudCBjb21taXQgdGltZSB0byBiZSBzaGFyZWQgYnkgYWxsIFByb2ZpbGVycyBpbiB0aGlzIGJhdGNoLlxuICAgIC8vIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICB9XG5cbiAgLy8gQ29tbWl0IGFsbCB0aGUgc2lkZS1lZmZlY3RzIHdpdGhpbiBhIHRyZWUuIFdlJ2xsIGRvIHRoaXMgaW4gdHdvIHBhc3Nlcy5cbiAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgLy8gcmVmIHVubW91bnRzLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbmV4dEVmZmVjdCAhPT0gbnVsbCxcbiAgICAgICAgXCJTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIFwiICtcbiAgICAgICAgICBcImluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAvLyBDbGVhbi11cFxuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG5cbiAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yMiA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29tbWl0QWxsTGlmZUN5Y2xlcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgY29tbWl0dGVkRXhwaXJhdGlvblRpbWVcbiAgICAgICk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBfZGlkRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9kaWRFcnJvcjIpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbmV4dEVmZmVjdCAhPT0gbnVsbCxcbiAgICAgICAgXCJTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIFwiICtcbiAgICAgICAgICBcImluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0NvbW1pdHRpbmckMSA9IGZhbHNlO1xuICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID0gZmluaXNoZWRXb3JrLmV4cGlyYXRpb25UaW1lO1xuICB2YXIgY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID0gZmluaXNoZWRXb3JrLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gIHZhciBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9XG4gICAgdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA9PT0gTm9Xb3JrIHx8XG4gICAgKGNoaWxkRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCAhPT0gTm9Xb3JrICYmXG4gICAgICBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPCB1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0KVxuICAgICAgPyBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXRcbiAgICAgIDogdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdDtcbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0ID09PSBOb1dvcmspIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG4gIG9uQ29tbWl0KHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0KTtcblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICB2YXIgc3Vic2NyaWJlciA9IHZvaWQgMDtcblxuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKFxuICAgICAgICAgIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgIHJvb3QuaW50ZXJhY3Rpb25UaHJlYWRJRFxuICAgICAgICApO1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJdCdzIG5vdCBzYWZlIGZvciBjb21taXRSb290KCkgdG8gdGhyb3cuXG4gICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAgIC8vIFVubGVzcyB0aGUgcmVuZGVyIHdhcyBzdXNwZW5kZWQgb3IgY2FzY2FkaW5nIHdvcmsgd2FzIHNjaGVkdWxlZCxcbiAgICAgIC8vIEluIHdoaWNoIGNhc2XigJMgbGVhdmUgcGVuZGluZyBpbnRlcmFjdGlvbnMgdW50aWwgdGhlIHN1YnNlcXVlbnQgcmVuZGVyLlxuICAgICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24oXG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucyxcbiAgICAgICAgc2NoZWR1bGVkRXhwaXJhdGlvblRpbWVcbiAgICAgICkge1xuICAgICAgICAvLyBPbmx5IGRlY3JlbWVudCB0aGUgcGVuZGluZyBpbnRlcmFjdGlvbiBjb3VudCBpZiB3ZSdyZSBkb25lLlxuICAgICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHdvcmsgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHksXG4gICAgICAgIC8vIFRoYXQgaW5kaWNhdGVzIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIHN1c3BlbnNlIGRhdGEuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9PT0gTm9Xb3JrIHx8XG4gICAgICAgICAgc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUgPCBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdFxuICAgICAgICApIHtcbiAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuZGVsZXRlKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBzYWZlIGZvciBjb21taXRSb290KCkgdG8gdGhyb3cuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciBub3cgYW5kIHdlJ2xsIHJlLXRocm93IGluIGZpbmlzaFJlbmRlcmluZygpLlxuICAgICAgICAgICAgICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENoaWxkRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgIC8vIGV4cGlyYXRpb24gdGltZXMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgIC8vIFdlJ3JlIGluIHByb2ZpbGluZyBtb2RlLlxuICAgIC8vIExldCdzIHVzZSB0aGlzIHNhbWUgdHJhdmVyc2FsIHRvIHVwZGF0ZSB0aGUgcmVuZGVyIGR1cmF0aW9ucy5cbiAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbjtcbiAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb247XG5cbiAgICAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC5cbiAgICAvLyBUaGlzIHZhbHVlIHdpbGwgb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAvLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uXG4gICAgLy8gSWYgdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSxcbiAgICAvLyBUaGVuIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXMgcmVuZGVyLlxuICAgIC8vIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS5cbiAgICAvLyBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXMgY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cbiAgICB2YXIgc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zID1cbiAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCB8fFxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZS5jaGlsZDtcblxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciBjaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKFxuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICAgICAgKGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJlxuICAgICAgICAgIGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPCBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKVxuICAgICAgKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBjaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICAgICAgKGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgICAgICAgY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lIDwgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSlcbiAgICAgICkge1xuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucykge1xuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2NoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKF9jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lID0gX2NoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGQuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgIChfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgICAgICAgX2NoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWUgPCBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKVxuICAgICAgKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgIChfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgICAgICBfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lIDwgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSlcbiAgICAgICkge1xuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBuZXdDaGlsZEV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGVcbiAgLy8gbmV4dCBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZVxuICAvLyBwYXJlbnQgZmliZXIuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQkJDEgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIEluY29tcGxldGUpID09PSBOb0VmZmVjdCkge1xuICAgICAgLy8gVGhpcyBmaWJlciBjb21wbGV0ZWQuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVXb3JrKFxuICAgICAgICAgIGN1cnJlbnQkJDEsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVdvcmsoXG4gICAgICAgICAgY3VycmVudCQkMSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAge1xuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHJldHVybkZpYmVyICE9PSBudWxsICYmXG4gICAgICAgIC8vIERvIG5vdCBhcHBlbmQgZWZmZWN0cyB0byBwYXJlbnRzIGlmIGEgc2libGluZyBmYWlsZWQgdG8gY29tcGxldGVcbiAgICAgICAgKHJldHVybkZpYmVyLmVmZmVjdFRhZyAmIEluY29tcGxldGUpID09PSBOb0VmZmVjdFxuICAgICAgKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgRGlkQ2FwdHVyZSkge1xuICAgICAgICAvLyBSZXN0YXJ0aW5nIGFuIGVycm9yIGJvdW5kYXJ5XG4gICAgICAgIHN0b3BGYWlsZWRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICBpZiAobmV4dC5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IG5leHQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBuZXh0LmNoaWxkO1xuICAgICAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgbmV4dC5lZmZlY3RUYWcgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBlZmZlY3QgbGlzdC5cbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuRmliZXIuZWZmZWN0VGFnIHw9IEluY29tcGxldGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgLy8gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50JCQxID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAge1xuICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihcbiAgICAgIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICk7XG4gIH1cblxuICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICBzdGFydFByb2ZpbGVyVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBhc3N1bWluZyB3ZSBkaWRuJ3QgYmFpbG91dCAob3IgZXJyb3IpLlxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBpZiAoaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAvLyBiZWNhdXNlIHRoZSByZW5kZXIgcGhhc2UgaXMgbWVhbnQgdG8gYmUgaWRlbXBvdGVudCwgYW5kIGl0IHNob3VsZFxuICAgICAgLy8gaGF2ZSB0aHJvd24gYWdhaW4uIFNpbmNlIGl0IGRpZG4ndCwgcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIHNvXG4gICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgcmV0aHJvd09yaWdpbmFsRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChpc1lpZWxkeSkge1xuICBpZiAoIWlzWWllbGR5KSB7XG4gICAgLy8gRmx1c2ggd29yayB3aXRob3V0IHlpZWxkaW5nXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBpc1lpZWxkeSwgaXNFeHBpcmVkKSB7XG4gIGludmFyaWFudChcbiAgICAhaXNXb3JraW5nLFxuICAgIFwicmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgXCIgK1xuICAgICAgXCJieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcbiAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50RGlzcGF0Y2hlciA9IERpc3BhdGNoZXI7XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcblxuICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gIGlmIChcbiAgICBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8XG4gICAgcm9vdCAhPT0gbmV4dFJvb3QgfHxcbiAgICBuZXh0VW5pdE9mV29yayA9PT0gbnVsbFxuICApIHtcbiAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICByZXNldFN0YWNrKCk7XG4gICAgbmV4dFJvb3QgPSByb290O1xuICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoXG4gICAgICBuZXh0Um9vdC5jdXJyZW50LFxuICAgICAgbnVsbCxcbiAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZVxuICAgICk7XG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGludGVyYWN0aW9ucyB0aGlzIGJhdGNoIG9mIHdvcmsgY3VycmVudGx5IGluY2x1ZGVzLFxuICAgICAgLy8gU28gdGhhdCB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LFxuICAgICAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgIHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24oXG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucyxcbiAgICAgICAgc2NoZWR1bGVkRXhwaXJhdGlvblRpbWVcbiAgICAgICkge1xuICAgICAgICBpZiAoc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBzY2hlZHVsZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RvcmUgdGhlIGN1cnJlbnQgc2V0IG9mIGludGVyYWN0aW9ucyBvbiB0aGUgRmliZXJSb290IGZvciBhIGZldyByZWFzb25zOlxuICAgICAgLy8gV2UgY2FuIHJlLXVzZSBpdCBpbiBob3QgZnVuY3Rpb25zIGxpa2UgcmVuZGVyUm9vdCgpIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgICAgLy8gV2Ugd2lsbCBhbHNvIHVzZSBpdCBpbiBjb21taXRXb3JrKCkgdG8gcGFzcyB0byBhbnkgUHJvZmlsZXIgb25SZW5kZXIoKSBob29rcy5cbiAgICAgIC8vIFRoaXMgYWxzbyBwcm92aWRlcyBEZXZUb29scyB3aXRoIGEgd2F5IHRvIGFjY2VzcyBpdCB3aGVuIHRoZSBvbkNvbW1pdFJvb3QoKSBob29rIGlzIGNhbGxlZC5cbiAgICAgIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbnM7XG5cbiAgICAgIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBXb3JrIHRocm93biBieSBhbiBpbnRlcmFjdGlvbiB0cmFjaW5nIHN1YnNjcmliZXIgc2hvdWxkIGJlIHJldGhyb3duLFxuICAgICAgICAgICAgLy8gQnV0IG9ubHkgb25jZSBpdCdzIHNhZmUgKHRvIGF2b2lkIGxlYXZlaW5nIHRoZSBzY2hlZHVsZXIgaW4gYW4gaW52YWxpZCBzdGF0ZSkuXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgZXJyb3IgZm9yIG5vdyBhbmQgd2UnbGwgcmUtdGhyb3cgaW4gZmluaXNoUmVuZGVyaW5nKCkuXG4gICAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IG51bGw7XG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgLy8gV2UncmUgYWJvdXQgdG8gc3RhcnQgbmV3IHRyYWNlZCB3b3JrLlxuICAgIC8vIFJlc3RvcmUgcGVuZGluZyBpbnRlcmFjdGlvbnMgc28gY2FzY2FkaW5nIHdvcmsgdHJpZ2dlcmVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHdpbGwgYmUgYWNjb3VudGVkIGZvci5cbiAgICBwcmV2SW50ZXJhY3Rpb25zID0gdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnM7XG4gIH1cblxuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3AoaXNZaWVsZHkpO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBpZiAobmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGZhdGFsIGVycm9yLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gUmVzZXQgZ2xvYmFsIGRlYnVnIHN0YXRlXG4gICAgICAgICAgLy8gV2UgYXNzdW1lIHRoaXMgaXMgZGVmaW5lZCBpbiBERVZcbiAgICAgICAgICByZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhaWxlZFVuaXRPZldvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgaWYgKHRydWUgJiYgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXBsYXlVbml0T2ZXb3JrKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB3ZSBhbHJlYWR5IGtub3cgdGhpcyBpc24ndCB0cnVlIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIC8vIEF0IGxlYXN0IHRoaXMgc2hvd3MgYSBuaWNlciBlcnJvciBtZXNzYWdlIHVudGlsIHdlIGZpZ3VyZSBvdXQgdGhlIGNhdXNlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNDQ5I2lzc3VlY29tbWVudC0zODY3Mjc0MzFcbiAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgIG5leHRVbml0T2ZXb3JrICE9PSBudWxsLFxuICAgICAgICAgIFwiRmFpbGVkIHRvIHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgXCIgK1xuICAgICAgICAgICAgXCJpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBcIiArXG4gICAgICAgICAgICBcIndpdGggYSByZXByb2R1Y2luZyBjYXNlIHRvIGhlbHAgdXMgZmluZCBpdC5cIlxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBzb3VyY2VGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3QuIFRoZSByb290IGNvdWxkIGNhcHR1cmUgaXRzIG93biBlcnJvcnMuIEhvd2V2ZXIsXG4gICAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCBlcnJvcnMgYmVmb3JlIG9yIGFmdGVyIHdlIHB1c2hlZCB0aGUgaG9zdFxuICAgICAgICAgIC8vIGNvbnRleHQuIFRoaXMgaW5mb3JtYXRpb24gaXMgbmVlZGVkIHRvIGF2b2lkIGEgc3RhY2sgbWlzbWF0Y2guXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBub3Qgc3VyZSwgdHJlYXQgdGhpcyBhcyBhIGZhdGFsIGVycm9yLiBXZSBjb3VsZCB0cmFja1xuICAgICAgICAgIC8vIHdoaWNoIHBoYXNlIGl0IGZhaWxzIGluLCBidXQgZG9lc24ndCBzZWVtIHdvcnRoIGl0LiBBdCBsZWFzdFxuICAgICAgICAgIC8vIGZvciBub3cuXG4gICAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcih0aHJvd25WYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dFeGNlcHRpb24oXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBzb3VyY2VGaWJlcixcbiAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlVW5pdE9mV29yayhzb3VyY2VGaWJlcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgLy8gVHJhY2VkIHdvcmsgaXMgZG9uZSBmb3Igbm93OyByZXN0b3JlIHRoZSBwcmV2aW91cyBpbnRlcmFjdGlvbnMuXG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxuXG4gIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50RGlzcGF0Y2hlciA9IG51bGw7XG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2VzKCk7XG5cbiAgLy8gWWllbGQgYmFjayB0byBtYWluIHRocmVhZC5cbiAgaWYgKGRpZEZhdGFsKSB7XG4gICAgdmFyIF9kaWRDb21wbGV0ZVJvb3QgPSBmYWxzZTtcbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBfZGlkQ29tcGxldGVSb290KTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICAvLyBUaGVyZSB3YXMgYSBmYXRhbCBlcnJvci5cbiAgICB7XG4gICAgICByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKTtcbiAgICB9XG4gICAgLy8gYG5leHRSb290YCBwb2ludHMgdG8gdGhlIGluLXByb2dyZXNzIHJvb3QuIEEgbm9uLW51bGwgdmFsdWUgaW5kaWNhdGVzXG4gICAgLy8gdGhhdCB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGFuIGFzeW5jIHJlbmRlci4gU2V0IGl0IHRvIG51bGwgdG8gaW5kaWNhdGVcbiAgICAvLyB0aGVyZSdzIG5vIG1vcmUgd29yayB0byBiZSBkb25lIGluIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgIG5leHRSb290ID0gbnVsbDtcbiAgICBvbkZhdGFsKHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgc3RpbGwgcmVtYWluaW5nIGFzeW5jIHdvcmsgaW4gdGhpcyB0cmVlLCBidXQgd2UgcmFuIG91dCBvZiB0aW1lXG4gICAgLy8gaW4gdGhlIGN1cnJlbnQgZnJhbWUuIFlpZWxkIGJhY2sgdG8gdGhlIHJlbmRlcmVyLiBVbmxlc3Mgd2UncmVcbiAgICAvLyBpbnRlcnJ1cHRlZCBieSBhIGhpZ2hlciBwcmlvcml0eSB1cGRhdGUsIHdlJ2xsIGNvbnRpbnVlIGxhdGVyIGZyb20gd2hlcmVcbiAgICAvLyB3ZSBsZWZ0IG9mZi5cbiAgICB2YXIgX2RpZENvbXBsZXRlUm9vdDIgPSBmYWxzZTtcbiAgICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBfZGlkQ29tcGxldGVSb290Mik7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgb25ZaWVsZChyb290KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBXZSBjb21wbGV0ZWQgdGhlIHdob2xlIHRyZWUuXG4gIHZhciBkaWRDb21wbGV0ZVJvb3QgPSB0cnVlO1xuICBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpO1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgaW52YXJpYW50KFxuICAgIHJvb3RXb3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCxcbiAgICBcIkZpbmlzaGVkIHJvb3Qgc2hvdWxkIGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBcIiArXG4gICAgICBcImNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcblxuICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGFuIGFzeW5jIHJlbmRlci4gU2V0IGl0IHRvIG51bGwgdG8gaW5kaWNhdGVcbiAgLy8gdGhlcmUncyBubyBtb3JlIHdvcmsgdG8gYmUgZG9uZSBpbiB0aGUgY3VycmVudCBiYXRjaC5cbiAgbmV4dFJvb3QgPSBudWxsO1xuICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBpZiAobmV4dFJlbmRlckRpZEVycm9yKSB7XG4gICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yXG4gICAgaWYgKGhhc0xvd2VyUHJpb3JpdHlXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgLy8gVGhlcmUncyBsb3dlciBwcmlvcml0eSB3b3JrLiBJZiBzbywgaXQgbWF5IGhhdmUgdGhlIGVmZmVjdCBvZiBmaXhpbmdcbiAgICAgIC8vIHRoZSBleGNlcHRpb24gdGhhdCB3YXMganVzdCB0aHJvd24uIEV4aXQgd2l0aG91dCBjb21taXR0aW5nLiBUaGlzIGlzXG4gICAgICAvLyBzaW1pbGFyIHRvIGEgc3VzcGVuZCwgYnV0IHdpdGhvdXQgYSB0aW1lb3V0IGJlY2F1c2Ugd2UncmUgbm90IHdhaXRpbmdcbiAgICAgIC8vIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZS4gUmVhY3Qgd2lsbCByZXN0YXJ0IGF0IHRoZSBsb3dlclxuICAgICAgLy8gcHJpb3JpdHkgbGV2ZWwuXG4gICAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB2YXIgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgICAgb25TdXNwZW5kKFxuICAgICAgICByb290LFxuICAgICAgICByb290V29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lLFxuICAgICAgICByb290RXhwaXJhdGlvblRpbWUsXG4gICAgICAgIC0xIC8vIEluZGljYXRlcyBubyB0aW1lb3V0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBUaGVyZSdzIG5vIGxvd2VyIHByaW9yaXR5IHdvcmssIGJ1dCB3ZSdyZSByZW5kZXJpbmcgYXN5bmNocm9ub3VzbHkuXG4gICAgICAvLyBTeW5jaHJvbnNvdWx5IGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBzYW1lIGxldmVsIG9uZSBtb3JlIHRpbWUuIFRoaXMgaXNcbiAgICAgIC8vIHNpbWlsYXIgdG8gYSBzdXNwZW5kLCBidXQgd2l0aG91dCBhIHRpbWVvdXQgYmVjYXVzZSB3ZSdyZSBub3Qgd2FpdGluZ1xuICAgICAgLy8gZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLlxuICAgICAgIXJvb3QuZGlkRXJyb3IgJiZcbiAgICAgICFpc0V4cGlyZWRcbiAgICApIHtcbiAgICAgIHJvb3QuZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgdmFyIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZSA9IChyb290Lm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gZXhwaXJhdGlvblRpbWUpO1xuICAgICAgdmFyIF9yb290RXhwaXJhdGlvblRpbWUgPSAocm9vdC5leHBpcmF0aW9uVGltZSA9IFN5bmMpO1xuICAgICAgb25TdXNwZW5kKFxuICAgICAgICByb290LFxuICAgICAgICByb290V29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgX3Jvb3RFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgLTEgLy8gSW5kaWNhdGVzIG5vIHRpbWVvdXRcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuYWJsZVN1c3BlbnNlICYmICFpc0V4cGlyZWQgJiYgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zICE9PSAtMSkge1xuICAgIC8vIFRoZSB0cmVlIHdhcyBzdXNwZW5kZWQuXG4gICAgdmFyIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZTIgPSBleHBpcmF0aW9uVGltZTtcbiAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyKTtcblxuICAgIC8vIEZpbmQgdGhlIGVhcmxpZXN0IHVuY29tbWl0dGVkIGV4cGlyYXRpb24gdGltZSBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nXG4gICAgLy8gd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlIHRpbWVvdXQgdGhyZXNob2xkIGNhbm5vdCBiZSBsb25nZXIgdGhhblxuICAgIC8vIHRoZSBvdmVyYWxsIGV4cGlyYXRpb24uXG4gICAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwoXG4gICAgICByb290LFxuICAgICAgZXhwaXJhdGlvblRpbWVcbiAgICApO1xuICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZWFybGllc3RFeHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyA8IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcykge1xuICAgICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gZWFybGllc3RFeHBpcmF0aW9uVGltZU1zO1xuICAgIH1cblxuICAgIC8vIFN1YnRyYWN0IHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYWJzb2x1dGUgdGltZW91dCB0byBnZXQgdGhlIG51bWJlclxuICAgIC8vIG9mIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgdGltZW91dC4gSW4gb3RoZXIgd29yZHMsIGNvbnZlcnQgYW4gYWJzb2x1dGVcbiAgICAvLyB0aW1lc3RhbXAgdG8gYSByZWxhdGl2ZSB0aW1lLiBUaGlzIGlzIHRoZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZFxuICAgIC8vIHRvIGBzZXRUaW1lb3V0YC5cbiAgICB2YXIgY3VycmVudFRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhyZXF1ZXN0Q3VycmVudFRpbWUoKSk7XG4gICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIC0gY3VycmVudFRpbWVNcztcbiAgICBtc1VudGlsVGltZW91dCA9IG1zVW50aWxUaW1lb3V0IDwgMCA/IDAgOiBtc1VudGlsVGltZW91dDtcblxuICAgIC8vIFRPRE86IEFjY291bnQgZm9yIHRoZSBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZVxuXG4gICAgdmFyIF9yb290RXhwaXJhdGlvblRpbWUyID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBvblN1c3BlbmQoXG4gICAgICByb290LFxuICAgICAgcm9vdFdvcmtJblByb2dyZXNzLFxuICAgICAgX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lMixcbiAgICAgIF9yb290RXhwaXJhdGlvblRpbWUyLFxuICAgICAgbXNVbnRpbFRpbWVvdXRcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlYWR5IHRvIGNvbW1pdC5cbiAgb25Db21wbGV0ZShyb290LCByb290V29ya0luUHJvZ3Jlc3MsIGV4cGlyYXRpb25UaW1lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goc291cmNlRmliZXIsIHZhbHVlLCBleHBpcmF0aW9uVGltZSkge1xuICBpbnZhcmlhbnQoXG4gICAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmckMSxcbiAgICBcImRpc3BhdGNoOiBDYW5ub3QgZGlzcGF0Y2ggZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXCJcbiAgKTtcblxuICB2YXIgZmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudExhenk6XG4gICAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OiB7XG4gICAgICAgIHZhciBfZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgX2Vycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCBfdXBkYXRlKTtcbiAgICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgdmFyIHJvb3RGaWJlciA9IHNvdXJjZUZpYmVyO1xuICAgIHZhciBfZXJyb3JJbmZvMiA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHJvb3RGaWJlcik7XG4gICAgdmFyIF91cGRhdGUyID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgcm9vdEZpYmVyLFxuICAgICAgX2Vycm9ySW5mbzIsXG4gICAgICBleHBpcmF0aW9uVGltZVxuICAgICk7XG4gICAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIF91cGRhdGUyKTtcbiAgICBzY2hlZHVsZVdvcmsocm9vdEZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGVycm9yKSB7XG4gIHJldHVybiBkaXNwYXRjaChmaWJlciwgZXJyb3IsIFN5bmMpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVGhyZWFkSUQoZXhwaXJhdGlvblRpbWUsIGludGVyYWN0aW9uVGhyZWFkSUQpIHtcbiAgLy8gSW50ZXJhY3Rpb24gdGhyZWFkcyBhcmUgdW5pcXVlIHBlciByb290IGFuZCBleHBpcmF0aW9uIHRpbWUuXG4gIHJldHVybiBleHBpcmF0aW9uVGltZSAqIDEwMDAgKyBpbnRlcmFjdGlvblRocmVhZElEO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcikge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gQW4gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQ7XG4gICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nJDEpIHtcbiAgICAgIC8vIFVwZGF0ZXMgdGhhdCBvY2N1ciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBzaG91bGQgaGF2ZSBzeW5jIHByaW9yaXR5XG4gICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgIGV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBObyBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldCwgYW5kIHdlJ3JlIG5vdCBjdXJyZW50bHlcbiAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgaWYgKGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gYXN5bmMgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZyBhIHRyZWUsIGRvIG5vdCB1cGRhdGUgYXQgdGhlIHNhbWVcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZSB0aGF0IGlzIGFscmVhZHkgcmVuZGVyaW5nLlxuICAgICAgaWYgKG5leHRSb290ICE9PSBudWxsICYmIGV4cGlyYXRpb25UaW1lID09PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhIHN5bmMgdXBkYXRlXG4gICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgfVxuICB9XG4gIGlmIChpc0JhdGNoaW5nSW50ZXJhY3RpdmVVcGRhdGVzKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcmFjdGl2ZSB1cGRhdGUuIEtlZXAgdHJhY2sgb2YgdGhlIGxvd2VzdCBwZW5kaW5nXG4gICAgLy8gaW50ZXJhY3RpdmUgZXhwaXJhdGlvbiB0aW1lLiBUaGlzIGFsbG93cyB1cyB0byBzeW5jaHJvbm91c2x5IGZsdXNoXG4gICAgLy8gYWxsIGludGVyYWN0aXZlIHVwZGF0ZXMgd2hlbiBuZWVkZWQuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID4gbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSkge1xuICAgICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQocm9vdCwgYWJzb2x1dGVUaW1lb3V0TXMsIHN1c3BlbmRlZFRpbWUpIHtcbiAgLy8gU2NoZWR1bGUgdGhlIHRpbWVvdXQuXG4gIGlmIChcbiAgICBhYnNvbHV0ZVRpbWVvdXRNcyA+PSAwICYmXG4gICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIDwgYWJzb2x1dGVUaW1lb3V0TXNcbiAgKSB7XG4gICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gYWJzb2x1dGVUaW1lb3V0TXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoKSB7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHJ5U3VzcGVuZGVkUm9vdChyb290LCBmaWJlciwgc3VzcGVuZGVkVGltZSkge1xuICBpZiAoZW5hYmxlU3VzcGVuc2UpIHtcbiAgICB2YXIgcmV0cnlUaW1lID0gdm9pZCAwO1xuXG4gICAgaWYgKGlzUHJpb3JpdHlMZXZlbFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRUaW1lKSkge1xuICAgICAgLy8gUGluZyBhdCB0aGUgb3JpZ2luYWwgbGV2ZWxcbiAgICAgIHJldHJ5VGltZSA9IHN1c3BlbmRlZFRpbWU7XG5cbiAgICAgIG1hcmtQaW5nZWRQcmlvcml0eUxldmVsKHJvb3QsIHJldHJ5VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBsYWNlaG9sZGVyIGFscmVhZHkgdGltZWQgb3V0LiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgICByZXRyeVRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG4gICAgICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgcmV0cnlUaW1lKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBJZiB0aGUgcGxhY2Vob2xkZXIgZmliZXIgaGFzIGFscmVhZHkgcmVuZGVyZWQgdGhlIHByaW1hcnkgY2hpbGRyZW5cbiAgICAvLyB3aXRob3V0IHN1c3BlbmRpbmcgKHRoYXQgaXMsIGFsbCBvZiB0aGUgcHJvbWlzZXMgaGF2ZSBhbHJlYWR5IHJlc29sdmVkKSxcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyaWdnZXIgYW5vdGhlciB1cGRhdGUgaGVyZS4gT25lIGNhc2UgdGhpcyBoYXBwZW5zIGlzIHdoZW5cbiAgICAvLyB3ZSBhcmUgaW4gc3luYyBtb2RlIGFuZCBhIHNpbmdsZSBwcm9taXNlIGlzIHRocm93biBib3RoIG9uIGluaXRpYWwgcmVuZGVyXG4gICAgLy8gYW5kIG9uIHVwZGF0ZTsgd2UgYXR0YWNoIHR3byAudGhlbihyZXRyeVN1c3BlbmRlZFJvb3QpIGNhbGxiYWNrcyBhbmQgZWFjaFxuICAgIC8vIG9uZSBwZXJmb3JtcyBTeW5jIHdvcmssIHJlcmVuZGVyaW5nIHRoZSBQbGFjZWhvbGRlci5cblxuICAgIGlmICgoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICBpZiAocm9vdCA9PT0gbmV4dFJvb3QgJiYgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAgIC8vIFJlY2VpdmVkIGEgcGluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgICAgLy8gcmVuZGVyaW5nLiBSZXN0YXJ0IGZyb20gdGhlIHJvb3QuXG4gICAgICAgIG5leHRSb290ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIHJldHJ5VGltZSk7XG4gICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHJvb3RFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICByZXF1ZXN0V29yayhyb290LCByb290RXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAge1xuICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBleHBpcmF0aW9uIHRpbWVcbiAgaWYgKFxuICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICBmaWJlci5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lXG4gICkge1xuICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH1cbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKFxuICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJlxuICAgIChhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpXG4gICkge1xuICAgIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB9XG4gIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cbiAgdmFyIG5vZGUgPSBmaWJlci5yZXR1cm47XG4gIHZhciByb290ID0gbnVsbDtcbiAgaWYgKG5vZGUgPT09IG51bGwgJiYgZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHJvb3QgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgaWYgKFxuICAgICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZVxuICAgICAgKSB7XG4gICAgICAgIG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICAgICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpXG4gICAgICAgICkge1xuICAgICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGFsdGVybmF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fFxuICAgICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpXG4gICAgICApIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCAmJiBub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIGlmIChcbiAgICAgIHRydWUgJiZcbiAgICAgIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KVxuICAgICkge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgdmFyIGludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9uTWFwID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXA7XG4gICAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5nZXQoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHBlbmRpbmdJbnRlcmFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGlmICghcGVuZGluZ0ludGVyYWN0aW9ucy5oYXMoaW50ZXJhY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChleHBpcmF0aW9uVGltZSwgbmV3IFNldChpbnRlcmFjdGlvbnMpKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChcbiAgICAgICAgICBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgICByb290LmludGVyYWN0aW9uVGhyZWFkSURcbiAgICAgICAgKTtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHJvb3QgPSBzY2hlZHVsZVdvcmtUb1Jvb3QoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoXG4gICAgIWlzV29ya2luZyAmJlxuICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmXG4gICAgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWVcbiAgKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgIHJlc2V0U3RhY2soKTtcbiAgfVxuICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoXG4gICAgLy8gSWYgd2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZSwgd2UgZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSB0aGlzIHJvb3RcbiAgICAvLyBmb3IgYW4gdXBkYXRlLCBiZWNhdXNlIHdlJ2xsIGRvIGl0IGJlZm9yZSB3ZSBleGl0Li4uXG4gICAgIWlzV29ya2luZyB8fFxuICAgIGlzQ29tbWl0dGluZyQxIHx8XG4gICAgLy8gLi4udW5sZXNzIHRoaXMgaXMgYSBkaWZmZXJlbnQgcm9vdCB0aGFuIHRoZSBvbmUgd2UncmUgcmVuZGVyaW5nLlxuICAgIG5leHRSb290ICE9PSByb290XG4gICkge1xuICAgIHZhciByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIHJlcXVlc3RXb3JrKHJvb3QsIHJvb3RFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgIC8vIFJlc2V0IHRoaXMgYmFjayB0byB6ZXJvIHNvIHN1YnNlcXVlbnQgdXBkYXRlcyBkb24ndCB0aHJvdy5cbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIFwiICtcbiAgICAgICAgXCJjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgXCIgK1xuICAgICAgICBcImNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgXCIgK1xuICAgICAgICBcInRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cIlxuICAgICk7XG4gIH1cbn1cblxuLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbi8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbnZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGNhbGxiYWNrSUQgPSB2b2lkIDA7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbnZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xudmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xudmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG52YXIgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xudmFyIGRlYWRsaW5lID0gbnVsbDtcblxudmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG52YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xudmFyIGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMgPSBmYWxzZTtcblxudmFyIGNvbXBsZXRlZEJhdGNoZXMgPSBudWxsO1xuXG52YXIgb3JpZ2luYWxTdGFydFRpbWVNcyA9IG5vdygpO1xudmFyIGN1cnJlbnRSZW5kZXJlclRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUob3JpZ2luYWxTdGFydFRpbWVNcyk7XG52YXIgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuXG4vLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCA9IG51bGw7XG5cbnZhciB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yayA9IDE7XG5cbmZ1bmN0aW9uIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKSB7XG4gIHZhciBjdXJyZW50VGltZU1zID0gbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICBjdXJyZW50UmVuZGVyZXJUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKGN1cnJlbnRUaW1lTXMpO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAvLyBBIGNhbGxiYWNrIGlzIGFscmVhZHkgc2NoZWR1bGVkLiBDaGVjayBpdHMgZXhwaXJhdGlvbiB0aW1lICh0aW1lb3V0KS5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPiBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbGJhY2tJRCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHZhciBjdXJyZW50TXMgPSBub3coKSAtIG9yaWdpbmFsU3RhcnRUaW1lTXM7XG4gIHZhciBleHBpcmF0aW9uVGltZU1zID0gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKTtcbiAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uVGltZU1zIC0gY3VycmVudE1zO1xuICBjYWxsYmFja0lEID0gc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmssIHsgdGltZW91dDogdGltZW91dCB9KTtcbn1cblxuLy8gRm9yIGV2ZXJ5IGNhbGwgdG8gcmVuZGVyUm9vdCwgb25lIG9mIG9uRmF0YWwsIG9uQ29tcGxldGUsIG9uU3VzcGVuZCwgYW5kXG4vLyBvbllpZWxkIGlzIGNhbGxlZCB1cG9uIGV4aXRpbmcuIFdlIHVzZSB0aGVzZSBpbiBsaWV1IG9mIHJldHVybmluZyBhIHR1cGxlLlxuLy8gSSd2ZSBhbHNvIGNob3NlbiBub3QgdG8gaW5saW5lIHRoZW0gaW50byByZW5kZXJSb290IGJlY2F1c2UgdGhlc2Ugd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5mdW5jdGlvbiBvbkZhdGFsKHJvb3QpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBsZXRlKHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG59XG5cbmZ1bmN0aW9uIG9uU3VzcGVuZChcbiAgcm9vdCxcbiAgZmluaXNoZWRXb3JrLFxuICBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSxcbiAgcm9vdEV4cGlyYXRpb25UaW1lLFxuICBtc1VudGlsVGltZW91dFxuKSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSByb290RXhwaXJhdGlvblRpbWU7XG4gIGlmIChlbmFibGVTdXNwZW5zZSAmJiBtc1VudGlsVGltZW91dCA9PT0gMCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIC8vIERvbid0IHdhaXQgYW4gYWRkaXRpb25hbCB0aWNrLiBDb21taXQgdGhlIHRyZWUgaW1tZWRpYXRlbHkuXG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgfSBlbHNlIGlmIChtc1VudGlsVGltZW91dCA+IDApIHtcbiAgICAvLyBXYWl0IGBtc1VudGlsVGltZW91dGAgbWlsbGlzZWNvbmRzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChcbiAgICAgIG9uVGltZW91dC5iaW5kKG51bGwsIHJvb3QsIGZpbmlzaGVkV29yaywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUpLFxuICAgICAgbXNVbnRpbFRpbWVvdXRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uWWllbGQocm9vdCkge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG9uVGltZW91dChyb290LCBmaW5pc2hlZFdvcmssIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChlbmFibGVTdXNwZW5zZSkge1xuICAgIC8vIFRoZSByb290IHRpbWVkIG91dC4gQ29tbWl0IGl0LlxuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gc3VzcGVuZGVkRXhwaXJhdGlvblRpbWU7XG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgLy8gUmVhZCB0aGUgY3VycmVudCB0aW1lIGJlZm9yZSBlbnRlcmluZyB0aGUgY29tbWl0IHBoYXNlLiBXZSBjYW4gYmVcbiAgICAvLyBjZXJ0YWluIHRoaXMgd29uJ3QgY2F1c2UgdGVhcmluZyByZWxhdGVkIHRvIGJhdGNoaW5nIG9mIGV2ZW50IHVwZGF0ZXNcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIGF0IHRoZSB0b3Agb2YgYSB0aW1lciBldmVudC5cbiAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgIGZsdXNoUm9vdChyb290LCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXQocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RDdXJyZW50VGltZSgpIHtcbiAgLy8gcmVxdWVzdEN1cnJlbnRUaW1lIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGNvbXB1dGUgYW4gZXhwaXJhdGlvblxuICAvLyB0aW1lLlxuICAvL1xuICAvLyBFeHBpcmF0aW9uIHRpbWVzIGFyZSBjb21wdXRlZCBieSBhZGRpbmcgdG8gdGhlIGN1cnJlbnQgdGltZSAodGhlIHN0YXJ0XG4gIC8vIHRpbWUpLiBIb3dldmVyLCBpZiB0d28gdXBkYXRlcyBhcmUgc2NoZWR1bGVkIHdpdGhpbiB0aGUgc2FtZSBldmVudCwgd2VcbiAgLy8gc2hvdWxkIHRyZWF0IHRoZWlyIHN0YXJ0IHRpbWVzIGFzIHNpbXVsdGFuZW91cywgZXZlbiBpZiB0aGUgYWN0dWFsIGNsb2NrXG4gIC8vIHRpbWUgaGFzIGFkdmFuY2VkIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxuICAvLyBJbiBvdGhlciB3b3JkcywgYmVjYXVzZSBleHBpcmF0aW9uIHRpbWVzIGRldGVybWluZSBob3cgdXBkYXRlcyBhcmUgYmF0Y2hlZCxcbiAgLy8gd2Ugd2FudCBhbGwgdXBkYXRlcyBvZiBsaWtlIHByaW9yaXR5IHRoYXQgb2NjdXIgd2l0aGluIHRoZSBzYW1lIGV2ZW50IHRvXG4gIC8vIHJlY2VpdmUgdGhlIHNhbWUgZXhwaXJhdGlvbiB0aW1lLiBPdGhlcndpc2Ugd2UgZ2V0IHRlYXJpbmcuXG4gIC8vXG4gIC8vIFdlIGtlZXAgdHJhY2sgb2YgdHdvIHNlcGFyYXRlIHRpbWVzOiB0aGUgY3VycmVudCBcInJlbmRlcmVyXCIgdGltZSBhbmQgdGhlXG4gIC8vIGN1cnJlbnQgXCJzY2hlZHVsZXJcIiB0aW1lLiBUaGUgcmVuZGVyZXIgdGltZSBjYW4gYmUgdXBkYXRlZCB3aGVuZXZlcjsgaXRcbiAgLy8gb25seSBleGlzdHMgdG8gbWluaW1pemUgdGhlIGNhbGxzIHBlcmZvcm1hbmNlLm5vdy5cbiAgLy9cbiAgLy8gQnV0IHRoZSBzY2hlZHVsZXIgdGltZSBjYW4gb25seSBiZSB1cGRhdGVkIGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrLCBvclxuICAvLyBpZiB3ZSBrbm93IGZvciBjZXJ0YWluIHRoYXQgd2UncmUgbm90IGluIHRoZSBtaWRkbGUgb2YgYW4gZXZlbnQuXG5cbiAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgLy8gV2UncmUgYWxyZWFkeSByZW5kZXJpbmcuIFJldHVybiB0aGUgbW9zdCByZWNlbnRseSByZWFkIHRpbWUuXG4gICAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXJUaW1lO1xuICB9XG4gIC8vIENoZWNrIGlmIHRoZXJlJ3MgcGVuZGluZyB3b3JrLlxuICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICBpZiAoXG4gICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9PT0gTmV2ZXJcbiAgKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBwZW5kaW5nIHdvcmssIG9yIGlmIHRoZSBwZW5kaW5nIHdvcmsgaXMgb2Zmc2NyZWVuLCB3ZSBjYW5cbiAgICAvLyByZWFkIHRoZSBjdXJyZW50IHRpbWUgd2l0aG91dCByaXNrIG9mIHRlYXJpbmcuXG4gICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgIGN1cnJlbnRTY2hlZHVsZXJUaW1lID0gY3VycmVudFJlbmRlcmVyVGltZTtcbiAgICByZXR1cm4gY3VycmVudFNjaGVkdWxlclRpbWU7XG4gIH1cbiAgLy8gVGhlcmUncyBhbHJlYWR5IHBlbmRpbmcgd29yay4gV2UgbWlnaHQgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXJcbiAgLy8gZXZlbnQuIElmIHdlIHdlcmUgdG8gcmVhZCB0aGUgY3VycmVudCB0aW1lLCBpdCBjb3VsZCBjYXVzZSBtdWx0aXBsZSB1cGRhdGVzXG4gIC8vIHdpdGhpbiB0aGUgc2FtZSBldmVudCB0byByZWNlaXZlIGRpZmZlcmVudCBleHBpcmF0aW9uIHRpbWVzLCBsZWFkaW5nIHRvXG4gIC8vIHRlYXJpbmcuIFJldHVybiB0aGUgbGFzdCByZWFkIHRpbWUuIER1cmluZyB0aGUgbmV4dCBpZGxlIGNhbGxiYWNrLCB0aGVcbiAgLy8gdGltZSB3aWxsIGJlIHVwZGF0ZWQuXG4gIHJldHVybiBjdXJyZW50U2NoZWR1bGVyVGltZTtcbn1cblxuLy8gcmVxdWVzdFdvcmsgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS5cbi8vIEl0J3MgdXAgdG8gdGhlIHJlbmRlcmVyIHRvIGNhbGwgcmVuZGVyUm9vdCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG5mdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICBhZGRSb290VG9TY2hlZHVsZShyb290LCBleHBpcmF0aW9uVGltZSk7XG4gIGlmIChpc1JlbmRlcmluZykge1xuICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSBjdXJyZW50bHkgcmVuZGVyaW5nIGJhdGNoLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIC8vIEZsdXNoIHdvcmsgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG4gICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIC8vIC4uLnVubGVzcyB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlcywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGRcbiAgICAgIC8vIGZsdXNoIGl0IG5vdy5cbiAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIFN5bmMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBHZXQgcmlkIG9mIFN5bmMgYW5kIHVzZSBjdXJyZW50IHRpbWU/XG4gIGlmIChleHBpcmF0aW9uVGltZSA9PT0gU3luYykge1xuICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvblRpbWUocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvb3RUb1NjaGVkdWxlKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIEFkZCB0aGUgcm9vdCB0byB0aGUgc2NoZWR1bGUuXG4gIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICBpZiAocm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgcm9vdCBpcyBub3QgYWxyZWFkeSBzY2hlZHVsZWQuIEFkZCBpdC5cbiAgICByb290LmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgYnV0IGl0cyBwcmlvcml0eSBtYXkgaGF2ZSBpbmNyZWFzZWQuXG4gICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoXG4gICAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lXG4gICAgKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgdmFyIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSBOb1dvcms7XG4gIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcbiAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsLFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBwcmV2aW91cyBhbmQgbGFzdCByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBcIiArXG4gICAgICAgICAgICBcImNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290O1xuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHxcbiAgICAgICAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA8IGhpZ2hlc3RQcmlvcml0eVdvcmtcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICAgICAgICAvLyBTeW5jIGlzIGhpZ2hlc3QgcHJpb3JpdHkgYnkgZGVmaW5pdGlvbiBzb1xuICAgICAgICAgIC8vIHdlIGNhbiBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbn1cblxuZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICBpZiAoZGwuZGlkVGltZW91dCkge1xuICAgIC8vIFRoZSBjYWxsYmFjayB0aW1lZCBvdXQuIFRoYXQgbWVhbnMgYXQgbGVhc3Qgb25lIHVwZGF0ZSBoYXMgZXhwaXJlZC5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvb3Qgc2NoZWR1bGUuIElmIHRoZXkgY29udGFpbiBleHBpcmVkIHdvcmssIHNldFxuICAgIC8vIHRoZSBuZXh0IHJlbmRlciBleHBpcmF0aW9uIHRpbWUgdG8gdGhlIGN1cnJlbnQgdGltZS4gVGhpcyBoYXMgdGhlIGVmZmVjdFxuICAgIC8vIG9mIGZsdXNoaW5nIGFsbCBleHBpcmVkIHdvcmsgaW4gYSBzaW5nbGUgYmF0Y2gsIGluc3RlYWQgb2YgZmx1c2hpbmcgZWFjaFxuICAgIC8vIGxldmVsIG9uZSBhdCBhIHRpbWUuXG4gICAgaWYgKGZpcnN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICBkbyB7XG4gICAgICAgIGRpZEV4cGlyZUF0RXhwaXJhdGlvblRpbWUocm9vdCwgY3VycmVudFJlbmRlcmVyVGltZSk7XG4gICAgICAgIC8vIFRoZSByb290IHNjaGVkdWxlIGlzIGNpcmN1bGFyLCBzbyB0aGlzIGlzIG5ldmVyIG51bGwuXG4gICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgfSB3aGlsZSAocm9vdCAhPT0gZmlyc3RTY2hlZHVsZWRSb290KTtcbiAgICB9XG4gIH1cbiAgcGVyZm9ybVdvcmsoTm9Xb3JrLCBkbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29yaygpIHtcbiAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrKG1pbkV4cGlyYXRpb25UaW1lLCBkbCkge1xuICBkZWFkbGluZSA9IGRsO1xuXG4gIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgd2UgcmVhY2hcbiAgLy8gdGhlIGRlYWRsaW5lLlxuICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuXG4gIGlmIChkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uVGltZVRvTXMobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICB3aGlsZSAoXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiZcbiAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJlxuICAgICAgKG1pbkV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHxcbiAgICAgICAgbWluRXhwaXJhdGlvblRpbWUgPj0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSkgJiZcbiAgICAgICghZGVhZGxpbmVEaWRFeHBpcmUgfHwgY3VycmVudFJlbmRlcmVyVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKVxuICAgICkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QoXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCxcbiAgICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSxcbiAgICAgICAgY3VycmVudFJlbmRlcmVyVGltZSA+PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lXG4gICAgICApO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICAgIGN1cnJlbnRTY2hlZHVsZXJUaW1lID0gY3VycmVudFJlbmRlcmVyVGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKFxuICAgICAgbmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmXG4gICAgICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiZcbiAgICAgIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8XG4gICAgICAgIG1pbkV4cGlyYXRpb25UaW1lID49IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpXG4gICAgKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUsIHRydWUpO1xuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG4gIH1cblxuICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgLy8gSWYgd2UncmUgaW5zaWRlIGEgY2FsbGJhY2ssIHNldCB0aGlzIHRvIGZhbHNlIHNpbmNlIHdlIGp1c3QgY29tcGxldGVkIGl0LlxuICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGNhbGxiYWNrSUQgPSBudWxsO1xuICB9XG4gIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShcbiAgICAgIG5leHRGbHVzaGVkUm9vdCxcbiAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWVcbiAgICApO1xuICB9XG5cbiAgLy8gQ2xlYW4tdXAuXG4gIGRlYWRsaW5lID0gbnVsbDtcbiAgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcblxuICBmaW5pc2hSZW5kZXJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIGludmFyaWFudChcbiAgICAhaXNSZW5kZXJpbmcsXG4gICAgXCJ3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBcIiArXG4gICAgICBcIm1lYW5zIHlvdSBhdHRlbXB0ZWQgdG8gY29tbWl0IGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC5cIlxuICApO1xuICAvLyBQZXJmb3JtIHdvcmsgb24gcm9vdCBhcyBpZiB0aGUgZ2l2ZW4gZXhwaXJhdGlvbiB0aW1lIGlzIHRoZSBjdXJyZW50IHRpbWUuXG4gIC8vIFRoaXMgaGFzIHRoZSBlZmZlY3Qgb2Ygc3luY2hyb25vdXNseSBmbHVzaGluZyBhbGwgd29yayB1cCB0byBhbmRcbiAgLy8gaW5jbHVkaW5nIHRoZSBnaXZlbiB0aW1lLlxuICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lLCB0cnVlKTtcbiAgLy8gRmx1c2ggYW55IHN5bmMgd29yayB0aGF0IHdhcyBzY2hlZHVsZWQgYnkgbGlmZWN5Y2xlc1xuICBwZXJmb3JtU3luY1dvcmsoKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nKCkge1xuICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gbnVsbDtcblxuICBpZiAoY29tcGxldGVkQmF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIHZhciBiYXRjaGVzID0gY29tcGxldGVkQmF0Y2hlcztcbiAgICBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICB0cnkge1xuICAgICAgICBiYXRjaC5fb25Db21wbGV0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gdW5oYW5kbGVkRXJyb3I7XG4gICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzRXhwaXJlZCkge1xuICBpbnZhcmlhbnQoXG4gICAgIWlzUmVuZGVyaW5nLFxuICAgIFwicGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIFwiICtcbiAgICAgIFwiYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICk7XG5cbiAgaXNSZW5kZXJpbmcgPSB0cnVlO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgaWYgKGRlYWRsaW5lID09PSBudWxsIHx8IGlzRXhwaXJlZCkge1xuICAgIC8vIEZsdXNoIHdvcmsgd2l0aG91dCB5aWVsZGluZy5cbiAgICAvLyBUT0RPOiBOb24teWllbGR5IHdvcmsgZG9lcyBub3QgbmVjZXNzYXJpbHkgaW1wbHkgZXhwaXJlZCB3b3JrLiBBIHJlbmRlcmVyXG4gICAgLy8gbWF5IHdhbnQgdG8gcGVyZm9ybSBzb21lIHdvcmsgd2l0aG91dCB5aWVsZGluZywgYnV0IGFsc28gd2l0aG91dFxuICAgIC8vIHJlcXVpcmluZyB0aGUgcm9vdCB0byBjb21wbGV0ZSAoYnkgdHJpZ2dlcmluZyBwbGFjZWhvbGRlcnMpLlxuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgY29tcGxldGVSb290KHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAvLyBJZiB0aGlzIHJvb3QgcHJldmlvdXNseSBzdXNwZW5kZWQsIGNsZWFyIGl0cyBleGlzdGluZyB0aW1lb3V0LCBzaW5jZVxuICAgICAgLy8gd2UncmUgYWJvdXQgdG8gdHJ5IHJlbmRlcmluZyBhZ2Fpbi5cbiAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCkge1xuICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICAgIC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG4gICAgICAgIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICB9XG4gICAgICB2YXIgaXNZaWVsZHkgPSBmYWxzZTtcbiAgICAgIHJlbmRlclJvb3Qocm9vdCwgaXNZaWVsZHksIGlzRXhwaXJlZCk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChfZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgcm9vdCBwcmV2aW91c2x5IHN1c3BlbmRlZCwgY2xlYXIgaXRzIGV4aXN0aW5nIHRpbWVvdXQsIHNpbmNlXG4gICAgICAvLyB3ZSdyZSBhYm91dCB0byB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICAgICAgdmFyIF90aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlICYmIF90aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KF90aW1lb3V0SGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBfaXNZaWVsZHkgPSB0cnVlO1xuICAgICAgcmVuZGVyUm9vdChyb290LCBfaXNZaWVsZHksIGlzRXhwaXJlZCk7XG4gICAgICBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgIC8vIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1JlbmRlcmluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYmF0Y2ggdGhhdCBtYXRjaGVzIHRoaXMgZXhwaXJhdGlvbiB0aW1lLlxuICB2YXIgZmlyc3RCYXRjaCA9IHJvb3QuZmlyc3RCYXRjaDtcbiAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWUgPD0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY29tcGxldGVkQmF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcyA9IFtmaXJzdEJhdGNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcy5wdXNoKGZpcnN0QmF0Y2gpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RCYXRjaC5fZGVmZXIpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBibG9ja2VkIGZyb20gY29tbWl0dGluZyBieSBhIGJhdGNoLiBVbnNjaGVkdWxlIGl0IHVudGlsXG4gICAgICAvLyB3ZSByZWNlaXZlIGFub3RoZXIgdXBkYXRlLlxuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICByb290LmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbW1pdCB0aGUgcm9vdC5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBuZXN0ZWQgdXBkYXRlIChhIHN5bmMgdXBkYXRlIHNjaGVkdWxlZCBkdXJpbmcgdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSkuXG4gIGlmIChyb290ID09PSBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCkge1xuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gcm9vdDtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cbiAgY29tbWl0Um9vdChyb290LCBmaW5pc2hlZFdvcmspO1xufVxuXG4vLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4vLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbmZ1bmN0aW9uIHNob3VsZFlpZWxkKCkge1xuICBpZiAoZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoXG4gICAgZGVhZGxpbmUgPT09IG51bGwgfHxcbiAgICBkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29ya1xuICApIHtcbiAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAvLyBkdXJpbmcgYSB0aW1lb3V0LiBUaGlzIHBhdGggaXMgb25seSBoaXQgZm9yIG5vbi1leHBpcmVkIHdvcmsuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICBpbnZhcmlhbnQoXG4gICAgbmV4dEZsdXNoZWRSb290ICE9PSBudWxsLFxuICAgIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgK1xuICAgICAgXCJSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgKTtcbiAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3Qgc28gd2UgZG9uJ3Qgd29yayBvbiBpdCBhZ2FpbiB1bnRpbCB0aGVyZSdzXG4gIC8vIGFub3RoZXIgdXBkYXRlLlxuICBuZXh0Rmx1c2hlZFJvb3QuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgfVxufVxuXG4vLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4vLyB0aGUgcmVjb25jaWxlci5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzJDEoZm4sIGEpIHtcbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgIHBlcmZvcm1TeW5jV29yaygpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcykge1xuICAgIHJldHVybiBmbihhLCBiKTtcbiAgfVxuICAvLyBJZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcywgc3luY2hyb25vdXNseSBmbHVzaCB0aGVtLlxuICAvLyBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgd2UgcmVhZCBhbnkgaGFuZGxlcnMsIGJlY2F1c2UgdGhlIGVmZmVjdCBvZlxuICAvLyB0aGUgcHJldmlvdXMgZXZlbnQgbWF5IGluZmx1ZW5jZSB3aGljaCBoYW5kbGVycyBhcmUgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGlzIGV2ZW50LlxuICBpZiAoXG4gICAgIWlzQmF0Y2hpbmdVcGRhdGVzICYmXG4gICAgIWlzUmVuZGVyaW5nICYmXG4gICAgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrXG4gICkge1xuICAgIC8vIFN5bmNocm9ub3VzbHkgZmx1c2ggcGVuZGluZyBpbnRlcmFjdGl2ZSB1cGRhdGVzLlxuICAgIHBlcmZvcm1Xb3JrKGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIH1cbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ0ludGVyYWN0aXZlVXBkYXRlcyA9IGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMgPSB0cnVlO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEsIGIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdJbnRlcmFjdGl2ZVVwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXMkMSgpIHtcbiAgaWYgKFxuICAgICFpc1JlbmRlcmluZyAmJlxuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgIT09IE5vV29ya1xuICApIHtcbiAgICAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgaW50ZXJhY3RpdmUgdXBkYXRlcy5cbiAgICBwZXJmb3JtV29yayhsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbi8vIDAgaXMgUFJPRCwgMSBpcyBERVYuXG4vLyBNaWdodCBhZGQgUFJPRklMRSBsYXRlci5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0JDEocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gZmliZXIudHlwZTtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnRMYXp5KSB7XG4gICAgdmFyIF9Db21wb25lbnQgPSBnZXRSZXN1bHRGcm9tUmVzb2x2ZWRUaGVuYWJsZShmaWJlci50eXBlKTtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBfQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVSb290VXBkYXRlKGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICB7XG4gICAgaWYgKHBoYXNlID09PSBcInJlbmRlclwiICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgXCIgK1xuICAgICAgICAgIFwidHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuIFwiICtcbiAgICAgICAgICBcIklmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuXCIgK1xuICAgICAgICAgIFwiQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuXCIsXG4gICAgICAgIGdldENvbXBvbmVudE5hbWUoY3VycmVudC50eXBlKSB8fCBcIlVua25vd25cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIFwiICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLlwiLFxuICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgIClcbiAgICAgIDogdm9pZCAwO1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQkMSwgdXBkYXRlKTtcblxuICBzY2hlZHVsZVdvcmsoY3VycmVudCQkMSwgZXhwaXJhdGlvblRpbWUpO1xuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckF0RXhwaXJhdGlvblRpbWUoXG4gIGVsZW1lbnQsXG4gIGNvbnRhaW5lcixcbiAgcGFyZW50Q29tcG9uZW50LFxuICBleHBpcmF0aW9uVGltZSxcbiAgY2FsbGJhY2tcbikge1xuICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgdmFyIGN1cnJlbnQkJDEgPSBjb250YWluZXIuY3VycmVudDtcblxuICB7XG4gICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIGlmIChjdXJyZW50JCQxLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICByZXR1cm4gc2NoZWR1bGVSb290VXBkYXRlKGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UkMShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0JDEoY29tcG9uZW50KTtcbiAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCBcIlVuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogJXNcIixcbiAgICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgaXNDb25jdXJyZW50LCBoeWRyYXRlKSB7XG4gIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaXNDb25jdXJyZW50LCBoeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgY3VycmVudCQkMSk7XG4gIHJldHVybiB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lKFxuICAgIGVsZW1lbnQsXG4gICAgY29udGFpbmVyLFxuICAgIHBhcmVudENvbXBvbmVudCxcbiAgICBleHBpcmF0aW9uVGltZSxcbiAgICBjYWxsYmFja1xuICApO1xufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG5cbiAgcmV0dXJuIGluamVjdEludGVybmFscyhcbiAgICBPYmplY3QuYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH0sXG4gICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vLyBUaGlzIGZpbGUgaW50ZW50aW9uYWxseSBkb2VzICpub3QqIGhhdmUgdGhlIEZsb3cgYW5ub3RhdGlvbi5cbi8vIERvbid0IGFkZCBpdC4gU2VlIGAuL2lubGluZS10eXBlZC5qc2AgZm9yIGFuIGV4cGxhbmF0aW9uLlxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJJbmZvLFxuICAvLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuICBpbXBsZW1lbnRhdGlvblxuKSB7XG4gIHZhciBrZXkgPVxuICAgIGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiBcIlwiICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9IFwiMTYuNS4yXCI7XG5cbi8vIE1vZHVsZXMgcHJvdmlkZWQgYnkgUk46XG52YXIgTmF0aXZlTWV0aG9kc01peGluID0gZnVuY3Rpb24oZmluZE5vZGVIYW5kbGUsIGZpbmRIb3N0SW5zdGFuY2UpIHtcbiAgLyoqXG4gICAqIGBOYXRpdmVNZXRob2RzTWl4aW5gIHByb3ZpZGVzIG1ldGhvZHMgdG8gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZVxuICAgKiBjb21wb25lbnQgZGlyZWN0bHkuIFRoaXMgY2FuIGJlIHVzZWZ1bCBpbiBjYXNlcyB3aGVuIHlvdSB3YW50IHRvIGZvY3VzXG4gICAqIGEgdmlldyBvciBtZWFzdXJlIGl0cyBvbi1zY3JlZW4gZGltZW5zaW9ucywgZm9yIGV4YW1wbGUuXG4gICAqXG4gICAqIFRoZSBtZXRob2RzIGRlc2NyaWJlZCBoZXJlIGFyZSBhdmFpbGFibGUgb24gbW9zdCBvZiB0aGUgZGVmYXVsdCBjb21wb25lbnRzXG4gICAqIHByb3ZpZGVkIGJ5IFJlYWN0IE5hdGl2ZS4gTm90ZSwgaG93ZXZlciwgdGhhdCB0aGV5IGFyZSAqbm90KiBhdmFpbGFibGUgb25cbiAgICogY29tcG9zaXRlIGNvbXBvbmVudHMgdGhhdCBhcmVuJ3QgZGlyZWN0bHkgYmFja2VkIGJ5IGEgbmF0aXZlIHZpZXcuIFRoaXMgd2lsbFxuICAgKiBnZW5lcmFsbHkgaW5jbHVkZSBtb3N0IGNvbXBvbmVudHMgdGhhdCB5b3UgZGVmaW5lIGluIHlvdXIgb3duIGFwcC4gRm9yIG1vcmVcbiAgICogaW5mb3JtYXRpb24sIHNlZSBbRGlyZWN0XG4gICAqIE1hbmlwdWxhdGlvbl0oZG9jcy9kaXJlY3QtbWFuaXB1bGF0aW9uLmh0bWwpLlxuICAgKlxuICAgKiBOb3RlIHRoZSBGbG93ICRFeGFjdDw+IHN5bnRheCBpcyByZXF1aXJlZCB0byBzdXBwb3J0IG1peGlucy5cbiAgICogUmVhY3QgY3JlYXRlQ2xhc3MgbWl4aW5zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBleGFjdCB0eXBlcy5cbiAgICovXG4gIHZhciBOYXRpdmVNZXRob2RzTWl4aW4gPSB7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbG9jYXRpb24gb24gc2NyZWVuLCB3aWR0aCwgYW5kIGhlaWdodCBvZiB0aGUgZ2l2ZW4gdmlldyBhbmRcbiAgICAgKiByZXR1cm5zIHRoZSB2YWx1ZXMgdmlhIGFuIGFzeW5jIGNhbGxiYWNrLiBJZiBzdWNjZXNzZnVsLCB0aGUgY2FsbGJhY2sgd2lsbFxuICAgICAqIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgICAqXG4gICAgICogIC0geFxuICAgICAqICAtIHlcbiAgICAgKiAgLSB3aWR0aFxuICAgICAqICAtIGhlaWdodFxuICAgICAqICAtIHBhZ2VYXG4gICAgICogIC0gcGFnZVlcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGVzZSBtZWFzdXJlbWVudHMgYXJlIG5vdCBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIHJlbmRlcmluZ1xuICAgICAqIGhhcyBiZWVuIGNvbXBsZXRlZCBpbiBuYXRpdmUuIElmIHlvdSBuZWVkIHRoZSBtZWFzdXJlbWVudHMgYXMgc29vbiBhc1xuICAgICAqIHBvc3NpYmxlLCBjb25zaWRlciB1c2luZyB0aGUgW2BvbkxheW91dGBcbiAgICAgKiBwcm9wXShkb2NzL3ZpZXcuaHRtbCNvbmxheW91dCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBtZWFzdXJlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgVUlNYW5hZ2VyLm1lYXN1cmUoXG4gICAgICAgIGZpbmROb2RlSGFuZGxlKHRoaXMpLFxuICAgICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgY2FsbGJhY2spXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gdmlldyBpbiB0aGUgd2luZG93IGFuZCByZXR1cm5zIHRoZVxuICAgICAqIHZhbHVlcyB2aWEgYW4gYXN5bmMgY2FsbGJhY2suIElmIHRoZSBSZWFjdCByb290IHZpZXcgaXMgZW1iZWRkZWQgaW5cbiAgICAgKiBhbm90aGVyIG5hdGl2ZSB2aWV3LCB0aGlzIHdpbGwgZ2l2ZSB5b3UgdGhlIGFic29sdXRlIGNvb3JkaW5hdGVzLiBJZlxuICAgICAqIHN1Y2Nlc3NmdWwsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBhcmd1bWVudHM6XG4gICAgICpcbiAgICAgKiAgLSB4XG4gICAgICogIC0geVxuICAgICAqICAtIHdpZHRoXG4gICAgICogIC0gaGVpZ2h0XG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlc2UgbWVhc3VyZW1lbnRzIGFyZSBub3QgYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSByZW5kZXJpbmdcbiAgICAgKiBoYXMgYmVlbiBjb21wbGV0ZWQgaW4gbmF0aXZlLlxuICAgICAqL1xuICAgIG1lYXN1cmVJbldpbmRvdzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIFVJTWFuYWdlci5tZWFzdXJlSW5XaW5kb3coXG4gICAgICAgIGZpbmROb2RlSGFuZGxlKHRoaXMpLFxuICAgICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgY2FsbGJhY2spXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaWtlIFtgbWVhc3VyZSgpYF0oI21lYXN1cmUpLCBidXQgbWVhc3VyZXMgdGhlIHZpZXcgcmVsYXRpdmUgYW4gYW5jZXN0b3IsXG4gICAgICogc3BlY2lmaWVkIGFzIGByZWxhdGl2ZVRvTmF0aXZlTm9kZWAuIFRoaXMgbWVhbnMgdGhhdCB0aGUgcmV0dXJuZWQgeCwgeVxuICAgICAqIGFyZSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luIHgsIHkgb2YgdGhlIGFuY2VzdG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBBcyBhbHdheXMsIHRvIG9idGFpbiBhIG5hdGl2ZSBub2RlIGhhbmRsZSBmb3IgYSBjb21wb25lbnQsIHlvdSBjYW4gdXNlXG4gICAgICogYGZpbmROb2RlSGFuZGxlKGNvbXBvbmVudClgLlxuICAgICAqL1xuICAgIG1lYXN1cmVMYXlvdXQ6IGZ1bmN0aW9uKFxuICAgICAgcmVsYXRpdmVUb05hdGl2ZU5vZGUsXG4gICAgICBvblN1Y2Nlc3MsXG4gICAgICBvbkZhaWwgLyogY3VycmVudGx5IHVudXNlZCAqL1xuICAgICkge1xuICAgICAgVUlNYW5hZ2VyLm1lYXN1cmVMYXlvdXQoXG4gICAgICAgIGZpbmROb2RlSGFuZGxlKHRoaXMpLFxuICAgICAgICByZWxhdGl2ZVRvTmF0aXZlTm9kZSxcbiAgICAgICAgbW91bnRTYWZlQ2FsbGJhY2tfTk9UX1JFQUxMWV9TQUZFKHRoaXMsIG9uRmFpbCksXG4gICAgICAgIG1vdW50U2FmZUNhbGxiYWNrX05PVF9SRUFMTFlfU0FGRSh0aGlzLCBvblN1Y2Nlc3MpXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHByb3BzIHN0cmFpZ2h0IHRvIG5hdGl2ZS4gVGhleSB3aWxsIG5vdCBwYXJ0aWNpcGF0ZSBpblxuICAgICAqIGZ1dHVyZSBkaWZmIHByb2Nlc3MgLSB0aGlzIG1lYW5zIHRoYXQgaWYgeW91IGRvIG5vdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAgICogbmV4dCByZW5kZXIsIHRoZXkgd2lsbCByZW1haW4gYWN0aXZlIChzZWUgW0RpcmVjdFxuICAgICAqIE1hbmlwdWxhdGlvbl0oZG9jcy9kaXJlY3QtbWFuaXB1bGF0aW9uLmh0bWwpKS5cbiAgICAgKi9cbiAgICBzZXROYXRpdmVQcm9wczogZnVuY3Rpb24obmF0aXZlUHJvcHMpIHtcbiAgICAgIC8vIENsYXNzIGNvbXBvbmVudHMgZG9uJ3QgaGF2ZSB2aWV3Q29uZmlnIC0+IHZhbGlkYXRlQXR0cmlidXRlcy5cbiAgICAgIC8vIE5vciBkb2VzIGl0IG1ha2Ugc2Vuc2UgdG8gc2V0IG5hdGl2ZSBwcm9wcyBvbiBhIG5vbi1uYXRpdmUgY29tcG9uZW50LlxuICAgICAgLy8gSW5zdGVhZCwgZmluZCB0aGUgbmVhcmVzdCBob3N0IGNvbXBvbmVudCBhbmQgc2V0IHByb3BzIG9uIGl0LlxuICAgICAgLy8gVXNlIGZpbmROb2RlSGFuZGxlKCkgcmF0aGVyIHRoYW4gZmluZE5vZGVIYW5kbGUoKSBiZWNhdXNlXG4gICAgICAvLyBXZSB3YW50IHRoZSBpbnN0YW5jZS93cmFwcGVyIChub3QgdGhlIG5hdGl2ZSB0YWcpLlxuICAgICAgdmFyIG1heWJlSW5zdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgIC8vIEZpYmVyIGVycm9ycyBpZiBmaW5kTm9kZUhhbmRsZSBpcyBjYWxsZWQgZm9yIGFuIHVtb3VudGVkIGNvbXBvbmVudC5cbiAgICAgIC8vIFRlc3RzIHVzaW5nIFJlYWN0VGVzdFJlbmRlcmVyIHdpbGwgdHJpZ2dlciB0aGlzIGNhc2UgaW5kaXJlY3RseS5cbiAgICAgIC8vIE1pbWlja2luZyBzdGFjayBiZWhhdmlvciwgd2Ugc2hvdWxkIHNpbGVudGx5IGlnbm9yZSB0aGlzIGNhc2UuXG4gICAgICAvLyBUT0RPIEZpeCBSZWFjdFRlc3RSZW5kZXJlciBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgdHJ5L2NhdGNoLlxuICAgICAgdHJ5IHtcbiAgICAgICAgbWF5YmVJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2UodGhpcyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cblxuICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gaG9zdCBjb21wb25lbnQgYmVuZWF0aCB0aGlzIHdlIHNob3VsZCBmYWlsIHNpbGVudGx5LlxuICAgICAgLy8gVGhpcyBpcyBub3QgYW4gZXJyb3I7IGl0IGNvdWxkIG1lYW4gYSBjbGFzcyBjb21wb25lbnQgcmVuZGVyZWQgbnVsbC5cbiAgICAgIGlmIChtYXliZUluc3RhbmNlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlld0NvbmZpZyA9IG1heWJlSW5zdGFuY2Uudmlld0NvbmZpZztcblxuICAgICAge1xuICAgICAgICB3YXJuRm9yU3R5bGVQcm9wcyhuYXRpdmVQcm9wcywgdmlld0NvbmZpZy52YWxpZEF0dHJpYnV0ZXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGNyZWF0ZShuYXRpdmVQcm9wcywgdmlld0NvbmZpZy52YWxpZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBBdm9pZCB0aGUgb3ZlcmhlYWQgb2YgYnJpZGdlIGNhbGxzIGlmIHRoZXJlJ3Mgbm8gdXBkYXRlLlxuICAgICAgLy8gVGhpcyBpcyBhbiBleHBlbnNpdmUgbm8tb3AgZm9yIEFuZHJvaWQsIGFuZCBjYXVzZXMgYW4gdW5uZWNlc3NhcnlcbiAgICAgIC8vIHZpZXcgaW52YWxpZGF0aW9uIGZvciBjZXJ0YWluIGNvbXBvbmVudHMgKGVnIFJDVFRleHRJbnB1dCkgb24gaU9TLlxuICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT0gbnVsbCkge1xuICAgICAgICBVSU1hbmFnZXIudXBkYXRlVmlldyhcbiAgICAgICAgICBtYXliZUluc3RhbmNlLl9uYXRpdmVUYWcsXG4gICAgICAgICAgdmlld0NvbmZpZy51aVZpZXdDbGFzc05hbWUsXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBmb2N1cyBmb3IgdGhlIGdpdmVuIGlucHV0IG9yIHZpZXcuIFRoZSBleGFjdCBiZWhhdmlvciB0cmlnZ2VyZWRcbiAgICAgKiB3aWxsIGRlcGVuZCBvbiB0aGUgcGxhdGZvcm0gYW5kIHR5cGUgb2Ygdmlldy5cbiAgICAgKi9cbiAgICBmb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICBUZXh0SW5wdXRTdGF0ZS5mb2N1c1RleHRJbnB1dChmaW5kTm9kZUhhbmRsZSh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZm9jdXMgZnJvbSBhbiBpbnB1dCBvciB2aWV3LiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBgZm9jdXMoKWAuXG4gICAgICovXG4gICAgYmx1cjogZnVuY3Rpb24oKSB7XG4gICAgICBUZXh0SW5wdXRTdGF0ZS5ibHVyVGV4dElucHV0KGZpbmROb2RlSGFuZGxlKHRoaXMpKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIC8vIGhpZGUgdGhpcyBmcm9tIEZsb3cgc2luY2Ugd2UgY2FuJ3QgZGVmaW5lIHRoZXNlIHByb3BlcnRpZXMgb3V0c2lkZSBvZlxuICAgIC8vIHRydWUgd2l0aG91dCBhY3R1YWxseSBpbXBsZW1lbnRpbmcgdGhlbSAoc2V0dGluZyB0aGVtIHRvIHVuZGVmaW5lZFxuICAgIC8vIGlzbid0IGFsbG93ZWQgYnkgUmVhY3RDbGFzcylcbiAgICB2YXIgTmF0aXZlTWV0aG9kc01peGluX0RFViA9IE5hdGl2ZU1ldGhvZHNNaXhpbjtcbiAgICBpbnZhcmlhbnQoXG4gICAgICAhTmF0aXZlTWV0aG9kc01peGluX0RFVi5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgIU5hdGl2ZU1ldGhvZHNNaXhpbl9ERVYuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAhTmF0aXZlTWV0aG9kc01peGluX0RFVi5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICFOYXRpdmVNZXRob2RzTWl4aW5fREVWLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLFxuICAgICAgXCJEbyBub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZnVuY3Rpb25zLlwiXG4gICAgKTtcbiAgICAvLyBUT0RPIChidmF1Z2huKSBSZW1vdmUgY1dNIGFuZCBjV1JQIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3QgTmF0aXZlLFxuICAgIC8vIE9uY2UgdGhlc2UgbGlmZWN5Y2xlcyBoYXZlIGJlZW4gcmVtb3ZlIGZyb20gdGhlIHJlY29uY2lsZXIuXG4gICAgTmF0aXZlTWV0aG9kc01peGluX0RFVi5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93T25TdHlsZXNQcm9wKHRoaXMsIHRoaXMucHJvcHMpO1xuICAgIH07XG4gICAgTmF0aXZlTWV0aG9kc01peGluX0RFVi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICAgIHRocm93T25TdHlsZXNQcm9wKHRoaXMsIG5ld1Byb3BzKTtcbiAgICB9O1xuICAgIE5hdGl2ZU1ldGhvZHNNaXhpbl9ERVYuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3dPblN0eWxlc1Byb3AodGhpcywgdGhpcy5wcm9wcyk7XG4gICAgfTtcbiAgICBOYXRpdmVNZXRob2RzTWl4aW5fREVWLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24oXG4gICAgICBuZXdQcm9wc1xuICAgICkge1xuICAgICAgdGhyb3dPblN0eWxlc1Byb3AodGhpcywgbmV3UHJvcHMpO1xuICAgIH07XG5cbiAgICAvLyBSZWFjdCBtYXkgd2FybiBhYm91dCBjV00vY1dSUC9jV1UgbWV0aG9kcyBiZWluZyBkZXByZWNhdGVkLlxuICAgIC8vIEFkZCBhIGZsYWcgdG8gc3VwcHJlc3MgdGhlc2Ugd2FybmluZ3MgZm9yIHRoaXMgc3BlY2lhbCBjYXNlLlxuICAgIC8vIFRPRE8gKGJ2YXVnaG4pIFJlbW92ZSB0aGlzIGZsYWcgb25jZSB0aGUgYWJvdmUgbWV0aG9kcyBoYXZlIGJlZW4gcmVtb3ZlZC5cbiAgICBOYXRpdmVNZXRob2RzTWl4aW5fREVWLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nID0gdHJ1ZTtcbiAgICBOYXRpdmVNZXRob2RzTWl4aW5fREVWLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gTmF0aXZlTWV0aG9kc01peGluO1xufTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJDEoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcbiAgICAgIFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKVxuICAgID8gY2FsbFxuICAgIDogc2VsZjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICtcbiAgICAgICAgdHlwZW9mIHN1cGVyQ2xhc3NcbiAgICApO1xuICB9XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mXG4gICAgICA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcylcbiAgICAgIDogKHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3MpO1xufVxuXG4vLyBNb2R1bGVzIHByb3ZpZGVkIGJ5IFJOOlxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24oZmluZE5vZGVIYW5kbGUsIGZpbmRIb3N0SW5zdGFuY2UpIHtcbiAgLyoqXG4gICAqIFN1cGVyY2xhc3MgdGhhdCBwcm92aWRlcyBtZXRob2RzIHRvIGFjY2VzcyB0aGUgdW5kZXJseWluZyBuYXRpdmUgY29tcG9uZW50LlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBmb2N1cyBhIHZpZXcgb3IgbWVhc3VyZSBpdHMgZGltZW5zaW9ucy5cbiAgICpcbiAgICogTWV0aG9kcyBpbXBsZW1lbnRlZCBieSB0aGlzIGNsYXNzIGFyZSBhdmFpbGFibGUgb24gbW9zdCBkZWZhdWx0IGNvbXBvbmVudHNcbiAgICogcHJvdmlkZWQgYnkgUmVhY3QgTmF0aXZlLiBIb3dldmVyLCB0aGV5IGFyZSAqbm90KiBhdmFpbGFibGUgb24gY29tcG9zaXRlXG4gICAqIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IGRpcmVjdGx5IGJhY2tlZCBieSBhIG5hdGl2ZSB2aWV3LiBGb3IgbW9yZVxuICAgKiBpbmZvcm1hdGlvbiwgc2VlIFtEaXJlY3QgTWFuaXB1bGF0aW9uXShkb2NzL2RpcmVjdC1tYW5pcHVsYXRpb24uaHRtbCkuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgdmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gKGZ1bmN0aW9uKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHMoUmVhY3ROYXRpdmVDb21wb25lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gUmVhY3ROYXRpdmVDb21wb25lbnQoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBSZWFjdE5hdGl2ZUNvbXBvbmVudCk7XG5cbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZm9jdXMuIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIGBmb2N1cygpYC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIER1ZSB0byBidWdzIGluIEZsb3cncyBoYW5kbGluZyBvZiBSZWFjdC5jcmVhdGVDbGFzcywgc29tZSBmaWVsZHMgYWxyZWFkeVxuICAgICAqIGRlY2xhcmVkIGluIHRoZSBiYXNlIGNsYXNzIG5lZWQgdG8gYmUgcmVkZWNsYXJlZCBiZWxvdy5cbiAgICAgKi9cbiAgICBSZWFjdE5hdGl2ZUNvbXBvbmVudC5wcm90b3R5cGUuYmx1ciA9IGZ1bmN0aW9uIGJsdXIoKSB7XG4gICAgICBUZXh0SW5wdXRTdGF0ZS5ibHVyVGV4dElucHV0KGZpbmROb2RlSGFuZGxlKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgZm9jdXMuIFRoZSBleGFjdCBiZWhhdmlvciBkZXBlbmRzIG9uIHRoZSBwbGF0Zm9ybSBhbmQgdmlldy5cbiAgICAgKi9cblxuICAgIFJlYWN0TmF0aXZlQ29tcG9uZW50LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgICAgVGV4dElucHV0U3RhdGUuZm9jdXNUZXh0SW5wdXQoZmluZE5vZGVIYW5kbGUodGhpcykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlcyB0aGUgb24tc2NyZWVuIGxvY2F0aW9uIGFuZCBkaW1lbnNpb25zLiBJZiBzdWNjZXNzZnVsLCB0aGUgY2FsbGJhY2tcbiAgICAgKiB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgICAqXG4gICAgICogIC0geFxuICAgICAqICAtIHlcbiAgICAgKiAgLSB3aWR0aFxuICAgICAqICAtIGhlaWdodFxuICAgICAqICAtIHBhZ2VYXG4gICAgICogIC0gcGFnZVlcbiAgICAgKlxuICAgICAqIFRoZXNlIHZhbHVlcyBhcmUgbm90IGF2YWlsYWJsZSB1bnRpbCBhZnRlciBuYXRpdmVzIHJlbmRlcmluZyBjb21wbGV0ZXMuIElmXG4gICAgICogeW91IG5lZWQgdGhlIG1lYXN1cmVtZW50cyBhcyBzb29uIGFzIHBvc3NpYmxlLCBjb25zaWRlciB1c2luZyB0aGVcbiAgICAgKiBbYG9uTGF5b3V0YCBwcm9wXShkb2NzL3ZpZXcuaHRtbCNvbmxheW91dCkgaW5zdGVhZC5cbiAgICAgKi9cblxuICAgIFJlYWN0TmF0aXZlQ29tcG9uZW50LnByb3RvdHlwZS5tZWFzdXJlID0gZnVuY3Rpb24gbWVhc3VyZShjYWxsYmFjaykge1xuICAgICAgVUlNYW5hZ2VyLm1lYXN1cmUoXG4gICAgICAgIGZpbmROb2RlSGFuZGxlKHRoaXMpLFxuICAgICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgY2FsbGJhY2spXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlcyB0aGUgb24tc2NyZWVuIGxvY2F0aW9uIGFuZCBkaW1lbnNpb25zLiBFdmVuIGlmIHRoZSBSZWFjdCBOYXRpdmVcbiAgICAgKiByb290IHZpZXcgaXMgZW1iZWRkZWQgd2l0aGluIGFub3RoZXIgbmF0aXZlIHZpZXcsIHRoaXMgbWV0aG9kIHdpbGwgZ2l2ZSB5b3VcbiAgICAgKiB0aGUgYWJzb2x1dGUgY29vcmRpbmF0ZXMgbWVhc3VyZWQgZnJvbSB0aGUgd2luZG93LiBJZiBzdWNjZXNzZnVsLCB0aGVcbiAgICAgKiBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgICAqXG4gICAgICogIC0geFxuICAgICAqICAtIHlcbiAgICAgKiAgLSB3aWR0aFxuICAgICAqICAtIGhlaWdodFxuICAgICAqXG4gICAgICogVGhlc2UgdmFsdWVzIGFyZSBub3QgYXZhaWxhYmxlIHVudGlsIGFmdGVyIG5hdGl2ZXMgcmVuZGVyaW5nIGNvbXBsZXRlcy5cbiAgICAgKi9cblxuICAgIFJlYWN0TmF0aXZlQ29tcG9uZW50LnByb3RvdHlwZS5tZWFzdXJlSW5XaW5kb3cgPSBmdW5jdGlvbiBtZWFzdXJlSW5XaW5kb3coXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgVUlNYW5hZ2VyLm1lYXN1cmVJbldpbmRvdyhcbiAgICAgICAgZmluZE5vZGVIYW5kbGUodGhpcyksXG4gICAgICAgIG1vdW50U2FmZUNhbGxiYWNrX05PVF9SRUFMTFlfU0FGRSh0aGlzLCBjYWxsYmFjaylcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gW2BtZWFzdXJlKClgXSgjbWVhc3VyZSksIGJ1dCB0aGUgcmVzdWx0aW5nIGxvY2F0aW9uIHdpbGwgYmVcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgc3VwcGxpZWQgYW5jZXN0b3IncyBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIE9idGFpbiBhIG5hdGl2ZSBub2RlIGhhbmRsZSB3aXRoIGBSZWFjdE5hdGl2ZS5maW5kTm9kZUhhbmRsZShjb21wb25lbnQpYC5cbiAgICAgKi9cblxuICAgIFJlYWN0TmF0aXZlQ29tcG9uZW50LnByb3RvdHlwZS5tZWFzdXJlTGF5b3V0ID0gZnVuY3Rpb24gbWVhc3VyZUxheW91dChcbiAgICAgIHJlbGF0aXZlVG9OYXRpdmVOb2RlLFxuICAgICAgb25TdWNjZXNzLFxuICAgICAgb25GYWlsIC8qIGN1cnJlbnRseSB1bnVzZWQgKi9cbiAgICApIHtcbiAgICAgIFVJTWFuYWdlci5tZWFzdXJlTGF5b3V0KFxuICAgICAgICBmaW5kTm9kZUhhbmRsZSh0aGlzKSxcbiAgICAgICAgcmVsYXRpdmVUb05hdGl2ZU5vZGUsXG4gICAgICAgIG1vdW50U2FmZUNhbGxiYWNrX05PVF9SRUFMTFlfU0FGRSh0aGlzLCBvbkZhaWwpLFxuICAgICAgICBtb3VudFNhZmVDYWxsYmFja19OT1RfUkVBTExZX1NBRkUodGhpcywgb25TdWNjZXNzKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzZW5kcyBwcm9wcyBzdHJhaWdodCB0byBuYXRpdmUuIFRoZXkgd2lsbCBub3QgcGFydGljaXBhdGUgaW5cbiAgICAgKiBmdXR1cmUgZGlmZiBwcm9jZXNzIC0gdGhpcyBtZWFucyB0aGF0IGlmIHlvdSBkbyBub3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgICAqIG5leHQgcmVuZGVyLCB0aGV5IHdpbGwgcmVtYWluIGFjdGl2ZSAoc2VlIFtEaXJlY3RcbiAgICAgKiBNYW5pcHVsYXRpb25dKGRvY3MvZGlyZWN0LW1hbmlwdWxhdGlvbi5odG1sKSkuXG4gICAgICovXG5cbiAgICBSZWFjdE5hdGl2ZUNvbXBvbmVudC5wcm90b3R5cGUuc2V0TmF0aXZlUHJvcHMgPSBmdW5jdGlvbiBzZXROYXRpdmVQcm9wcyhcbiAgICAgIG5hdGl2ZVByb3BzXG4gICAgKSB7XG4gICAgICAvLyBDbGFzcyBjb21wb25lbnRzIGRvbid0IGhhdmUgdmlld0NvbmZpZyAtPiB2YWxpZGF0ZUF0dHJpYnV0ZXMuXG4gICAgICAvLyBOb3IgZG9lcyBpdCBtYWtlIHNlbnNlIHRvIHNldCBuYXRpdmUgcHJvcHMgb24gYSBub24tbmF0aXZlIGNvbXBvbmVudC5cbiAgICAgIC8vIEluc3RlYWQsIGZpbmQgdGhlIG5lYXJlc3QgaG9zdCBjb21wb25lbnQgYW5kIHNldCBwcm9wcyBvbiBpdC5cbiAgICAgIC8vIFVzZSBmaW5kTm9kZUhhbmRsZSgpIHJhdGhlciB0aGFuIFJlYWN0TmF0aXZlLmZpbmROb2RlSGFuZGxlKCkgYmVjYXVzZVxuICAgICAgLy8gV2Ugd2FudCB0aGUgaW5zdGFuY2Uvd3JhcHBlciAobm90IHRoZSBuYXRpdmUgdGFnKS5cbiAgICAgIHZhciBtYXliZUluc3RhbmNlID0gdm9pZCAwO1xuXG4gICAgICAvLyBGaWJlciBlcnJvcnMgaWYgZmluZE5vZGVIYW5kbGUgaXMgY2FsbGVkIGZvciBhbiB1bW91bnRlZCBjb21wb25lbnQuXG4gICAgICAvLyBUZXN0cyB1c2luZyBSZWFjdFRlc3RSZW5kZXJlciB3aWxsIHRyaWdnZXIgdGhpcyBjYXNlIGluZGlyZWN0bHkuXG4gICAgICAvLyBNaW1pY2tpbmcgc3RhY2sgYmVoYXZpb3IsIHdlIHNob3VsZCBzaWxlbnRseSBpZ25vcmUgdGhpcyBjYXNlLlxuICAgICAgLy8gVE9ETyBGaXggUmVhY3RUZXN0UmVuZGVyZXIgc28gd2UgY2FuIHJlbW92ZSB0aGlzIHRyeS9jYXRjaC5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1heWJlSW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGhvc3QgY29tcG9uZW50IGJlbmVhdGggdGhpcyB3ZSBzaG91bGQgZmFpbCBzaWxlbnRseS5cbiAgICAgIC8vIFRoaXMgaXMgbm90IGFuIGVycm9yOyBpdCBjb3VsZCBtZWFuIGEgY2xhc3MgY29tcG9uZW50IHJlbmRlcmVkIG51bGwuXG4gICAgICBpZiAobWF5YmVJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZpZXdDb25maWcgPVxuICAgICAgICBtYXliZUluc3RhbmNlLnZpZXdDb25maWcgfHwgbWF5YmVJbnN0YW5jZS5jYW5vbmljYWwudmlld0NvbmZpZztcblxuICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBjcmVhdGUobmF0aXZlUHJvcHMsIHZpZXdDb25maWcudmFsaWRBdHRyaWJ1dGVzKTtcblxuICAgICAgLy8gQXZvaWQgdGhlIG92ZXJoZWFkIG9mIGJyaWRnZSBjYWxscyBpZiB0aGVyZSdzIG5vIHVwZGF0ZS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gZXhwZW5zaXZlIG5vLW9wIGZvciBBbmRyb2lkLCBhbmQgY2F1c2VzIGFuIHVubmVjZXNzYXJ5XG4gICAgICAvLyB2aWV3IGludmFsaWRhdGlvbiBmb3IgY2VydGFpbiBjb21wb25lbnRzIChlZyBSQ1RUZXh0SW5wdXQpIG9uIGlPUy5cbiAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9IG51bGwpIHtcbiAgICAgICAgVUlNYW5hZ2VyLnVwZGF0ZVZpZXcoXG4gICAgICAgICAgbWF5YmVJbnN0YW5jZS5fbmF0aXZlVGFnLFxuICAgICAgICAgIHZpZXdDb25maWcudWlWaWV3Q2xhc3NOYW1lLFxuICAgICAgICAgIHVwZGF0ZVBheWxvYWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0TmF0aXZlQ29tcG9uZW50O1xuICB9KShSZWFjdC5Db21wb25lbnQpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICByZXR1cm4gUmVhY3ROYXRpdmVDb21wb25lbnQ7XG59O1xuXG4vLyBNb2R1bGUgcHJvdmlkZWQgYnkgUk46XG52YXIgZW1wdHlPYmplY3QkMiA9IHt9O1xue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0JDIpO1xufVxuXG52YXIgZ2V0SW5zcGVjdG9yRGF0YUZvclZpZXdUYWcgPSB2b2lkIDA7XG5cbntcbiAgdmFyIHRyYXZlcnNlT3duZXJUcmVlVXAgPSBmdW5jdGlvbihoaWVyYXJjaHksIGluc3RhbmNlKSB7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBoaWVyYXJjaHkudW5zaGlmdChpbnN0YW5jZSk7XG4gICAgICB0cmF2ZXJzZU93bmVyVHJlZVVwKGhpZXJhcmNoeSwgaW5zdGFuY2UuX2RlYnVnT3duZXIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0T3duZXJIaWVyYXJjaHkgPSBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBbXTtcbiAgICB0cmF2ZXJzZU93bmVyVHJlZVVwKGhpZXJhcmNoeSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiBoaWVyYXJjaHk7XG4gIH07XG5cbiAgdmFyIGxhc3ROb25Ib3N0SW5zdGFuY2UgPSBmdW5jdGlvbihoaWVyYXJjaHkpIHtcbiAgICBmb3IgKHZhciBpID0gaGllcmFyY2h5Lmxlbmd0aCAtIDE7IGkgPiAxOyBpLS0pIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGhpZXJhcmNoeVtpXTtcblxuICAgICAgaWYgKGluc3RhbmNlLnRhZyAhPT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoaWVyYXJjaHlbMF07XG4gIH07XG5cbiAgdmFyIGdldEhvc3RQcm9wcyA9IGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgdmFyIGhvc3QgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3QpIHtcbiAgICAgIHJldHVybiBob3N0Lm1lbW9pemVkUHJvcHMgfHwgZW1wdHlPYmplY3QkMjtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0JDI7XG4gIH07XG5cbiAgdmFyIGdldEhvc3ROb2RlID0gZnVuY3Rpb24oZmliZXIsIGZpbmROb2RlSGFuZGxlKSB7XG4gICAgdmFyIGhvc3ROb2RlID0gdm9pZCAwO1xuICAgIC8vIGxvb2sgZm9yIGNoaWxkcmVuIGZpcnN0IGZvciB0aGUgaG9zdE5vZGVcbiAgICAvLyBhcyBjb21wb3NpdGUgZmliZXJzIGRvIG5vdCBoYXZlIGEgaG9zdE5vZGVcbiAgICB3aGlsZSAoZmliZXIpIHtcbiAgICAgIGlmIChmaWJlci5zdGF0ZU5vZGUgIT09IG51bGwgJiYgZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIGhvc3ROb2RlID0gZmluZE5vZGVIYW5kbGUoZmliZXIuc3RhdGVOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChob3N0Tm9kZSkge1xuICAgICAgICByZXR1cm4gaG9zdE5vZGU7XG4gICAgICB9XG4gICAgICBmaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgY3JlYXRlSGllcmFyY2h5ID0gZnVuY3Rpb24oZmliZXJIaWVyYXJjaHkpIHtcbiAgICByZXR1cm4gZmliZXJIaWVyYXJjaHkubWFwKGZ1bmN0aW9uKGZpYmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpLFxuICAgICAgICBnZXRJbnNwZWN0b3JEYXRhOiBmdW5jdGlvbihmaW5kTm9kZUhhbmRsZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWFzdXJlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICByZXR1cm4gVUlNYW5hZ2VyLm1lYXN1cmUoXG4gICAgICAgICAgICAgICAgZ2V0SG9zdE5vZGUoZmliZXIsIGZpbmROb2RlSGFuZGxlKSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BzOiBnZXRIb3N0UHJvcHMoZmliZXIpLFxuICAgICAgICAgICAgc291cmNlOiBmaWJlci5fZGVidWdTb3VyY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIGdldEluc3BlY3RvckRhdGFGb3JWaWV3VGFnID0gZnVuY3Rpb24odmlld1RhZykge1xuICAgIHZhciBjbG9zZXN0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21UYWcodmlld1RhZyk7XG5cbiAgICAvLyBIYW5kbGUgY2FzZSB3aGVyZSB1c2VyIGNsaWNrcyBvdXRzaWRlIG9mIFJlYWN0TmF0aXZlXG4gICAgaWYgKCFjbG9zZXN0SW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhpZXJhcmNoeTogW10sXG4gICAgICAgIHByb3BzOiBlbXB0eU9iamVjdCQyLFxuICAgICAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgICAgIHNvdXJjZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChjbG9zZXN0SW5zdGFuY2UpO1xuICAgIHZhciBmaWJlckhpZXJhcmNoeSA9IGdldE93bmVySGllcmFyY2h5KGZpYmVyKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBsYXN0Tm9uSG9zdEluc3RhbmNlKGZpYmVySGllcmFyY2h5KTtcbiAgICB2YXIgaGllcmFyY2h5ID0gY3JlYXRlSGllcmFyY2h5KGZpYmVySGllcmFyY2h5KTtcbiAgICB2YXIgcHJvcHMgPSBnZXRIb3N0UHJvcHMoaW5zdGFuY2UpO1xuICAgIHZhciBzb3VyY2UgPSBpbnN0YW5jZS5fZGVidWdTb3VyY2U7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGZpYmVySGllcmFyY2h5LmluZGV4T2YoaW5zdGFuY2UpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZXJhcmNoeTogaGllcmFyY2h5LFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24sXG4gICAgICBzb3VyY2U6IHNvdXJjZVxuICAgIH07XG4gIH07XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbi8vIE1vZHVsZSBwcm92aWRlZCBieSBSTjpcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGZpbmRIb3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlJDE7XG5cbmZ1bmN0aW9uIGZpbmROb2RlSGFuZGxlKGNvbXBvbmVudE9ySGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICFvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyXG4gICAgICAgID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBcIiVzIGlzIGFjY2Vzc2luZyBmaW5kTm9kZUhhbmRsZSBpbnNpZGUgaXRzIHJlbmRlcigpLiBcIiArXG4gICAgICAgICAgICAgIFwicmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCBcIiArXG4gICAgICAgICAgICAgIFwibmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgXCIgK1xuICAgICAgICAgICAgICBcInJlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kIFwiICtcbiAgICAgICAgICAgICAgXCJjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkgfHwgXCJBIGNvbXBvbmVudFwiXG4gICAgICAgICAgKVxuICAgICAgICA6IHZvaWQgMDtcblxuICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckhhbmRsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRPckhhbmRsZSA9PT0gXCJudW1iZXJcIikge1xuICAgIC8vIEFscmVhZHkgYSBub2RlIGhhbmRsZVxuICAgIHJldHVybiBjb21wb25lbnRPckhhbmRsZTtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JIYW5kbGUuX25hdGl2ZVRhZykge1xuICAgIHJldHVybiBjb21wb25lbnRPckhhbmRsZS5fbmF0aXZlVGFnO1xuICB9XG4gIGlmIChjb21wb25lbnRPckhhbmRsZS5jYW5vbmljYWwgJiYgY29tcG9uZW50T3JIYW5kbGUuY2Fub25pY2FsLl9uYXRpdmVUYWcpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JIYW5kbGUuY2Fub25pY2FsLl9uYXRpdmVUYWc7XG4gIH1cbiAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50T3JIYW5kbGUpO1xuICBpZiAoaG9zdEluc3RhbmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlO1xuICB9XG4gIGlmIChob3N0SW5zdGFuY2UuY2Fub25pY2FsKSB7XG4gICAgLy8gRmFicmljXG4gICAgcmV0dXJuIGhvc3RJbnN0YW5jZS5jYW5vbmljYWwuX25hdGl2ZVRhZztcbiAgfVxuICByZXR1cm4gaG9zdEluc3RhbmNlLl9uYXRpdmVUYWc7XG59XG5cbnNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oXG4gIGJhdGNoZWRVcGRhdGVzJDEsXG4gIGludGVyYWN0aXZlVXBkYXRlcyQxLFxuICBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxXG4pO1xuXG5mdW5jdGlvbiBjb21wdXRlQ29tcG9uZW50U3RhY2tGb3JFcnJvclJlcG9ydGluZyhyZWFjdFRhZykge1xuICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21UYWcocmVhY3RUYWcpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlcik7XG59XG5cbnZhciByb290cyA9IG5ldyBNYXAoKTtcblxudmFyIFJlYWN0TmF0aXZlUmVuZGVyZXIgPSB7XG4gIE5hdGl2ZUNvbXBvbmVudDogUmVhY3ROYXRpdmVDb21wb25lbnQoZmluZE5vZGVIYW5kbGUsIGZpbmRIb3N0SW5zdGFuY2UpLFxuXG4gIGZpbmROb2RlSGFuZGxlOiBmaW5kTm9kZUhhbmRsZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGNvbnRhaW5lclRhZywgY2FsbGJhY2spIHtcbiAgICB2YXIgcm9vdCA9IHJvb3RzLmdldChjb250YWluZXJUYWcpO1xuXG4gICAgaWYgKCFyb290KSB7XG4gICAgICAvLyBUT0RPIChidmF1Z2huKTogSWYgd2UgZGVjaWRlIHRvIGtlZXAgdGhlIHdyYXBwZXIgY29tcG9uZW50LFxuICAgICAgLy8gV2UgY291bGQgY3JlYXRlIGEgd3JhcHBlciBmb3IgY29udGFpbmVyVGFnIGFzIHdlbGwgdG8gcmVkdWNlIHNwZWNpYWwgY2FzaW5nLlxuICAgICAgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJUYWcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICByb290cy5zZXQoY29udGFpbmVyVGFnLCByb290KTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uKGNvbnRhaW5lclRhZykge1xuICAgIHZhciByb290ID0gcm9vdHMuZ2V0KGNvbnRhaW5lclRhZyk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIC8vIFRPRE86IElzIGl0IHNhZmUgdG8gcmVzZXQgdGhpcyBub3cgb3Igc2hvdWxkIEkgd2FpdCBzaW5jZSB0aGlzIHVubW91bnQgY291bGQgYmUgZGVmZXJyZWQ/XG4gICAgICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJvb3RzLmRlbGV0ZShjb250YWluZXJUYWcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlQW5kUmVtb3ZlQ29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXJUYWcpIHtcbiAgICBSZWFjdE5hdGl2ZVJlbmRlcmVyLnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyVGFnKTtcblxuICAgIC8vIENhbGwgYmFjayBpbnRvIG5hdGl2ZSB0byByZW1vdmUgYWxsIG9mIHRoZSBzdWJ2aWV3cyBmcm9tIHRoaXMgY29udGFpbmVyXG4gICAgVUlNYW5hZ2VyLnJlbW92ZVJvb3RWaWV3KGNvbnRhaW5lclRhZyk7XG4gIH0sXG4gIGNyZWF0ZVBvcnRhbDogZnVuY3Rpb24oY2hpbGRyZW4sIGNvbnRhaW5lclRhZykge1xuICAgIHZhciBrZXkgPVxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyVGFnLCBudWxsLCBrZXkpO1xuICB9LFxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIFVzZWQgYXMgYSBtaXhpbiBpbiBtYW55IGNyZWF0ZUNsYXNzLWJhc2VkIGNvbXBvbmVudHNcbiAgICBOYXRpdmVNZXRob2RzTWl4aW46IE5hdGl2ZU1ldGhvZHNNaXhpbihmaW5kTm9kZUhhbmRsZSwgZmluZEhvc3RJbnN0YW5jZSksXG4gICAgY29tcHV0ZUNvbXBvbmVudFN0YWNrRm9yRXJyb3JSZXBvcnRpbmc6IGNvbXB1dGVDb21wb25lbnRTdGFja0ZvckVycm9yUmVwb3J0aW5nXG4gIH1cbn07XG5cbmluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRJbnN0YW5jZUZyb21UYWcsXG4gIGdldEluc3BlY3RvckRhdGFGb3JWaWV3VGFnOiBnZXRJbnNwZWN0b3JEYXRhRm9yVmlld1RhZyxcbiAgYnVuZGxlVHlwZTogMSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiBcInJlYWN0LW5hdGl2ZS1yZW5kZXJlclwiXG59KTtcblxudmFyIFJlYWN0TmF0aXZlUmVuZGVyZXIkMiA9IE9iamVjdC5mcmVlemUoe1xuICBkZWZhdWx0OiBSZWFjdE5hdGl2ZVJlbmRlcmVyXG59KTtcblxudmFyIFJlYWN0TmF0aXZlUmVuZGVyZXIkMyA9XG4gIChSZWFjdE5hdGl2ZVJlbmRlcmVyJDIgJiYgUmVhY3ROYXRpdmVSZW5kZXJlcikgfHwgUmVhY3ROYXRpdmVSZW5kZXJlciQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdE5hdGl2ZVJlbmRlcmVyID1cbiAgUmVhY3ROYXRpdmVSZW5kZXJlciQzLmRlZmF1bHQgfHwgUmVhY3ROYXRpdmVSZW5kZXJlciQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0TmF0aXZlUmVuZGVyZXI7XG5cbiAgfSkoKTtcbn1cbiJdfQ==